
Analyzing loop at embann.c:151
embann.c:151:43: note: ===== analyze_loop_nest =====
embann.c:151:43: note: === vect_analyze_loop_form ===
embann.c:151:43: note: not vectorized: control flow in loop.
embann.c:151:43: note: bad loop form.

Analyzing loop at embann.c:157
embann.c:157:68: note: ===== analyze_loop_nest =====
embann.c:157:68: note: === vect_analyze_loop_form ===
embann.c:157:68: note: not vectorized: control flow in loop.
embann.c:157:68: note: bad loop form.

Analyzing loop at embann.c:93
embann.c:93:55: note: ===== analyze_loop_nest =====
embann.c:93:55: note: === vect_analyze_loop_form ===
embann.c:93:55: note: not vectorized: multiple nested loops.
embann.c:93:55: note: bad loop form.

Analyzing loop at embann.c:105
embann.c:105:47: note: ===== analyze_loop_nest =====
embann.c:105:47: note: === vect_analyze_loop_form ===
embann.c:105:47: note: not vectorized: control flow in loop.
embann.c:105:47: note: bad loop form.

Analyzing loop at embann.c:111
embann.c:111:71: note: ===== analyze_loop_nest =====
embann.c:111:71: note: === vect_analyze_loop_form ===
embann.c:111:71: note: not vectorized: control flow in loop.
embann.c:111:71: note: bad loop form.

Analyzing loop at embann.c:76
embann.c:76:5: note: ===== analyze_loop_nest =====
embann.c:76:5: note: === vect_analyze_loop_form ===
embann.c:76:5: note: === get_loop_niters ===
embann.c:76:5: note: Symbolic number of iterations is numInputNeurons_16(D)
embann.c:76:5: note: not vectorized: loop contains function calls or data references that cannot be analyzed
embann.c:42:6: note: vectorized 0 loops in function.
embann.c:42:6: note: ===vect_slp_analyze_bb===
embann.c:47:28: note: === vect_analyze_data_refs ===
embann.c:47:28: note: not vectorized: not enough data-refs in basic block.
embann.c:49:8: note: === vect_analyze_data_refs ===
embann.c:49:8: note: got vectype for stmt: network = _4;
vector(2) long unsigned int
embann.c:49:8: note: not vectorized: not enough data-refs in basic block.
embann.c:49:8: note: ===vect_slp_analyze_bb===
embann.c:49:20: note: ===vect_slp_analyze_bb===
embann.c:65:48: note: === vect_analyze_data_refs ===
embann.c:65:48: note: not vectorized: not enough data-refs in basic block.
embann.c:67:8: note: === vect_analyze_data_refs ===
embann.c:67:8: note: not vectorized: not enough data-refs in basic block.
embann.c:67:8: note: ===vect_slp_analyze_bb===
embann.c:71:5: note: === vect_analyze_data_refs ===
embann.c:71:5: note: not vectorized: not enough data-refs in basic block.
embann.c:76:5: note: === vect_analyze_data_refs ===
embann.c:76:5: note: got vectype for stmt: inputLayer_107->numNeurons = numInputNeurons_16(D);
vector(8) short unsigned int
embann.c:76:5: note: not vectorized: not enough data-refs in basic block.
embann.c:76:5: note: ===vect_slp_analyze_bb===
embann.c:84:5: note: === vect_analyze_data_refs ===
embann.c:84:5: note: got vectype for stmt: network.6_115 = network;
vector(2) long unsigned int
embann.c:84:5: note: not vectorized: no vectype for stmt: network.6_115->inputLayer = *inputLayer_107;
 scalar_type: struct inputLayer_t
embann.c:84:5: note: not vectorized: more than one data ref in stmt: network.6_115->inputLayer = *inputLayer_107;
embann.c:84:5: note: === vect_analyze_data_ref_accesses ===
embann.c:84:5: note: not consecutive access network.6_115 = network;
embann.c:84:5: note: not vectorized: no grouped stores in basic block.
embann.c:91:5: note: === vect_analyze_data_refs ===
embann.c:91:5: note: not vectorized: not enough data-refs in basic block.
embann.c:91:5: note: ===vect_slp_analyze_bb===
embann.c:91:5: note: ===vect_slp_analyze_bb===
embann.c:76:5: note: === vect_analyze_data_refs ===
embann.c:76:5: note: got vectype for stmt: inputLayer_107->neuron[_112] = pNeuron_110;
vector(2) long unsigned int
embann.c:76:5: note: got vectype for stmt: pNeuron_110->activation = 0.0;
vector(4) float
embann.c:76:5: note: === vect_analyze_data_ref_accesses ===
embann.c:76:5: note: not consecutive access inputLayer_107->neuron[_112] = pNeuron_110;
embann.c:76:5: note: not consecutive access pNeuron_110->activation = 0.0;
embann.c:76:5: note: not vectorized: no grouped stores in basic block.
embann.c:76:5: note: ===vect_slp_analyze_bb===
embann.c:76:5: note: ===vect_slp_analyze_bb===
embann.c:139:51: note: === vect_analyze_data_refs ===
embann.c:139:51: note: not vectorized: not enough data-refs in basic block.
embann.c:141:8: note: === vect_analyze_data_refs ===
embann.c:141:8: note: not vectorized: not enough data-refs in basic block.
embann.c:141:8: note: ===vect_slp_analyze_bb===
embann.c:93:55: note: === vect_analyze_data_refs ===
embann.c:93:55: note: not vectorized: not enough data-refs in basic block.
embann.c:93:55: note: ===vect_slp_analyze_bb===
embann.c:95:12: note: === vect_analyze_data_refs ===
embann.c:95:12: note: not vectorized: not enough data-refs in basic block.
embann.c:95:12: note: ===vect_slp_analyze_bb===
embann.c:99:9: note: === vect_analyze_data_refs ===
embann.c:99:9: note: not vectorized: not enough data-refs in basic block.
embann.c:103:9: note: === vect_analyze_data_refs ===
embann.c:103:9: note: not vectorized: not enough data-refs in basic block.
embann.c:103:9: note: ===vect_slp_analyze_bb===
embann.c:131:9: note: === vect_analyze_data_refs ===
embann.c:131:9: note: got vectype for stmt: network.12_97 = network;
vector(2) long unsigned int
embann.c:131:9: note: not vectorized: no vectype for stmt: network.12_97->hiddenLayer[_98] = *hiddenLayer_65;
 scalar_type: struct hiddenLayer_t
embann.c:131:9: note: not vectorized: more than one data ref in stmt: network.12_97->hiddenLayer[_98] = *hiddenLayer_65;
embann.c:131:9: note: === vect_analyze_data_ref_accesses ===
embann.c:131:9: note: not consecutive access network.12_97 = network;
embann.c:131:9: note: not vectorized: no grouped stores in basic block.
embann.c:91:5: note: === vect_analyze_data_refs ===
embann.c:91:5: note: not vectorized: not enough data-refs in basic block.
embann.c:91:5: note: ===vect_slp_analyze_bb===
embann.c:91:5: note: ===vect_slp_analyze_bb===
embann.c:91:5: note: === vect_analyze_data_refs ===
embann.c:91:5: note: not vectorized: not enough data-refs in basic block.
embann.c:91:5: note: ===vect_slp_analyze_bb===
embann.c:109:13: note: === vect_analyze_data_refs ===
embann.c:109:13: note: got vectype for stmt: hiddenLayer_65->neuron[_75] = pNeuron_73;
vector(2) long unsigned int
embann.c:109:13: note: got vectype for stmt: pNeuron_73->activation = 0.0;
vector(4) float
embann.c:109:13: note: === vect_analyze_data_ref_accesses ===
embann.c:109:13: note: not consecutive access hiddenLayer_65->neuron[_75] = pNeuron_73;
embann.c:109:13: note: not consecutive access pNeuron_73->activation = 0.0;
embann.c:109:13: note: not vectorized: no grouped stores in basic block.
embann.c:109:13: note: ===vect_slp_analyze_bb===
embann.c:109:13: note: ===vect_slp_analyze_bb===
embann.c:112:20: note: === vect_analyze_data_refs ===
embann.c:112:20: note: not vectorized: not enough data-refs in basic block.
embann.c:112:20: note: ===vect_slp_analyze_bb===
embann.c:120:67: note: === vect_analyze_data_refs ===
embann.c:120:67: note: got vectype for stmt: prephitmp_119->params[_172] = hiddenLayerParams_76;
vector(2) long unsigned int
embann.c:120:67: note: not vectorized: not enough data-refs in basic block.
embann.c:121:69: note: === vect_analyze_data_refs ===
embann.c:121:69: note: got vectype for stmt: _82 = hiddenLayer_65->neuron[_75];
vector(2) long unsigned int
embann.c:121:69: note: got vectype for stmt: _83 = _82->params[_172];
vector(2) long unsigned int
embann.c:121:69: note: got vectype for stmt: _83->bias = _84;
vector(4) float
embann.c:121:69: note: === vect_analyze_data_ref_accesses ===
embann.c:121:69: note: not consecutive access _82 = hiddenLayer_65->neuron[_75];
embann.c:121:69: note: not consecutive access _83 = _82->params[_172];
embann.c:121:69: note: not consecutive access _83->bias = _84;
embann.c:121:69: note: not vectorized: no grouped stores in basic block.
embann.c:109:13: note: === vect_analyze_data_refs ===
embann.c:109:13: note: got vectype for stmt: _88 = hiddenLayer_65->neuron[_75];
vector(2) long unsigned int
embann.c:109:13: note: got vectype for stmt: _89 = _88->params[_172];
vector(2) long unsigned int
embann.c:109:13: note: got vectype for stmt: _89->weight = _90;
vector(4) float
embann.c:109:13: note: === vect_analyze_data_ref_accesses ===
embann.c:109:13: note: not consecutive access _88 = hiddenLayer_65->neuron[_75];
embann.c:109:13: note: not consecutive access _89 = _88->params[_172];
embann.c:109:13: note: not consecutive access _89->weight = _90;
embann.c:109:13: note: not vectorized: no grouped stores in basic block.
embann.c:109:13: note: ===vect_slp_analyze_bb===
embann.c:109:13: note: ===vect_slp_analyze_bb===
embann.c:103:9: note: === vect_analyze_data_refs ===
embann.c:103:9: note: not vectorized: not enough data-refs in basic block.
embann.c:103:9: note: ===vect_slp_analyze_bb===
embann.c:103:9: note: ===vect_slp_analyze_bb===
embann.c:145:5: note: === vect_analyze_data_refs ===
embann.c:145:5: note: not vectorized: not enough data-refs in basic block.
embann.c:149:5: note: === vect_analyze_data_refs ===
embann.c:149:5: note: not vectorized: not enough data-refs in basic block.
embann.c:149:5: note: ===vect_slp_analyze_bb===
embann.c:169:5: note: === vect_analyze_data_refs ===
embann.c:169:5: note: got vectype for stmt: outputLayer_30->numNeurons = numOutputNeurons_20(D);
vector(8) short unsigned int
embann.c:169:5: note: got vectype for stmt: network.18_58 = network;
vector(2) long unsigned int
embann.c:169:5: note: not vectorized: no vectype for stmt: network.18_58->outputLayer = *outputLayer_30;
 scalar_type: struct outputLayer_t
embann.c:169:5: note: not vectorized: more than one data ref in stmt: network.18_58->outputLayer = *outputLayer_30;
embann.c:169:5: note: === vect_analyze_data_ref_accesses ===
embann.c:169:5: note: not consecutive access network.18_58 = network;
embann.c:169:5: note: not consecutive access outputLayer_30->numNeurons = numOutputNeurons_20(D);
embann.c:169:5: note: not vectorized: no grouped stores in basic block.
embann.c:61:1: note: === vect_analyze_data_refs ===
embann.c:61:1: note: got vectype for stmt: network.1_9 = network;
vector(2) long unsigned int
embann.c:61:1: note: got vectype for stmt: network.1_9->properties.numLayers = _10;
vector(16) unsigned char
embann.c:61:1: note: got vectype for stmt: network.1_9->properties.numHiddenLayers = numHiddenLayers_11(D);
vector(16) unsigned char
embann.c:61:1: note: got vectype for stmt: network.1_9->properties.networkResponse = 0;
vector(8) short unsigned int
embann.c:61:1: note: === vect_analyze_data_ref_accesses ===
embann.c:61:1: note: Detected interleaving store network.1_9->properties.numLayers and network.1_9->properties.numHiddenLayers
embann.c:61:1: note: not consecutive access network.1_9 = network;
embann.c:61:1: note: Detected interleaving store of size 2 starting with network.1_9->properties.numLayers = _10;
embann.c:61:1: note: not consecutive access network.1_9->properties.networkResponse = 0;
embann.c:61:1: note: === vect_pattern_recog ===
embann.c:61:1: note: === vect_analyze_slp ===
embann.c:61:1: note: Build SLP for network.1_9->properties.numLayers = _10;
embann.c:61:1: note: Build SLP failed: unrolling required in basic block SLP
embann.c:61:1: note: recording new base alignment for &network
embann.c:61:1: note:   alignment:    8
embann.c:61:1: note:   misalignment: 0
embann.c:61:1: note:   based on:     network.1_9 = network;
embann.c:61:1: note: recording new base alignment for network.1_9
embann.c:61:1: note:   alignment:    8
embann.c:61:1: note:   misalignment: 0
embann.c:61:1: note:   based on:     network.1_9->properties.numLayers = _10;
embann.c:61:1: note: ===vect_slp_analyze_bb===
embann.c:151:43: note: === vect_analyze_data_refs ===
embann.c:151:43: note: not vectorized: not enough data-refs in basic block.
embann.c:151:43: note: ===vect_slp_analyze_bb===
embann.c:155:9: note: === vect_analyze_data_refs ===
embann.c:155:9: note: got vectype for stmt: outputLayer_30->neuron[_38] = pNeuron_36;
vector(2) long unsigned int
embann.c:155:9: note: got vectype for stmt: pNeuron_36->activation = 0.0;
vector(4) float
embann.c:155:9: note: === vect_analyze_data_ref_accesses ===
embann.c:155:9: note: not consecutive access outputLayer_30->neuron[_38] = pNeuron_36;
embann.c:155:9: note: not consecutive access pNeuron_36->activation = 0.0;
embann.c:155:9: note: not vectorized: no grouped stores in basic block.
embann.c:155:9: note: ===vect_slp_analyze_bb===
embann.c:149:5: note: === vect_analyze_data_refs ===
embann.c:149:5: note: not vectorized: not enough data-refs in basic block.
embann.c:149:5: note: ===vect_slp_analyze_bb===
embann.c:149:5: note: ===vect_slp_analyze_bb===
embann.c:149:5: note: ===vect_slp_analyze_bb===
embann.c:158:16: note: === vect_analyze_data_refs ===
embann.c:158:16: note: not vectorized: not enough data-refs in basic block.
embann.c:158:16: note: ===vect_slp_analyze_bb===
embann.c:162:63: note: === vect_analyze_data_refs ===
embann.c:162:63: note: got vectype for stmt: prephitmp_121->params[_42] = outputNeuronParams_39;
vector(2) long unsigned int
embann.c:162:63: note: not vectorized: not enough data-refs in basic block.
embann.c:163:65: note: === vect_analyze_data_refs ===
embann.c:163:65: note: got vectype for stmt: _46 = outputLayer_30->neuron[_38];
vector(2) long unsigned int
embann.c:163:65: note: got vectype for stmt: _47 = _46->params[_42];
vector(2) long unsigned int
embann.c:163:65: note: got vectype for stmt: _47->bias = _48;
vector(4) float
embann.c:163:65: note: === vect_analyze_data_ref_accesses ===
embann.c:163:65: note: not consecutive access _46 = outputLayer_30->neuron[_38];
embann.c:163:65: note: not consecutive access _47 = _46->params[_42];
embann.c:163:65: note: not consecutive access _47->bias = _48;
embann.c:163:65: note: not vectorized: no grouped stores in basic block.
embann.c:155:9: note: === vect_analyze_data_refs ===
embann.c:155:9: note: got vectype for stmt: _52 = outputLayer_30->neuron[_38];
vector(2) long unsigned int
embann.c:155:9: note: got vectype for stmt: _53 = _52->params[_42];
vector(2) long unsigned int
embann.c:155:9: note: got vectype for stmt: _53->weight = _54;
vector(4) float
embann.c:155:9: note: === vect_analyze_data_ref_accesses ===
embann.c:155:9: note: not consecutive access _52 = outputLayer_30->neuron[_38];
embann.c:155:9: note: not consecutive access _53 = _52->params[_42];
embann.c:155:9: note: not consecutive access _53->weight = _54;
embann.c:155:9: note: not vectorized: no grouped stores in basic block.
embann.c:155:9: note: ===vect_slp_analyze_bb===

Analyzing loop at embann.c:174
embann.c:174:5: note: ===== analyze_loop_nest =====
embann.c:174:5: note: === vect_analyze_loop_form ===
embann.c:174:5: note: === get_loop_niters ===
embann.c:174:5: note: Symbolic number of iterations is (uint32_t) _18
embann.c:174:5: note: === vect_analyze_data_refs ===
embann.c:174:5: note: got vectype for stmt: _4 = network.20_17->inputLayer.neuron[i_21];
vector(2) long unsigned int
embann.c:174:5: note: got vectype for stmt: _5 = *_3;
vector(4) float
embann.c:174:5: note: got vectype for stmt: _4->activation = _5;
vector(4) float
embann.c:174:5: note: not vectorized: not suitable for scatter store _4->activation = _5;
embann.c:174:5: note: bad data references.
embann.c:172:6: note: vectorized 0 loops in function.
embann.c:172:6: note: ===vect_slp_analyze_bb===
embann.c:174:5: note: === vect_analyze_data_refs ===
embann.c:174:5: note: got vectype for stmt: network.20_17 = network;
vector(2) long unsigned int
embann.c:174:5: note: got vectype for stmt: _18 = network.20_17->inputLayer.numNeurons;
vector(8) short unsigned int
embann.c:174:5: note: === vect_analyze_data_ref_accesses ===
embann.c:174:5: note: not consecutive access network.20_17 = network;
embann.c:174:5: note: not consecutive access _18 = network.20_17->inputLayer.numNeurons;
embann.c:174:5: note: not vectorized: no grouped stores in basic block.
embann.c:174:5: note: ===vect_slp_analyze_bb===
embann.c:174:5: note: ===vect_slp_analyze_bb===
embann.c:174:5: note: === vect_analyze_data_refs ===
embann.c:174:5: note: got vectype for stmt: _4 = network.20_17->inputLayer.neuron[i_21];
vector(2) long unsigned int
embann.c:174:5: note: got vectype for stmt: _5 = *_3;
vector(4) float
embann.c:174:5: note: got vectype for stmt: _4->activation = _5;
vector(4) float
embann.c:174:5: note: === vect_analyze_data_ref_accesses ===
embann.c:174:5: note: not consecutive access _5 = *_3;
embann.c:174:5: note: not consecutive access _4->activation = _5;
embann.c:174:5: note: not consecutive access _4 = network.20_17->inputLayer.neuron[i_21];
embann.c:174:5: note: not vectorized: no grouped stores in basic block.
embann.c:174:5: note: ===vect_slp_analyze_bb===
embann.c:174:5: note: ===vect_slp_analyze_bb===
embann.c:178:1: note: === vect_analyze_data_refs ===
embann.c:178:1: note: not vectorized: not enough data-refs in basic block.

Analyzing loop at embann.c:182
embann.c:182:5: note: ===== analyze_loop_nest =====
embann.c:182:5: note: === vect_analyze_loop_form ===
embann.c:182:5: note: === get_loop_niters ===
embann.c:182:5: note: Symbolic number of iterations is (uint32_t) _27
embann.c:182:5: note: === vect_analyze_data_refs ===
embann.c:182:5: note: got vectype for stmt: _3 = *_2;
vector(16) unsigned char
embann.c:182:5: note: got vectype for stmt: _11 = network.22_26->inputLayer.neuron[i_30];
vector(2) long unsigned int
embann.c:182:5: note: got vectype for stmt: _11->activation = _12;
vector(4) float
embann.c:182:5: note: not vectorized: not suitable for scatter store _11->activation = _12;
embann.c:182:5: note: bad data references.
embann.c:180:6: note: vectorized 0 loops in function.
embann.c:180:6: note: ===vect_slp_analyze_bb===
embann.c:182:5: note: === vect_analyze_data_refs ===
embann.c:182:5: note: got vectype for stmt: network.22_26 = network;
vector(2) long unsigned int
embann.c:182:5: note: got vectype for stmt: _27 = network.22_26->inputLayer.numNeurons;
vector(8) short unsigned int
embann.c:182:5: note: === vect_analyze_data_ref_accesses ===
embann.c:182:5: note: not consecutive access network.22_26 = network;
embann.c:182:5: note: not consecutive access _27 = network.22_26->inputLayer.numNeurons;
embann.c:182:5: note: not vectorized: no grouped stores in basic block.
embann.c:182:5: note: ===vect_slp_analyze_bb===
embann.c:184:78: note: === vect_analyze_data_refs ===
embann.c:184:78: note: not vectorized: not enough data-refs in basic block.
embann.c:184:78: note: ===vect_slp_analyze_bb===
embann.c:182:5: note: === vect_analyze_data_refs ===
embann.c:182:5: note: got vectype for stmt: _3 = *_2;
vector(16) unsigned char
embann.c:182:5: note: got vectype for stmt: _11 = network.22_26->inputLayer.neuron[i_30];
vector(2) long unsigned int
embann.c:182:5: note: got vectype for stmt: _11->activation = _12;
vector(4) float
embann.c:182:5: note: === vect_analyze_data_ref_accesses ===
embann.c:182:5: note: not consecutive access _3 = *_2;
embann.c:182:5: note: not consecutive access _11->activation = _12;
embann.c:182:5: note: not consecutive access _11 = network.22_26->inputLayer.neuron[i_30];
embann.c:182:5: note: not vectorized: no grouped stores in basic block.
embann.c:182:5: note: ===vect_slp_analyze_bb===
embann.c:182:5: note: ===vect_slp_analyze_bb===
embann.c:186:1: note: === vect_analyze_data_refs ===
embann.c:186:1: note: not vectorized: not enough data-refs in basic block.

Analyzing loop at embann.c:190
embann.c:190:5: note: ===== analyze_loop_nest =====
embann.c:190:5: note: === vect_analyze_loop_form ===
embann.c:190:5: note: === get_loop_niters ===
embann.c:190:5: note: Symbolic number of iterations is (uint32_t) _22
embann.c:190:5: note: === vect_analyze_data_refs ===
embann.c:190:5: note: got vectype for stmt: _3 = *_2;
vector(16) unsigned char
embann.c:190:5: note: got vectype for stmt: _6 = network.24_21->inputLayer.neuron[i_25];
vector(2) long unsigned int
embann.c:190:5: note: got vectype for stmt: _6->activation = _7;
vector(4) float
embann.c:190:5: note: not vectorized: not suitable for scatter store _6->activation = _7;
embann.c:190:5: note: bad data references.
embann.c:188:6: note: vectorized 0 loops in function.
embann.c:188:6: note: ===vect_slp_analyze_bb===
embann.c:190:5: note: === vect_analyze_data_refs ===
embann.c:190:5: note: got vectype for stmt: network.24_21 = network;
vector(2) long unsigned int
embann.c:190:5: note: got vectype for stmt: _22 = network.24_21->inputLayer.numNeurons;
vector(8) short unsigned int
embann.c:190:5: note: === vect_analyze_data_ref_accesses ===
embann.c:190:5: note: not consecutive access network.24_21 = network;
embann.c:190:5: note: not consecutive access _22 = network.24_21->inputLayer.numNeurons;
embann.c:190:5: note: not vectorized: no grouped stores in basic block.
embann.c:190:5: note: ===vect_slp_analyze_bb===
embann.c:190:5: note: === vect_analyze_data_refs ===
embann.c:190:5: note: not vectorized: not enough data-refs in basic block.
embann.c:190:5: note: ===vect_slp_analyze_bb===
embann.c:190:5: note: === vect_analyze_data_refs ===
embann.c:190:5: note: got vectype for stmt: _3 = *_2;
vector(16) unsigned char
embann.c:190:5: note: got vectype for stmt: _6 = network.24_21->inputLayer.neuron[i_25];
vector(2) long unsigned int
embann.c:190:5: note: got vectype for stmt: _6->activation = _7;
vector(4) float
embann.c:190:5: note: === vect_analyze_data_ref_accesses ===
embann.c:190:5: note: not consecutive access _3 = *_2;
embann.c:190:5: note: not consecutive access _6->activation = _7;
embann.c:190:5: note: not consecutive access _6 = network.24_21->inputLayer.neuron[i_25];
embann.c:190:5: note: not vectorized: no grouped stores in basic block.
embann.c:190:5: note: ===vect_slp_analyze_bb===
embann.c:190:5: note: ===vect_slp_analyze_bb===
embann.c:194:1: note: === vect_analyze_data_refs ===
embann.c:194:1: note: not vectorized: not enough data-refs in basic block.

Analyzing loop at embann.c:204
embann.c:204:47: note: ===== analyze_loop_nest =====
embann.c:204:47: note: === vect_analyze_loop_form ===
embann.c:204:47: note: not vectorized: control flow in loop.
embann.c:204:47: note: bad loop form.

Analyzing loop at embann.c:204
embann.c:204:9: note: ===== analyze_loop_nest =====
embann.c:204:9: note: === vect_analyze_loop_form ===
embann.c:204:9: note: === get_loop_niters ===
embann.c:204:9: note: Symbolic number of iterations is (uint32_t) _22
embann.c:204:9: note: === vect_analyze_data_refs ===
embann.c:204:9: note: got vectype for stmt: _1 = pTrainingData_29->data[j_30];
vector(16) unsigned char
embann.c:204:9: note: === vect_analyze_scalar_cycles ===
embann.c:204:9: note: Analyze phi: sum_27 = PHI <0(9), sum_17(11)>
embann.c:204:9: note: Access function of PHI: {0, +, _2}_2
embann.c:204:9: note: step: _2,  init: 0
embann.c:204:9: note: step unknown.
embann.c:204:9: note: Analyze phi: j_30 = PHI <0(9), j_18(11)>
embann.c:204:9: note: Access function of PHI: {0, +, 1}_2
embann.c:204:9: note: step: 1,  init: 0
embann.c:204:9: note: Detected induction.
embann.c:204:9: note: Analyze phi: sum_27 = PHI <0(9), sum_17(11)>
embann.c:204:9: note: detected reduction: sum_17 = _2 + sum_27;
embann.c:204:9: note: Detected reduction.
embann.c:204:9: note: === vect_pattern_recog ===
embann.c:204:9: note: vect_is_simple_use: operand _2
embann.c:204:9: note: def_stmt: _2 = (unsigned int) _1;
embann.c:204:9: note: type of def: internal
embann.c:204:9: note: vect_is_simple_use: operand _1
embann.c:204:9: note: def_stmt: _1 = pTrainingData_29->data[j_30];
embann.c:204:9: note: type of def: internal
embann.c:204:9: note: vect_is_simple_use: operand _2
embann.c:204:9: note: def_stmt: _2 = (unsigned int) _1;
embann.c:204:9: note: type of def: internal
embann.c:204:9: note: vect_is_simple_use: operand _1
embann.c:204:9: note: def_stmt: _1 = pTrainingData_29->data[j_30];
embann.c:204:9: note: type of def: internal
embann.c:204:9: note: vect_is_simple_use: operand _2
embann.c:204:9: note: def_stmt: _2 = (unsigned int) _1;
embann.c:204:9: note: type of def: internal
embann.c:204:9: note: vect_is_simple_use: operand _1
embann.c:204:9: note: def_stmt: _1 = pTrainingData_29->data[j_30];
embann.c:204:9: note: type of def: internal
embann.c:204:9: note: vect_recog_widen_sum_pattern: detected: patt_37 = _1 w+ sum_27;
embann.c:204:9: note: === vect_analyze_data_ref_accesses ===
embann.c:204:9: note: === vect_mark_stmts_to_be_vectorized ===
embann.c:204:9: note: init: phi relevant? sum_27 = PHI <0(9), sum_17(11)>
embann.c:204:9: note: init: phi relevant? j_30 = PHI <0(9), j_18(11)>
embann.c:204:9: note: init: stmt relevant? _1 = pTrainingData_29->data[j_30];
embann.c:204:9: note: init: stmt relevant? _2 = (unsigned int) _1;
embann.c:204:9: note: init: stmt relevant? sum_17 = _2 + sum_27;
embann.c:204:9: note: vec_stmt_relevant_p: used out of loop.
embann.c:204:9: note: vect_is_simple_use: operand _2
embann.c:204:9: note: def_stmt: _2 = (unsigned int) _1;
embann.c:204:9: note: type of def: internal
embann.c:204:9: note: vec_stmt_relevant_p: stmt live but not relevant.
embann.c:204:9: note: mark relevant 1, live 1: sum_17 = _2 + sum_27;
embann.c:204:9: note: init: stmt relevant? j_18 = j_30 + 1;
embann.c:204:9: note: init: stmt relevant? if (j_18 < _22)
embann.c:204:9: note: worklist: examine stmt: sum_17 = _2 + sum_27;
embann.c:204:9: note: vect_is_simple_use: operand _2
embann.c:204:9: note: def_stmt: _2 = (unsigned int) _1;
embann.c:204:9: note: type of def: internal
embann.c:204:9: note: mark relevant 1, live 0: _2 = (unsigned int) _1;
embann.c:204:9: note: vect_is_simple_use: operand sum_27
embann.c:204:9: note: def_stmt: sum_27 = PHI <0(9), sum_17(11)>
embann.c:204:9: note: type of def: reduction
embann.c:204:9: note: mark relevant 1, live 0: sum_27 = PHI <0(9), sum_17(11)>
embann.c:204:9: note: worklist: examine stmt: sum_27 = PHI <0(9), sum_17(11)>
embann.c:204:9: note: vect_is_simple_use: operand 0
embann.c:204:9: note: vect_is_simple_use: operand sum_17
embann.c:204:9: note: def_stmt: sum_17 = _2 + sum_27;
embann.c:204:9: note: type of def: reduction
embann.c:204:9: note: reduc-stmt defining reduc-phi in the same nest.
embann.c:204:9: note: worklist: examine stmt: _2 = (unsigned int) _1;
embann.c:204:9: note: vect_is_simple_use: operand _1
embann.c:204:9: note: def_stmt: _1 = pTrainingData_29->data[j_30];
embann.c:204:9: note: type of def: internal
embann.c:204:9: note: mark relevant 1, live 0: _1 = pTrainingData_29->data[j_30];
embann.c:204:9: note: worklist: examine stmt: _1 = pTrainingData_29->data[j_30];
embann.c:204:9: note: === vect_analyze_data_ref_dependences ===
embann.c:204:9: note: === vect_determine_vectorization_factor ===
embann.c:204:9: note: ==> examining phi: sum_27 = PHI <0(9), sum_17(11)>
embann.c:204:9: note: get vectype for scalar type:  uint32_t
embann.c:204:9: note: vectype: vector(4) unsigned int
embann.c:204:9: note: nunits = 4
embann.c:204:9: note: ==> examining phi: j_30 = PHI <0(9), j_18(11)>
embann.c:204:9: note: ==> examining statement: _1 = pTrainingData_29->data[j_30];
embann.c:204:9: note: get vectype for scalar type:  unsigned char
embann.c:204:9: note: vectype: vector(16) unsigned char
embann.c:204:9: note: nunits = 16
embann.c:204:9: note: ==> examining statement: _2 = (unsigned int) _1;
embann.c:204:9: note: get vectype for scalar type:  unsigned int
embann.c:204:9: note: vectype: vector(4) unsigned int
embann.c:204:9: note: get vectype for scalar type:  unsigned char
embann.c:204:9: note: vectype: vector(16) unsigned char
embann.c:204:9: note: nunits = 16
embann.c:204:9: note: ==> examining statement: sum_17 = _2 + sum_27;
embann.c:204:9: note: get vectype for scalar type:  uint32_t
embann.c:204:9: note: vectype: vector(4) unsigned int
embann.c:204:9: note: get vectype for scalar type:  uint32_t
embann.c:204:9: note: vectype: vector(4) unsigned int
embann.c:204:9: note: nunits = 4
embann.c:204:9: note: ==> examining statement: j_18 = j_30 + 1;
embann.c:204:9: note: skip.
embann.c:204:9: note: ==> examining statement: if (j_18 < _22)
embann.c:204:9: note: skip.
embann.c:204:9: note: vectorization factor = 16
embann.c:204:9: note: === vect_analyze_slp ===
embann.c:204:9: note: === vect_make_slp_decision ===
embann.c:204:9: note: === vect_analyze_data_refs_alignment ===
embann.c:204:9: note: recording new base alignment for pTrainingData_29
embann.c:204:9: note:   alignment:    8
embann.c:204:9: note:   misalignment: 0
embann.c:204:9: note:   based on:     _1 = pTrainingData_29->data[j_30];
embann.c:204:9: note: vect_compute_data_ref_alignment:
embann.c:204:9: note: can't force alignment of ref: pTrainingData_29->data[j_30]
embann.c:204:9: note: === vect_prune_runtime_alias_test_list ===
embann.c:204:9: note: === vect_enhance_data_refs_alignment ===
embann.c:204:9: note: Unknown misalignment, naturally aligned
embann.c:204:9: note: vect_can_advance_ivs_p:
embann.c:204:9: note: Analyze phi: sum_27 = PHI <0(9), sum_17(11)>
embann.c:204:9: note: reduc or virtual phi. skip.
embann.c:204:9: note: Analyze phi: j_30 = PHI <0(9), j_18(11)>
embann.c:204:9: note: vect_model_load_cost: aligned.
embann.c:204:9: note: vect_get_data_access_cost: inside_cost = 12, outside_cost = 0.
embann.c:204:9: note: cost model: epilogue peel iters set to vf/2 because loop iterations are unknown .
embann.c:204:9: note: vect_model_load_cost: unaligned supported by hardware.
embann.c:204:9: note: vect_get_data_access_cost: inside_cost = 12, outside_cost = 0.
embann.c:204:9: note: cost model: epilogue peel iters set to vf/2 because loop iterations are unknown .
embann.c:204:9: note: Vectorizing an unaligned access.
embann.c:204:9: note: === vect_analyze_loop_operations ===
embann.c:204:9: note: examining phi: sum_27 = PHI <0(9), sum_17(11)>
embann.c:204:9: note: examining phi: j_30 = PHI <0(9), j_18(11)>
embann.c:204:9: note: ==> examining statement: _1 = pTrainingData_29->data[j_30];
embann.c:204:9: note: num. args = 4 (not unary/binary/ternary op).
embann.c:204:9: note: vect_is_simple_use: operand pTrainingData_29->data[j_30]
embann.c:204:9: note: not ssa-name.
embann.c:204:9: note: use not simple.
embann.c:204:9: note: can't use a fully-masked loop because the target doesn't have the appropriate masked load or store.
embann.c:204:9: note: vect_model_load_cost: unaligned supported by hardware.
embann.c:204:9: note: vect_model_load_cost: inside_cost = 12, prologue_cost = 0 .
embann.c:204:9: note: ==> examining statement: _2 = (unsigned int) _1;
embann.c:204:9: note: vect_is_simple_use: operand _1
embann.c:204:9: note: def_stmt: _1 = pTrainingData_29->data[j_30];
embann.c:204:9: note: type of def: internal
embann.c:204:9: note: === vectorizable_conversion ===
embann.c:204:9: note: vect_model_promotion_demotion_cost: inside_cost = 24, prologue_cost = 0 .
embann.c:204:9: note: ==> examining statement: sum_17 = _2 + sum_27;
embann.c:204:9: note: vect_is_simple_use: operand _2
embann.c:204:9: note: def_stmt: _2 = (unsigned int) _1;
embann.c:204:9: note: type of def: internal
embann.c:204:9: note: vect_is_simple_use: operand sum_27
embann.c:204:9: note: def_stmt: sum_27 = PHI <0(9), sum_17(11)>
embann.c:204:9: note: type of def: reduction
embann.c:204:9: note: reduc op not supported by target.
vect_model_reduction_cost: inside_cost = 16, prologue_cost = 4, epilogue_cost = 20 .
embann.c:204:9: note: ==> examining statement: j_18 = j_30 + 1;
embann.c:204:9: note: irrelevant.
embann.c:204:9: note: ==> examining statement: if (j_18 < _22)
embann.c:204:9: note: irrelevant.
embann.c:204:9: note: not using a fully-masked loop.
embann.c:204:9: note: cost model: epilogue peel iters set to vf/2 because loop iterations are unknown .
embann.c:204:9: note: Cost model analysis: 
  Vector inside of loop cost: 52
  Vector prologue cost: 36
  Vector epilogue cost: 180
  Scalar iteration cost: 20
  Scalar outside cost: 32
  Vector outside cost: 216
  prologue iterations: 0
  epilogue iterations: 8
  Calculated minimum iters for profitability: 10
embann.c:204:9: note:   Runtime profitability threshold = 16
embann.c:204:9: note:   Static estimate profitability threshold = 16
embann.c:204:9: note: epilog loop required
embann.c:204:9: note: vect_can_advance_ivs_p:
embann.c:204:9: note: Analyze phi: sum_27 = PHI <0(9), sum_17(11)>
embann.c:204:9: note: reduc or virtual phi. skip.
embann.c:204:9: note: Analyze phi: j_30 = PHI <0(9), j_18(11)>
embann.c:204:9: note: loop vectorized
embann.c:204:9: note: === vec_transform_loop ===
embann.c:204:9: note: Profitability threshold is 16 loop iterations.
embann.c:204:9: note: vect_update_ivs_after_vectorizer: phi: sum_27 = PHI <sum_17(11), 0(14)>
embann.c:204:9: note: reduc or virtual phi. skip.
embann.c:204:9: note: vect_update_ivs_after_vectorizer: phi: j_30 = PHI <j_18(11), 0(14)>
embann.c:204:9: note: ------>vectorizing phi: sum_27 = PHI <sum_17(11), 0(21)>
embann.c:204:9: note: multiple-types.
embann.c:204:9: note: transform phi.
embann.c:204:9: note: ------>vectorizing phi: j_30 = PHI <j_18(11), 0(21)>
embann.c:204:9: note: ------>vectorizing phi: vect_sum_17.210_4 = PHI <(11), (21)>
embann.c:204:9: note: ------>vectorizing statement: _1 = pTrainingData_29->data[j_30];
embann.c:204:9: note: transform statement.
embann.c:204:9: note: transform load. ncopies = 1
embann.c:204:9: note: create vector_type-pointer variable to type: vector(16) unsigned char  vectorizing a record based array ref: *pTrainingData_29
embann.c:204:9: note: created vectp_pTrainingData.212_3
embann.c:204:9: note: add new stmt: vect__1.213_42 = MEM[(uint8_t[0:] *)vectp_pTrainingData.211_38];
embann.c:204:9: note: ------>vectorizing statement: _2 = (unsigned int) _1;
embann.c:204:9: note: multiple-types.
embann.c:204:9: note: transform statement.
embann.c:204:9: note: vect_is_simple_use: operand _1
embann.c:204:9: note: def_stmt: _1 = pTrainingData_29->data[j_30];
embann.c:204:9: note: type of def: internal
embann.c:204:9: note: transform conversion. ncopies = 1.
embann.c:204:9: note: vect_get_vec_def_for_operand: _1
embann.c:204:9: note: vect_is_simple_use: operand _1
embann.c:204:9: note: def_stmt: _1 = pTrainingData_29->data[j_30];
embann.c:204:9: note: type of def: internal
embann.c:204:9: note:   def_stmt =  _1 = pTrainingData_29->data[j_30];
embann.c:204:9: note: add new stmt: vect__2.215_43 = [vec_unpack_lo_expr] vect__1.213_42;
embann.c:204:9: note: add new stmt: vect__2.215_44 = [vec_unpack_hi_expr] vect__1.213_42;
embann.c:204:9: note: add new stmt: vect__2.214_45 = [vec_unpack_lo_expr] vect__2.215_43;
embann.c:204:9: note: add new stmt: vect__2.214_46 = [vec_unpack_hi_expr] vect__2.215_43;
embann.c:204:9: note: add new stmt: vect__2.214_47 = [vec_unpack_lo_expr] vect__2.215_44;
embann.c:204:9: note: add new stmt: vect__2.214_48 = [vec_unpack_hi_expr] vect__2.215_44;
embann.c:204:9: note: ------>vectorizing statement: sum_17 = _2 + sum_27;
embann.c:204:9: note: multiple-types.
embann.c:204:9: note: transform statement.
embann.c:204:9: note: vect_is_simple_use: operand _2
embann.c:204:9: note: def_stmt: _2 = (unsigned int) _1;
embann.c:204:9: note: type of def: internal
embann.c:204:9: note: vect_is_simple_use: operand sum_27
embann.c:204:9: note: def_stmt: sum_27 = PHI <sum_17(11), 0(21)>
embann.c:204:9: note: type of def: reduction
embann.c:204:9: note: reduc op not supported by target.
embann.c:204:9: note: transform reduction.
embann.c:204:9: note: vect_get_vec_def_for_operand: _2
embann.c:204:9: note: vect_is_simple_use: operand _2
embann.c:204:9: note: def_stmt: _2 = (unsigned int) _1;
embann.c:204:9: note: type of def: internal
embann.c:204:9: note:   def_stmt =  _2 = (unsigned int) _1;
embann.c:204:9: note: vect_get_vec_def_for_operand: sum_27
embann.c:204:9: note: vect_is_simple_use: operand sum_27
embann.c:204:9: note: def_stmt: sum_27 = PHI <sum_17(11), 0(21)>
embann.c:204:9: note: type of def: reduction
embann.c:204:9: note:   def_stmt =  sum_27 = PHI <sum_17(11), 0(21)>
embann.c:204:9: note: add new stmt: vect_sum_17.216_49 = vect__2.214_45 + vect_sum_17.210_4;
embann.c:204:9: note: add new stmt: vect_sum_17.216_50 = vect__2.214_46 + vect_sum_17.216_49;
embann.c:204:9: note: add new stmt: vect_sum_17.216_51 = vect__2.214_47 + vect_sum_17.216_50;
embann.c:204:9: note: add new stmt: vect_sum_17.216_52 = vect__2.214_48 + vect_sum_17.216_51;
embann.c:204:9: note: vect_is_simple_use: operand 0
embann.c:204:9: note: transform reduction: created def-use cycle: vect_sum_17.210_4 = PHI <vect_sum_17.216_52(11), { 0, 0, 0, 0 }(21)>
vect_sum_17.216_52 = vect__2.214_48 + vect_sum_17.216_51;
embann.c:204:9: note: Reduce using vector shifts
embann.c:204:9: note: extract scalar result
embann.c:204:9: note: ------>vectorizing statement: j_18 = j_30 + 1;
embann.c:204:9: note: ------>vectorizing statement: vectp_pTrainingData.211_41 = vectp_pTrainingData.211_38 + 16;
embann.c:204:9: note: ------>vectorizing statement: if (j_18 < _22)
embann.c:204:9: note: New loop exit condition: if (ivtmp_61 < bnd.207_11)
embann.c:204:9: note: LOOP VECTORIZED

embann.c:196:7: note: vectorized 1 loops in function.
embann.c:204:9: note: loop with 14 iterations completely unrolled (header execution count 21807687)
embann.c:196:7: note: ===vect_slp_analyze_bb===
embann.c:202:11: note: === vect_analyze_data_refs ===
embann.c:202:11: note: got vectype for stmt: pTrainingData_16 = trainingDataCollection.head;
vector(2) long unsigned int
embann.c:202:11: note: not vectorized: not enough data-refs in basic block.
embann.c:202:11: note: ===vect_slp_analyze_bb===
embann.c:202:11: note: ===vect_slp_analyze_bb===
embann.c:202:11: note: === vect_analyze_data_refs ===
embann.c:202:11: note: not vectorized: not enough data-refs in basic block.
embann.c:202:11: note: ===vect_slp_analyze_bb===
embann.c:202:11: note: === vect_analyze_data_refs ===
embann.c:202:11: note: not vectorized: not enough data-refs in basic block.
embann.c:202:11: note: ===vect_slp_analyze_bb===
embann.c:206:17: note: === vect_analyze_data_refs ===
embann.c:206:17: note: not vectorized: no vectype for stmt: vect__1.213_42 = MEM[(uint8_t[0:] *)vectp_pTrainingData.211_38];
 scalar_type: vector(16) unsigned char
embann.c:206:17: note: not vectorized: not enough data-refs in basic block.
embann.c:206:17: note: ===vect_slp_analyze_bb===
embann.c:206:17: note: ===vect_slp_analyze_bb===
embann.c:206:17: note: === vect_analyze_data_refs ===
embann.c:206:17: note: not vectorized: not enough data-refs in basic block.
embann.c:206:17: note: ===vect_slp_analyze_bb===
embann.c:204:9: note: === vect_analyze_data_refs ===
embann.c:204:9: note: got vectype for stmt: _27 = pTrainingData_29->data[j_12];
vector(16) unsigned char
embann.c:204:9: note: not vectorized: not enough data-refs in basic block.
embann.c:204:9: note: ===vect_slp_analyze_bb===
embann.c:204:9: note: === vect_analyze_data_refs ===
embann.c:204:9: note: got vectype for stmt: _62 = pTrainingData_29->data[j_40];
vector(16) unsigned char
embann.c:204:9: note: not vectorized: not enough data-refs in basic block.
embann.c:204:9: note: ===vect_slp_analyze_bb===
embann.c:204:9: note: === vect_analyze_data_refs ===
embann.c:204:9: note: got vectype for stmt: _68 = pTrainingData_29->data[j_67];
vector(16) unsigned char
embann.c:204:9: note: not vectorized: not enough data-refs in basic block.
embann.c:204:9: note: ===vect_slp_analyze_bb===
embann.c:204:9: note: === vect_analyze_data_refs ===
embann.c:204:9: note: got vectype for stmt: _74 = pTrainingData_29->data[j_73];
vector(16) unsigned char
embann.c:204:9: note: not vectorized: not enough data-refs in basic block.
embann.c:204:9: note: ===vect_slp_analyze_bb===
embann.c:204:9: note: === vect_analyze_data_refs ===
embann.c:204:9: note: got vectype for stmt: _80 = pTrainingData_29->data[j_79];
vector(16) unsigned char
embann.c:204:9: note: not vectorized: not enough data-refs in basic block.
embann.c:204:9: note: ===vect_slp_analyze_bb===
embann.c:204:9: note: === vect_analyze_data_refs ===
embann.c:204:9: note: got vectype for stmt: _86 = pTrainingData_29->data[j_85];
vector(16) unsigned char
embann.c:204:9: note: not vectorized: not enough data-refs in basic block.
embann.c:204:9: note: ===vect_slp_analyze_bb===
embann.c:204:9: note: === vect_analyze_data_refs ===
embann.c:204:9: note: got vectype for stmt: _92 = pTrainingData_29->data[j_91];
vector(16) unsigned char
embann.c:204:9: note: not vectorized: not enough data-refs in basic block.
embann.c:204:9: note: ===vect_slp_analyze_bb===
embann.c:204:9: note: === vect_analyze_data_refs ===
embann.c:204:9: note: got vectype for stmt: _98 = pTrainingData_29->data[j_97];
vector(16) unsigned char
embann.c:204:9: note: not vectorized: not enough data-refs in basic block.
embann.c:204:9: note: ===vect_slp_analyze_bb===
embann.c:204:9: note: === vect_analyze_data_refs ===
embann.c:204:9: note: got vectype for stmt: _104 = pTrainingData_29->data[j_103];
vector(16) unsigned char
embann.c:204:9: note: not vectorized: not enough data-refs in basic block.
embann.c:204:9: note: ===vect_slp_analyze_bb===
embann.c:204:9: note: === vect_analyze_data_refs ===
embann.c:204:9: note: got vectype for stmt: _110 = pTrainingData_29->data[j_109];
vector(16) unsigned char
embann.c:204:9: note: not vectorized: not enough data-refs in basic block.
embann.c:204:9: note: ===vect_slp_analyze_bb===
embann.c:204:9: note: === vect_analyze_data_refs ===
embann.c:204:9: note: got vectype for stmt: _116 = pTrainingData_29->data[j_115];
vector(16) unsigned char
embann.c:204:9: note: not vectorized: not enough data-refs in basic block.
embann.c:204:9: note: ===vect_slp_analyze_bb===
embann.c:204:9: note: === vect_analyze_data_refs ===
embann.c:204:9: note: got vectype for stmt: _122 = pTrainingData_29->data[j_121];
vector(16) unsigned char
embann.c:204:9: note: not vectorized: not enough data-refs in basic block.
embann.c:204:9: note: ===vect_slp_analyze_bb===
embann.c:204:9: note: === vect_analyze_data_refs ===
embann.c:204:9: note: got vectype for stmt: _128 = pTrainingData_29->data[j_127];
vector(16) unsigned char
embann.c:204:9: note: not vectorized: not enough data-refs in basic block.
embann.c:204:9: note: ===vect_slp_analyze_bb===
embann.c:204:9: note: === vect_analyze_data_refs ===
embann.c:204:9: note: got vectype for stmt: _134 = pTrainingData_29->data[j_133];
vector(16) unsigned char
embann.c:204:9: note: not vectorized: not enough data-refs in basic block.
embann.c:204:9: note: ===vect_slp_analyze_bb===
embann.c:204:58: note: === vect_analyze_data_refs ===
embann.c:204:58: note: got vectype for stmt: _33 = pTrainingData_29->data[j_34];
vector(16) unsigned char
embann.c:204:58: note: not vectorized: not enough data-refs in basic block.
embann.c:204:58: note: ===vect_slp_analyze_bb===
embann.c:202:11: note: === vect_analyze_data_refs ===
embann.c:202:11: note: got vectype for stmt: pTrainingData_20 = pTrainingData_29->next;
vector(2) long unsigned int
embann.c:202:11: note: not vectorized: not enough data-refs in basic block.
embann.c:202:11: note: ===vect_slp_analyze_bb===
embann.c:202:11: note: ===vect_slp_analyze_bb===
embann.c:202:11: note: ===vect_slp_analyze_bb===
embann.c:204:9: note: === vect_analyze_data_refs ===
embann.c:204:9: note: got vectype for stmt: _22 = pTrainingData_29->length;
vector(4) unsigned int
embann.c:204:9: note: not vectorized: not enough data-refs in basic block.
embann.c:204:9: note: ===vect_slp_analyze_bb===
embann.c:216:12: note: === vect_analyze_data_refs ===
embann.c:216:12: note: got vectype for stmt: _7 = trainingDataCollection.numEntries;
vector(4) unsigned int
embann.c:216:12: note: not vectorized: not enough data-refs in basic block.
embann.c:216:12: note: ===vect_slp_analyze_bb===

Analyzing loop at embann.c:226
embann.c:226:11: note: ===== analyze_loop_nest =====
embann.c:226:11: note: === vect_analyze_loop_form ===
embann.c:226:11: note: not vectorized: control flow in loop.
embann.c:226:11: note: bad loop form.

Analyzing loop at embann.c:228
embann.c:228:9: note: ===== analyze_loop_nest =====
embann.c:228:9: note: === vect_analyze_loop_form ===
embann.c:228:9: note: === get_loop_niters ===
embann.c:228:9: note: Symbolic number of iterations is _6
embann.c:228:9: note: === vect_analyze_data_refs ===
embann.c:228:9: note: got vectype for stmt: _1 = pTrainingData_49->data[j_50];
vector(16) unsigned char
embann.c:228:9: note: === vect_analyze_scalar_cycles ===
embann.c:228:9: note: Analyze phi: sumofSquares_44 = PHI <sumofSquares_48(14), sumofSquares_16(18)>
embann.c:228:9: note: Access function of PHI: {sumofSquares_48, +, powmult_9}_2
embann.c:228:9: note: step: powmult_9,  init: sumofSquares_48
embann.c:228:9: note: step unknown.
embann.c:228:9: note: Analyze phi: j_50 = PHI <0(14), j_17(18)>
embann.c:228:9: note: Access function of PHI: {0, +, 1}_2
embann.c:228:9: note: step: 1,  init: 0
embann.c:228:9: note: Detected induction.
embann.c:228:9: note: Analyze phi: sumofSquares_44 = PHI <sumofSquares_48(14), sumofSquares_16(18)>
embann.c:228:9: note: detected reduction: sumofSquares_16 = powmult_9 + sumofSquares_44;
embann.c:228:9: note: Detected reduction.
embann.c:228:9: note: === vect_pattern_recog ===
embann.c:228:9: note: vect_is_simple_use: operand _3
embann.c:228:9: note: def_stmt: _3 = _2 - mean_12;
embann.c:228:9: note: type of def: internal
embann.c:228:9: note: vect_is_simple_use: operand powmult_9
embann.c:228:9: note: def_stmt: powmult_9 = _3 * _3;
embann.c:228:9: note: type of def: internal
embann.c:228:9: note: vect_is_simple_use: operand _3
embann.c:228:9: note: def_stmt: _3 = _2 - mean_12;
embann.c:228:9: note: type of def: internal
embann.c:228:9: note: vect_is_simple_use: operand powmult_9
embann.c:228:9: note: def_stmt: powmult_9 = _3 * _3;
embann.c:228:9: note: type of def: internal
embann.c:228:9: note: vect_is_simple_use: operand powmult_9
embann.c:228:9: note: def_stmt: powmult_9 = _3 * _3;
embann.c:228:9: note: type of def: internal
embann.c:228:9: note: === vect_analyze_data_ref_accesses ===
embann.c:228:9: note: === vect_mark_stmts_to_be_vectorized ===
embann.c:228:9: note: init: phi relevant? sumofSquares_44 = PHI <sumofSquares_48(14), sumofSquares_16(18)>
embann.c:228:9: note: init: phi relevant? j_50 = PHI <0(14), j_17(18)>
embann.c:228:9: note: init: stmt relevant? _1 = pTrainingData_49->data[j_50];
embann.c:228:9: note: init: stmt relevant? _2 = (float) _1;
embann.c:228:9: note: init: stmt relevant? _3 = _2 - mean_12;
embann.c:228:9: note: init: stmt relevant? powmult_9 = _3 * _3;
embann.c:228:9: note: init: stmt relevant? sumofSquares_16 = powmult_9 + sumofSquares_44;
embann.c:228:9: note: vec_stmt_relevant_p: used out of loop.
embann.c:228:9: note: vect_is_simple_use: operand powmult_9
embann.c:228:9: note: def_stmt: powmult_9 = _3 * _3;
embann.c:228:9: note: type of def: internal
embann.c:228:9: note: vec_stmt_relevant_p: stmt live but not relevant.
embann.c:228:9: note: mark relevant 1, live 1: sumofSquares_16 = powmult_9 + sumofSquares_44;
embann.c:228:9: note: init: stmt relevant? j_17 = j_50 + 1;
embann.c:228:9: note: init: stmt relevant? if (_6 > j_17)
embann.c:228:9: note: worklist: examine stmt: sumofSquares_16 = powmult_9 + sumofSquares_44;
embann.c:228:9: note: vect_is_simple_use: operand powmult_9
embann.c:228:9: note: def_stmt: powmult_9 = _3 * _3;
embann.c:228:9: note: type of def: internal
embann.c:228:9: note: mark relevant 1, live 0: powmult_9 = _3 * _3;
embann.c:228:9: note: vect_is_simple_use: operand sumofSquares_44
embann.c:228:9: note: def_stmt: sumofSquares_44 = PHI <sumofSquares_48(14), sumofSquares_16(18)>
embann.c:228:9: note: type of def: reduction
embann.c:228:9: note: mark relevant 1, live 0: sumofSquares_44 = PHI <sumofSquares_48(14), sumofSquares_16(18)>
embann.c:228:9: note: worklist: examine stmt: sumofSquares_44 = PHI <sumofSquares_48(14), sumofSquares_16(18)>
embann.c:228:9: note: vect_is_simple_use: operand sumofSquares_48
embann.c:228:9: note: def_stmt: sumofSquares_48 = PHI <0.0(12), sumofSquares_18(17)>
embann.c:228:9: note: type of def: external
embann.c:228:9: note: def_stmt is out of loop.
embann.c:228:9: note: vect_is_simple_use: operand sumofSquares_16
embann.c:228:9: note: def_stmt: sumofSquares_16 = powmult_9 + sumofSquares_44;
embann.c:228:9: note: type of def: reduction
embann.c:228:9: note: reduc-stmt defining reduc-phi in the same nest.
embann.c:228:9: note: worklist: examine stmt: powmult_9 = _3 * _3;
embann.c:228:9: note: vect_is_simple_use: operand _3
embann.c:228:9: note: def_stmt: _3 = _2 - mean_12;
embann.c:228:9: note: type of def: internal
embann.c:228:9: note: mark relevant 1, live 0: _3 = _2 - mean_12;
embann.c:228:9: note: vect_is_simple_use: operand _3
embann.c:228:9: note: def_stmt: _3 = _2 - mean_12;
embann.c:228:9: note: type of def: internal
embann.c:228:9: note: mark relevant 1, live 0: _3 = _2 - mean_12;
embann.c:228:9: note: already marked relevant/live.
embann.c:228:9: note: worklist: examine stmt: _3 = _2 - mean_12;
embann.c:228:9: note: vect_is_simple_use: operand _2
embann.c:228:9: note: def_stmt: _2 = (float) _1;
embann.c:228:9: note: type of def: internal
embann.c:228:9: note: mark relevant 1, live 0: _2 = (float) _1;
embann.c:228:9: note: vect_is_simple_use: operand mean_12
embann.c:228:9: note: def_stmt: mean_12 = mean_85 / _21;
embann.c:228:9: note: type of def: external
embann.c:228:9: note: def_stmt is out of loop.
embann.c:228:9: note: worklist: examine stmt: _2 = (float) _1;
embann.c:228:9: note: vect_is_simple_use: operand _1
embann.c:228:9: note: def_stmt: _1 = pTrainingData_49->data[j_50];
embann.c:228:9: note: type of def: internal
embann.c:228:9: note: mark relevant 1, live 0: _1 = pTrainingData_49->data[j_50];
embann.c:228:9: note: worklist: examine stmt: _1 = pTrainingData_49->data[j_50];
embann.c:228:9: note: === vect_analyze_data_ref_dependences ===
embann.c:228:9: note: === vect_determine_vectorization_factor ===
embann.c:228:9: note: ==> examining phi: sumofSquares_44 = PHI <sumofSquares_48(14), sumofSquares_16(18)>
embann.c:228:9: note: get vectype for scalar type:  float
embann.c:228:9: note: vectype: vector(4) float
embann.c:228:9: note: nunits = 4
embann.c:228:9: note: ==> examining phi: j_50 = PHI <0(14), j_17(18)>
embann.c:228:9: note: ==> examining statement: _1 = pTrainingData_49->data[j_50];
embann.c:228:9: note: get vectype for scalar type:  unsigned char
embann.c:228:9: note: vectype: vector(16) unsigned char
embann.c:228:9: note: nunits = 16
embann.c:228:9: note: ==> examining statement: _2 = (float) _1;
embann.c:228:9: note: get vectype for scalar type:  float
embann.c:228:9: note: vectype: vector(4) float
embann.c:228:9: note: get vectype for scalar type:  unsigned char
embann.c:228:9: note: vectype: vector(16) unsigned char
embann.c:228:9: note: nunits = 16
embann.c:228:9: note: ==> examining statement: _3 = _2 - mean_12;
embann.c:228:9: note: get vectype for scalar type:  float
embann.c:228:9: note: vectype: vector(4) float
embann.c:228:9: note: get vectype for scalar type:  float
embann.c:228:9: note: vectype: vector(4) float
embann.c:228:9: note: nunits = 4
embann.c:228:9: note: ==> examining statement: powmult_9 = _3 * _3;
embann.c:228:9: note: get vectype for scalar type:  float
embann.c:228:9: note: vectype: vector(4) float
embann.c:228:9: note: get vectype for scalar type:  float
embann.c:228:9: note: vectype: vector(4) float
embann.c:228:9: note: nunits = 4
embann.c:228:9: note: ==> examining statement: sumofSquares_16 = powmult_9 + sumofSquares_44;
embann.c:228:9: note: get vectype for scalar type:  float
embann.c:228:9: note: vectype: vector(4) float
embann.c:228:9: note: get vectype for scalar type:  float
embann.c:228:9: note: vectype: vector(4) float
embann.c:228:9: note: nunits = 4
embann.c:228:9: note: ==> examining statement: j_17 = j_50 + 1;
embann.c:228:9: note: skip.
embann.c:228:9: note: ==> examining statement: if (_6 > j_17)
embann.c:228:9: note: skip.
embann.c:228:9: note: vectorization factor = 16
embann.c:228:9: note: === vect_analyze_slp ===
embann.c:228:9: note: === vect_make_slp_decision ===
embann.c:228:9: note: === vect_analyze_data_refs_alignment ===
embann.c:228:9: note: recording new base alignment for pTrainingData_49
embann.c:228:9: note:   alignment:    8
embann.c:228:9: note:   misalignment: 0
embann.c:228:9: note:   based on:     _1 = pTrainingData_49->data[j_50];
embann.c:228:9: note: vect_compute_data_ref_alignment:
embann.c:228:9: note: can't force alignment of ref: pTrainingData_49->data[j_50]
embann.c:228:9: note: === vect_prune_runtime_alias_test_list ===
embann.c:228:9: note: === vect_enhance_data_refs_alignment ===
embann.c:228:9: note: Unknown misalignment, naturally aligned
embann.c:228:9: note: vect_can_advance_ivs_p:
embann.c:228:9: note: Analyze phi: sumofSquares_44 = PHI <sumofSquares_48(14), sumofSquares_16(18)>
embann.c:228:9: note: reduc or virtual phi. skip.
embann.c:228:9: note: Analyze phi: j_50 = PHI <0(14), j_17(18)>
embann.c:228:9: note: vect_model_load_cost: aligned.
embann.c:228:9: note: vect_get_data_access_cost: inside_cost = 12, outside_cost = 0.
embann.c:228:9: note: cost model: epilogue peel iters set to vf/2 because loop iterations are unknown .
embann.c:228:9: note: vect_model_load_cost: unaligned supported by hardware.
embann.c:228:9: note: vect_get_data_access_cost: inside_cost = 12, outside_cost = 0.
embann.c:228:9: note: cost model: epilogue peel iters set to vf/2 because loop iterations are unknown .
embann.c:228:9: note: Vectorizing an unaligned access.
embann.c:228:9: note: === vect_analyze_loop_operations ===
embann.c:228:9: note: examining phi: sumofSquares_44 = PHI <sumofSquares_48(14), sumofSquares_16(18)>
embann.c:228:9: note: examining phi: j_50 = PHI <0(14), j_17(18)>
embann.c:228:9: note: ==> examining statement: _1 = pTrainingData_49->data[j_50];
embann.c:228:9: note: num. args = 4 (not unary/binary/ternary op).
embann.c:228:9: note: vect_is_simple_use: operand pTrainingData_49->data[j_50]
embann.c:228:9: note: not ssa-name.
embann.c:228:9: note: use not simple.
embann.c:228:9: note: can't use a fully-masked loop because the target doesn't have the appropriate masked load or store.
embann.c:228:9: note: vect_model_load_cost: unaligned supported by hardware.
embann.c:228:9: note: vect_model_load_cost: inside_cost = 12, prologue_cost = 0 .
embann.c:228:9: note: ==> examining statement: _2 = (float) _1;
embann.c:228:9: note: vect_is_simple_use: operand _1
embann.c:228:9: note: def_stmt: _1 = pTrainingData_49->data[j_50];
embann.c:228:9: note: type of def: internal
embann.c:228:9: note: === vectorizable_conversion ===
embann.c:228:9: note: vect_model_simple_cost: inside_cost = 12, prologue_cost = 0 .
embann.c:228:9: note: ==> examining statement: _3 = _2 - mean_12;
embann.c:228:9: note: vect_is_simple_use: operand _2
embann.c:228:9: note: def_stmt: _2 = (float) _1;
embann.c:228:9: note: type of def: internal
embann.c:228:9: note: vect_is_simple_use: operand mean_12
embann.c:228:9: note: def_stmt: mean_12 = mean_85 / _21;
embann.c:228:9: note: type of def: external
embann.c:228:9: note: === vectorizable_operation ===
embann.c:228:9: note: vect_model_simple_cost: inside_cost = 48, prologue_cost = 4 .
embann.c:228:9: note: ==> examining statement: powmult_9 = _3 * _3;
embann.c:228:9: note: vect_is_simple_use: operand _3
embann.c:228:9: note: def_stmt: _3 = _2 - mean_12;
embann.c:228:9: note: type of def: internal
embann.c:228:9: note: vect_is_simple_use: operand _3
embann.c:228:9: note: def_stmt: _3 = _2 - mean_12;
embann.c:228:9: note: type of def: internal
embann.c:228:9: note: === vectorizable_operation ===
embann.c:228:9: note: vect_model_simple_cost: inside_cost = 48, prologue_cost = 0 .
embann.c:228:9: note: ==> examining statement: sumofSquares_16 = powmult_9 + sumofSquares_44;
embann.c:228:9: note: vect_is_simple_use: operand powmult_9
embann.c:228:9: note: def_stmt: powmult_9 = _3 * _3;
embann.c:228:9: note: type of def: internal
embann.c:228:9: note: vect_is_simple_use: operand sumofSquares_44
embann.c:228:9: note: def_stmt: sumofSquares_44 = PHI <sumofSquares_48(14), sumofSquares_16(18)>
embann.c:228:9: note: type of def: reduction
vect_model_reduction_cost: inside_cost = 48, prologue_cost = 4, epilogue_cost = 16 .
embann.c:228:9: note: ==> examining statement: j_17 = j_50 + 1;
embann.c:228:9: note: irrelevant.
embann.c:228:9: note: ==> examining statement: if (_6 > j_17)
embann.c:228:9: note: irrelevant.
embann.c:228:9: note: not using a fully-masked loop.
embann.c:228:9: note: cost model: epilogue peel iters set to vf/2 because loop iterations are unknown .
embann.c:228:9: note: Cost model analysis: 
  Vector inside of loop cost: 168
  Vector prologue cost: 40
  Vector epilogue cost: 368
  Scalar iteration cost: 44
  Scalar outside cost: 32
  Vector outside cost: 408
  prologue iterations: 0
  epilogue iterations: 8
  Calculated minimum iters for profitability: 9
embann.c:228:9: note:   Runtime profitability threshold = 16
embann.c:228:9: note:   Static estimate profitability threshold = 16
embann.c:228:9: note: epilog loop required
embann.c:228:9: note: vect_can_advance_ivs_p:
embann.c:228:9: note: Analyze phi: sumofSquares_44 = PHI <sumofSquares_48(14), sumofSquares_16(18)>
embann.c:228:9: note: reduc or virtual phi. skip.
embann.c:228:9: note: Analyze phi: j_50 = PHI <0(14), j_17(18)>
embann.c:228:9: note: loop vectorized
embann.c:228:9: note: === vec_transform_loop ===
embann.c:228:9: note: Profitability threshold is 16 loop iterations.
embann.c:228:9: note: vect_update_ivs_after_vectorizer: phi: sumofSquares_44 = PHI <sumofSquares_16(18), sumofSquares_48(21)>
embann.c:228:9: note: reduc or virtual phi. skip.
embann.c:228:9: note: vect_update_ivs_after_vectorizer: phi: j_50 = PHI <j_17(18), 0(21)>
embann.c:228:9: note: ------>vectorizing phi: sumofSquares_44 = PHI <sumofSquares_16(18), sumofSquares_48(28)>
embann.c:228:9: note: multiple-types.
embann.c:228:9: note: transform phi.
embann.c:228:9: note: ------>vectorizing phi: j_50 = PHI <j_17(18), 0(28)>
embann.c:228:9: note: ------>vectorizing phi: vect_sumofSquares_16.231_66 = PHI <(18), (28)>
embann.c:228:9: note: ------>vectorizing statement: _1 = pTrainingData_49->data[j_50];
embann.c:228:9: note: transform statement.
embann.c:228:9: note: transform load. ncopies = 1
embann.c:228:9: note: create vector_type-pointer variable to type: vector(16) unsigned char  vectorizing a record based array ref: *pTrainingData_49
embann.c:228:9: note: created vectp_pTrainingData.233_65
embann.c:228:9: note: add new stmt: vect__1.234_62 = MEM[(uint8_t[0:] *)vectp_pTrainingData.232_64];
embann.c:228:9: note: ------>vectorizing statement: _2 = (float) _1;
embann.c:228:9: note: multiple-types.
embann.c:228:9: note: transform statement.
embann.c:228:9: note: vect_is_simple_use: operand _1
embann.c:228:9: note: def_stmt: _1 = pTrainingData_49->data[j_50];
embann.c:228:9: note: type of def: internal
embann.c:228:9: note: transform conversion. ncopies = 1.
embann.c:228:9: note: vect_get_vec_def_for_operand: _1
embann.c:228:9: note: vect_is_simple_use: operand _1
embann.c:228:9: note: def_stmt: _1 = pTrainingData_49->data[j_50];
embann.c:228:9: note: type of def: internal
embann.c:228:9: note:   def_stmt =  _1 = pTrainingData_49->data[j_50];
embann.c:228:9: note: add new stmt: vect__2.236_61 = [vec_unpack_lo_expr] vect__1.234_62;
embann.c:228:9: note: add new stmt: vect__2.236_60 = [vec_unpack_hi_expr] vect__1.234_62;
embann.c:228:9: note: add new stmt: vect__2.235_59 = [vec_unpack_float_lo_expr] vect__2.236_61;
embann.c:228:9: note: add new stmt: vect__2.235_58 = [vec_unpack_float_hi_expr] vect__2.236_61;
embann.c:228:9: note: add new stmt: vect__2.235_56 = [vec_unpack_float_lo_expr] vect__2.236_60;
embann.c:228:9: note: add new stmt: vect__2.235_55 = [vec_unpack_float_hi_expr] vect__2.236_60;
embann.c:228:9: note: ------>vectorizing statement: _3 = _2 - mean_12;
embann.c:228:9: note: multiple-types.
embann.c:228:9: note: transform statement.
embann.c:228:9: note: vect_is_simple_use: operand _2
embann.c:228:9: note: def_stmt: _2 = (float) _1;
embann.c:228:9: note: type of def: internal
embann.c:228:9: note: vect_is_simple_use: operand mean_12
embann.c:228:9: note: def_stmt: mean_12 = mean_85 / _21;
embann.c:228:9: note: type of def: external
embann.c:228:9: note: transform binary/unary operation.
embann.c:228:9: note: vect_get_vec_def_for_operand: _2
embann.c:228:9: note: vect_is_simple_use: operand _2
embann.c:228:9: note: def_stmt: _2 = (float) _1;
embann.c:228:9: note: type of def: internal
embann.c:228:9: note:   def_stmt =  _2 = (float) _1;
embann.c:228:9: note: vect_get_vec_def_for_operand: mean_12
embann.c:228:9: note: vect_is_simple_use: operand mean_12
embann.c:228:9: note: def_stmt: mean_12 = mean_85 / _21;
embann.c:228:9: note: type of def: external
embann.c:228:9: note:   def_stmt =  mean_12 = mean_85 / _21;
embann.c:228:9: note: created new init_stmt: vect_cst__54 = {mean_12, mean_12, mean_12, mean_12};
embann.c:228:9: note: add new stmt: vect__3.237_42 = vect__2.235_59 - vect_cst__54;
embann.c:228:9: note: add new stmt: vect__3.237_41 = vect__2.235_58 - vect_cst__54;
embann.c:228:9: note: add new stmt: vect__3.237_39 = vect__2.235_56 - vect_cst__54;
embann.c:228:9: note: add new stmt: vect__3.237_38 = vect__2.235_55 - vect_cst__54;
embann.c:228:9: note: ------>vectorizing statement: powmult_9 = _3 * _3;
embann.c:228:9: note: multiple-types.
embann.c:228:9: note: transform statement.
embann.c:228:9: note: vect_is_simple_use: operand _3
embann.c:228:9: note: def_stmt: _3 = _2 - mean_12;
embann.c:228:9: note: type of def: internal
embann.c:228:9: note: vect_is_simple_use: operand _3
embann.c:228:9: note: def_stmt: _3 = _2 - mean_12;
embann.c:228:9: note: type of def: internal
embann.c:228:9: note: transform binary/unary operation.
embann.c:228:9: note: vect_get_vec_def_for_operand: _3
embann.c:228:9: note: vect_is_simple_use: operand _3
embann.c:228:9: note: def_stmt: _3 = _2 - mean_12;
embann.c:228:9: note: type of def: internal
embann.c:228:9: note:   def_stmt =  _3 = _2 - mean_12;
embann.c:228:9: note: vect_get_vec_def_for_operand: _3
embann.c:228:9: note: vect_is_simple_use: operand _3
embann.c:228:9: note: def_stmt: _3 = _2 - mean_12;
embann.c:228:9: note: type of def: internal
embann.c:228:9: note:   def_stmt =  _3 = _2 - mean_12;
embann.c:228:9: note: add new stmt: vect_powmult_9.238_37 = vect__3.237_42 * vect__3.237_42;
embann.c:228:9: note: add new stmt: vect_powmult_9.238_36 = vect__3.237_41 * vect__3.237_41;
embann.c:228:9: note: add new stmt: vect_powmult_9.238_33 = vect__3.237_39 * vect__3.237_39;
embann.c:228:9: note: add new stmt: vect_powmult_9.238_30 = vect__3.237_38 * vect__3.237_38;
embann.c:228:9: note: ------>vectorizing statement: sumofSquares_16 = powmult_9 + sumofSquares_44;
embann.c:228:9: note: multiple-types.
embann.c:228:9: note: transform statement.
embann.c:228:9: note: vect_is_simple_use: operand powmult_9
embann.c:228:9: note: def_stmt: powmult_9 = _3 * _3;
embann.c:228:9: note: type of def: internal
embann.c:228:9: note: vect_is_simple_use: operand sumofSquares_44
embann.c:228:9: note: def_stmt: sumofSquares_44 = PHI <sumofSquares_16(18), sumofSquares_48(28)>
embann.c:228:9: note: type of def: reduction
embann.c:228:9: note: transform reduction.
embann.c:228:9: note: vect_get_vec_def_for_operand: powmult_9
embann.c:228:9: note: vect_is_simple_use: operand powmult_9
embann.c:228:9: note: def_stmt: powmult_9 = _3 * _3;
embann.c:228:9: note: type of def: internal
embann.c:228:9: note:   def_stmt =  powmult_9 = _3 * _3;
embann.c:228:9: note: vect_get_vec_def_for_operand: sumofSquares_44
embann.c:228:9: note: vect_is_simple_use: operand sumofSquares_44
embann.c:228:9: note: def_stmt: sumofSquares_44 = PHI <sumofSquares_16(18), sumofSquares_48(28)>
embann.c:228:9: note: type of def: reduction
embann.c:228:9: note:   def_stmt =  sumofSquares_44 = PHI <sumofSquares_16(18), sumofSquares_48(28)>
embann.c:228:9: note: add new stmt: vect_sumofSquares_16.239_29 = vect_powmult_9.238_37 + vect_sumofSquares_16.231_66;
embann.c:228:9: note: add new stmt: vect_sumofSquares_16.239_26 = vect_powmult_9.238_36 + vect_sumofSquares_16.239_29;
embann.c:228:9: note: add new stmt: vect_sumofSquares_16.239_23 = vect_powmult_9.238_33 + vect_sumofSquares_16.239_26;
embann.c:228:9: note: add new stmt: vect_sumofSquares_16.239_15 = vect_powmult_9.238_30 + vect_sumofSquares_16.239_23;
embann.c:228:9: note: vect_is_simple_use: operand sumofSquares_48
embann.c:228:9: note: def_stmt: sumofSquares_48 = PHI <0.0(12), sumofSquares_18(17)>
embann.c:228:9: note: type of def: external
embann.c:228:9: note: transform reduction: created def-use cycle: vect_sumofSquares_16.231_66 = PHI <vect_sumofSquares_16.239_15(18), { 0.0, 0.0, 0.0, 0.0 }(28)>
vect_sumofSquares_16.239_15 = vect_powmult_9.238_30 + vect_sumofSquares_16.239_23;
embann.c:228:9: note: Reduce using direct vector reduction.
embann.c:228:9: note: ------>vectorizing statement: j_17 = j_50 + 1;
embann.c:228:9: note: ------>vectorizing statement: vectp_pTrainingData.232_63 = vectp_pTrainingData.232_64 + 16;
embann.c:228:9: note: ------>vectorizing statement: if (_6 > j_17)
embann.c:228:9: note: New loop exit condition: if (ivtmp_82 < bnd.228_70)
embann.c:228:9: note: LOOP VECTORIZED


Analyzing loop at embann.c:204
embann.c:204:47: note: ===== analyze_loop_nest =====
embann.c:204:47: note: === vect_analyze_loop_form ===
embann.c:204:47: note: not vectorized: control flow in loop.
embann.c:204:47: note: bad loop form.

Analyzing loop at embann.c:204
embann.c:204:9: note: ===== analyze_loop_nest =====
embann.c:204:9: note: === vect_analyze_loop_form ===
embann.c:204:9: note: === get_loop_niters ===
embann.c:204:9: note: Symbolic number of iterations is (uint32_t) _43
embann.c:204:9: note: === vect_analyze_data_refs ===
embann.c:204:9: note: got vectype for stmt: _24 = pTrainingData_51->data[j_52];
vector(16) unsigned char
embann.c:204:9: note: === vect_analyze_scalar_cycles ===
embann.c:204:9: note: Analyze phi: j_52 = PHI <0(16), j_28(20)>
embann.c:204:9: note: Access function of PHI: {0, +, 1}_4
embann.c:204:9: note: step: 1,  init: 0
embann.c:204:9: note: Detected induction.
embann.c:204:9: note: Analyze phi: sum_53 = PHI <0(16), sum_27(20)>
embann.c:204:9: note: Access function of PHI: {0, +, _25}_4
embann.c:204:9: note: step: _25,  init: 0
embann.c:204:9: note: step unknown.
embann.c:204:9: note: Analyze phi: sum_53 = PHI <0(16), sum_27(20)>
embann.c:204:9: note: detected reduction: sum_27 = _25 + sum_53;
embann.c:204:9: note: Detected reduction.
embann.c:204:9: note: === vect_pattern_recog ===
embann.c:204:9: note: vect_is_simple_use: operand _25
embann.c:204:9: note: def_stmt: _25 = (unsigned int) _24;
embann.c:204:9: note: type of def: internal
embann.c:204:9: note: vect_is_simple_use: operand _24
embann.c:204:9: note: def_stmt: _24 = pTrainingData_51->data[j_52];
embann.c:204:9: note: type of def: internal
embann.c:204:9: note: vect_is_simple_use: operand _25
embann.c:204:9: note: def_stmt: _25 = (unsigned int) _24;
embann.c:204:9: note: type of def: internal
embann.c:204:9: note: vect_is_simple_use: operand _24
embann.c:204:9: note: def_stmt: _24 = pTrainingData_51->data[j_52];
embann.c:204:9: note: type of def: internal
embann.c:204:9: note: vect_is_simple_use: operand _25
embann.c:204:9: note: def_stmt: _25 = (unsigned int) _24;
embann.c:204:9: note: type of def: internal
embann.c:204:9: note: vect_is_simple_use: operand _24
embann.c:204:9: note: def_stmt: _24 = pTrainingData_51->data[j_52];
embann.c:204:9: note: type of def: internal
embann.c:204:9: note: vect_recog_widen_sum_pattern: detected: patt_73 = _24 w+ sum_53;
embann.c:204:9: note: === vect_analyze_data_ref_accesses ===
embann.c:204:9: note: === vect_mark_stmts_to_be_vectorized ===
embann.c:204:9: note: init: phi relevant? j_52 = PHI <0(16), j_28(20)>
embann.c:204:9: note: init: phi relevant? sum_53 = PHI <0(16), sum_27(20)>
embann.c:204:9: note: init: stmt relevant? _24 = pTrainingData_51->data[j_52];
embann.c:204:9: note: init: stmt relevant? _25 = (unsigned int) _24;
embann.c:204:9: note: init: stmt relevant? sum_27 = _25 + sum_53;
embann.c:204:9: note: vec_stmt_relevant_p: used out of loop.
embann.c:204:9: note: vect_is_simple_use: operand _25
embann.c:204:9: note: def_stmt: _25 = (unsigned int) _24;
embann.c:204:9: note: type of def: internal
embann.c:204:9: note: vec_stmt_relevant_p: stmt live but not relevant.
embann.c:204:9: note: mark relevant 1, live 1: sum_27 = _25 + sum_53;
embann.c:204:9: note: init: stmt relevant? j_28 = j_52 + 1;
embann.c:204:9: note: init: stmt relevant? if (j_28 < _43)
embann.c:204:9: note: worklist: examine stmt: sum_27 = _25 + sum_53;
embann.c:204:9: note: vect_is_simple_use: operand _25
embann.c:204:9: note: def_stmt: _25 = (unsigned int) _24;
embann.c:204:9: note: type of def: internal
embann.c:204:9: note: mark relevant 1, live 0: _25 = (unsigned int) _24;
embann.c:204:9: note: vect_is_simple_use: operand sum_53
embann.c:204:9: note: def_stmt: sum_53 = PHI <0(16), sum_27(20)>
embann.c:204:9: note: type of def: reduction
embann.c:204:9: note: mark relevant 1, live 0: sum_53 = PHI <0(16), sum_27(20)>
embann.c:204:9: note: worklist: examine stmt: sum_53 = PHI <0(16), sum_27(20)>
embann.c:204:9: note: vect_is_simple_use: operand 0
embann.c:204:9: note: vect_is_simple_use: operand sum_27
embann.c:204:9: note: def_stmt: sum_27 = _25 + sum_53;
embann.c:204:9: note: type of def: reduction
embann.c:204:9: note: reduc-stmt defining reduc-phi in the same nest.
embann.c:204:9: note: worklist: examine stmt: _25 = (unsigned int) _24;
embann.c:204:9: note: vect_is_simple_use: operand _24
embann.c:204:9: note: def_stmt: _24 = pTrainingData_51->data[j_52];
embann.c:204:9: note: type of def: internal
embann.c:204:9: note: mark relevant 1, live 0: _24 = pTrainingData_51->data[j_52];
embann.c:204:9: note: worklist: examine stmt: _24 = pTrainingData_51->data[j_52];
embann.c:204:9: note: === vect_analyze_data_ref_dependences ===
embann.c:204:9: note: === vect_determine_vectorization_factor ===
embann.c:204:9: note: ==> examining phi: j_52 = PHI <0(16), j_28(20)>
embann.c:204:9: note: ==> examining phi: sum_53 = PHI <0(16), sum_27(20)>
embann.c:204:9: note: get vectype for scalar type:  uint32_t
embann.c:204:9: note: vectype: vector(4) unsigned int
embann.c:204:9: note: nunits = 4
embann.c:204:9: note: ==> examining statement: _24 = pTrainingData_51->data[j_52];
embann.c:204:9: note: get vectype for scalar type:  unsigned char
embann.c:204:9: note: vectype: vector(16) unsigned char
embann.c:204:9: note: nunits = 16
embann.c:204:9: note: ==> examining statement: _25 = (unsigned int) _24;
embann.c:204:9: note: get vectype for scalar type:  unsigned int
embann.c:204:9: note: vectype: vector(4) unsigned int
embann.c:204:9: note: get vectype for scalar type:  unsigned char
embann.c:204:9: note: vectype: vector(16) unsigned char
embann.c:204:9: note: nunits = 16
embann.c:204:9: note: ==> examining statement: sum_27 = _25 + sum_53;
embann.c:204:9: note: get vectype for scalar type:  uint32_t
embann.c:204:9: note: vectype: vector(4) unsigned int
embann.c:204:9: note: get vectype for scalar type:  uint32_t
embann.c:204:9: note: vectype: vector(4) unsigned int
embann.c:204:9: note: nunits = 4
embann.c:204:9: note: ==> examining statement: j_28 = j_52 + 1;
embann.c:204:9: note: skip.
embann.c:204:9: note: ==> examining statement: if (j_28 < _43)
embann.c:204:9: note: skip.
embann.c:204:9: note: vectorization factor = 16
embann.c:204:9: note: === vect_analyze_slp ===
embann.c:204:9: note: === vect_make_slp_decision ===
embann.c:204:9: note: === vect_analyze_data_refs_alignment ===
embann.c:204:9: note: recording new base alignment for pTrainingData_51
embann.c:204:9: note:   alignment:    8
embann.c:204:9: note:   misalignment: 0
embann.c:204:9: note:   based on:     _24 = pTrainingData_51->data[j_52];
embann.c:204:9: note: vect_compute_data_ref_alignment:
embann.c:204:9: note: can't force alignment of ref: pTrainingData_51->data[j_52]
embann.c:204:9: note: === vect_prune_runtime_alias_test_list ===
embann.c:204:9: note: === vect_enhance_data_refs_alignment ===
embann.c:204:9: note: Unknown misalignment, naturally aligned
embann.c:204:9: note: vect_can_advance_ivs_p:
embann.c:204:9: note: Analyze phi: j_52 = PHI <0(16), j_28(20)>
embann.c:204:9: note: Analyze phi: sum_53 = PHI <0(16), sum_27(20)>
embann.c:204:9: note: reduc or virtual phi. skip.
embann.c:204:9: note: vect_model_load_cost: aligned.
embann.c:204:9: note: vect_get_data_access_cost: inside_cost = 12, outside_cost = 0.
embann.c:204:9: note: cost model: epilogue peel iters set to vf/2 because loop iterations are unknown .
embann.c:204:9: note: vect_model_load_cost: unaligned supported by hardware.
embann.c:204:9: note: vect_get_data_access_cost: inside_cost = 12, outside_cost = 0.
embann.c:204:9: note: cost model: epilogue peel iters set to vf/2 because loop iterations are unknown .
embann.c:204:9: note: Vectorizing an unaligned access.
embann.c:204:9: note: === vect_analyze_loop_operations ===
embann.c:204:9: note: examining phi: j_52 = PHI <0(16), j_28(20)>
embann.c:204:9: note: examining phi: sum_53 = PHI <0(16), sum_27(20)>
embann.c:204:9: note: ==> examining statement: _24 = pTrainingData_51->data[j_52];
embann.c:204:9: note: num. args = 4 (not unary/binary/ternary op).
embann.c:204:9: note: vect_is_simple_use: operand pTrainingData_51->data[j_52]
embann.c:204:9: note: not ssa-name.
embann.c:204:9: note: use not simple.
embann.c:204:9: note: can't use a fully-masked loop because the target doesn't have the appropriate masked load or store.
embann.c:204:9: note: vect_model_load_cost: unaligned supported by hardware.
embann.c:204:9: note: vect_model_load_cost: inside_cost = 12, prologue_cost = 0 .
embann.c:204:9: note: ==> examining statement: _25 = (unsigned int) _24;
embann.c:204:9: note: vect_is_simple_use: operand _24
embann.c:204:9: note: def_stmt: _24 = pTrainingData_51->data[j_52];
embann.c:204:9: note: type of def: internal
embann.c:204:9: note: === vectorizable_conversion ===
embann.c:204:9: note: vect_model_promotion_demotion_cost: inside_cost = 24, prologue_cost = 0 .
embann.c:204:9: note: ==> examining statement: sum_27 = _25 + sum_53;
embann.c:204:9: note: vect_is_simple_use: operand _25
embann.c:204:9: note: def_stmt: _25 = (unsigned int) _24;
embann.c:204:9: note: type of def: internal
embann.c:204:9: note: vect_is_simple_use: operand sum_53
embann.c:204:9: note: def_stmt: sum_53 = PHI <0(16), sum_27(20)>
embann.c:204:9: note: type of def: reduction
embann.c:204:9: note: reduc op not supported by target.
vect_model_reduction_cost: inside_cost = 16, prologue_cost = 4, epilogue_cost = 20 .
embann.c:204:9: note: ==> examining statement: j_28 = j_52 + 1;
embann.c:204:9: note: irrelevant.
embann.c:204:9: note: ==> examining statement: if (j_28 < _43)
embann.c:204:9: note: irrelevant.
embann.c:204:9: note: not using a fully-masked loop.
embann.c:204:9: note: cost model: epilogue peel iters set to vf/2 because loop iterations are unknown .
embann.c:204:9: note: Cost model analysis: 
  Vector inside of loop cost: 52
  Vector prologue cost: 36
  Vector epilogue cost: 180
  Scalar iteration cost: 20
  Scalar outside cost: 32
  Vector outside cost: 216
  prologue iterations: 0
  epilogue iterations: 8
  Calculated minimum iters for profitability: 10
embann.c:204:9: note:   Runtime profitability threshold = 16
embann.c:204:9: note:   Static estimate profitability threshold = 16
embann.c:204:9: note: epilog loop required
embann.c:204:9: note: vect_can_advance_ivs_p:
embann.c:204:9: note: Analyze phi: j_52 = PHI <0(16), j_28(20)>
embann.c:204:9: note: Analyze phi: sum_53 = PHI <0(16), sum_27(20)>
embann.c:204:9: note: reduc or virtual phi. skip.
embann.c:204:9: note: loop vectorized
embann.c:204:9: note: === vec_transform_loop ===
embann.c:204:9: note: Profitability threshold is 16 loop iterations.
embann.c:204:9: note: vect_update_ivs_after_vectorizer: phi: j_52 = PHI <j_28(20), 0(29)>
embann.c:204:9: note: vect_update_ivs_after_vectorizer: phi: sum_53 = PHI <sum_27(20), 0(29)>
embann.c:204:9: note: reduc or virtual phi. skip.
embann.c:204:9: note: ------>vectorizing phi: j_52 = PHI <j_28(20), 0(36)>
embann.c:204:9: note: ------>vectorizing phi: sum_53 = PHI <sum_27(20), 0(36)>
embann.c:204:9: note: multiple-types.
embann.c:204:9: note: transform phi.
embann.c:204:9: note: ------>vectorizing phi: vect_sum_27.246_102 = PHI <(20), (36)>
embann.c:204:9: note: ------>vectorizing statement: _24 = pTrainingData_51->data[j_52];
embann.c:204:9: note: transform statement.
embann.c:204:9: note: transform load. ncopies = 1
embann.c:204:9: note: create vector_type-pointer variable to type: vector(16) unsigned char  vectorizing a record based array ref: *pTrainingData_51
embann.c:204:9: note: created vectp_pTrainingData.248_103
embann.c:204:9: note: add new stmt: vect__24.249_106 = MEM[(uint8_t[0:] *)vectp_pTrainingData.247_104];
embann.c:204:9: note: ------>vectorizing statement: _25 = (unsigned int) _24;
embann.c:204:9: note: multiple-types.
embann.c:204:9: note: transform statement.
embann.c:204:9: note: vect_is_simple_use: operand _24
embann.c:204:9: note: def_stmt: _24 = pTrainingData_51->data[j_52];
embann.c:204:9: note: type of def: internal
embann.c:204:9: note: transform conversion. ncopies = 1.
embann.c:204:9: note: vect_get_vec_def_for_operand: _24
embann.c:204:9: note: vect_is_simple_use: operand _24
embann.c:204:9: note: def_stmt: _24 = pTrainingData_51->data[j_52];
embann.c:204:9: note: type of def: internal
embann.c:204:9: note:   def_stmt =  _24 = pTrainingData_51->data[j_52];
embann.c:204:9: note: add new stmt: vect__25.251_107 = [vec_unpack_lo_expr] vect__24.249_106;
embann.c:204:9: note: add new stmt: vect__25.251_108 = [vec_unpack_hi_expr] vect__24.249_106;
embann.c:204:9: note: add new stmt: vect__25.250_109 = [vec_unpack_lo_expr] vect__25.251_107;
embann.c:204:9: note: add new stmt: vect__25.250_110 = [vec_unpack_hi_expr] vect__25.251_107;
embann.c:204:9: note: add new stmt: vect__25.250_111 = [vec_unpack_lo_expr] vect__25.251_108;
embann.c:204:9: note: add new stmt: vect__25.250_112 = [vec_unpack_hi_expr] vect__25.251_108;
embann.c:204:9: note: ------>vectorizing statement: sum_27 = _25 + sum_53;
embann.c:204:9: note: multiple-types.
embann.c:204:9: note: transform statement.
embann.c:204:9: note: vect_is_simple_use: operand _25
embann.c:204:9: note: def_stmt: _25 = (unsigned int) _24;
embann.c:204:9: note: type of def: internal
embann.c:204:9: note: vect_is_simple_use: operand sum_53
embann.c:204:9: note: def_stmt: sum_53 = PHI <sum_27(20), 0(36)>
embann.c:204:9: note: type of def: reduction
embann.c:204:9: note: reduc op not supported by target.
embann.c:204:9: note: transform reduction.
embann.c:204:9: note: vect_get_vec_def_for_operand: _25
embann.c:204:9: note: vect_is_simple_use: operand _25
embann.c:204:9: note: def_stmt: _25 = (unsigned int) _24;
embann.c:204:9: note: type of def: internal
embann.c:204:9: note:   def_stmt =  _25 = (unsigned int) _24;
embann.c:204:9: note: vect_get_vec_def_for_operand: sum_53
embann.c:204:9: note: vect_is_simple_use: operand sum_53
embann.c:204:9: note: def_stmt: sum_53 = PHI <sum_27(20), 0(36)>
embann.c:204:9: note: type of def: reduction
embann.c:204:9: note:   def_stmt =  sum_53 = PHI <sum_27(20), 0(36)>
embann.c:204:9: note: add new stmt: vect_sum_27.252_113 = vect__25.250_109 + vect_sum_27.246_102;
embann.c:204:9: note: add new stmt: vect_sum_27.252_114 = vect__25.250_110 + vect_sum_27.252_113;
embann.c:204:9: note: add new stmt: vect_sum_27.252_115 = vect__25.250_111 + vect_sum_27.252_114;
embann.c:204:9: note: add new stmt: vect_sum_27.252_116 = vect__25.250_112 + vect_sum_27.252_115;
embann.c:204:9: note: vect_is_simple_use: operand 0
embann.c:204:9: note: transform reduction: created def-use cycle: vect_sum_27.246_102 = PHI <vect_sum_27.252_116(20), { 0, 0, 0, 0 }(36)>
vect_sum_27.252_116 = vect__25.250_112 + vect_sum_27.252_115;
embann.c:204:9: note: Reduce using vector shifts
embann.c:204:9: note: extract scalar result
embann.c:204:9: note: ------>vectorizing statement: j_28 = j_52 + 1;
embann.c:204:9: note: ------>vectorizing statement: vectp_pTrainingData.247_105 = vectp_pTrainingData.247_104 + 16;
embann.c:204:9: note: ------>vectorizing statement: if (j_28 < _43)
embann.c:204:9: note: New loop exit condition: if (ivtmp_125 < bnd.243_99)
embann.c:204:9: note: LOOP VECTORIZED

embann.c:219:7: note: vectorized 2 loops in function.
embann.c:228:9: note: loop with 14 iterations completely unrolled (header execution count 19408838)
embann.c:204:9: note: loop with 14 iterations completely unrolled (header execution count 21807687)
embann.c:219:7: note: ===vect_slp_analyze_bb===
embann.c:202:11: note: === vect_analyze_data_refs ===
embann.c:202:11: note: got vectype for stmt: pTrainingData_14 = trainingDataCollection.head;
vector(2) long unsigned int
embann.c:202:11: note: not vectorized: not enough data-refs in basic block.
embann.c:202:11: note: ===vect_slp_analyze_bb===
embann.c:202:11: note: ===vect_slp_analyze_bb===
embann.c:202:11: note: === vect_analyze_data_refs ===
embann.c:202:11: note: not vectorized: not enough data-refs in basic block.
embann.c:202:11: note: ===vect_slp_analyze_bb===
embann.c:202:11: note: === vect_analyze_data_refs ===
embann.c:202:11: note: not vectorized: not enough data-refs in basic block.
embann.c:202:11: note: ===vect_slp_analyze_bb===
embann.c:206:17: note: === vect_analyze_data_refs ===
embann.c:206:17: note: not vectorized: no vectype for stmt: vect__24.249_106 = MEM[(uint8_t[0:] *)vectp_pTrainingData.247_104];
 scalar_type: vector(16) unsigned char
embann.c:206:17: note: not vectorized: not enough data-refs in basic block.
embann.c:206:17: note: ===vect_slp_analyze_bb===
embann.c:206:17: note: ===vect_slp_analyze_bb===
embann.c:206:17: note: === vect_analyze_data_refs ===
embann.c:206:17: note: not vectorized: not enough data-refs in basic block.
embann.c:206:17: note: ===vect_slp_analyze_bb===
embann.c:204:9: note: === vect_analyze_data_refs ===
embann.c:204:9: note: got vectype for stmt: _222 = pTrainingData_51->data[j_97];
vector(16) unsigned char
embann.c:204:9: note: not vectorized: not enough data-refs in basic block.
embann.c:204:9: note: ===vect_slp_analyze_bb===
embann.c:204:9: note: === vect_analyze_data_refs ===
embann.c:204:9: note: got vectype for stmt: _228 = pTrainingData_51->data[j_226];
vector(16) unsigned char
embann.c:204:9: note: not vectorized: not enough data-refs in basic block.
embann.c:204:9: note: ===vect_slp_analyze_bb===
embann.c:204:9: note: === vect_analyze_data_refs ===
embann.c:204:9: note: got vectype for stmt: _234 = pTrainingData_51->data[j_232];
vector(16) unsigned char
embann.c:204:9: note: not vectorized: not enough data-refs in basic block.
embann.c:204:9: note: ===vect_slp_analyze_bb===
embann.c:204:9: note: === vect_analyze_data_refs ===
embann.c:204:9: note: got vectype for stmt: _240 = pTrainingData_51->data[j_238];
vector(16) unsigned char
embann.c:204:9: note: not vectorized: not enough data-refs in basic block.
embann.c:204:9: note: ===vect_slp_analyze_bb===
embann.c:204:9: note: === vect_analyze_data_refs ===
embann.c:204:9: note: got vectype for stmt: _246 = pTrainingData_51->data[j_244];
vector(16) unsigned char
embann.c:204:9: note: not vectorized: not enough data-refs in basic block.
embann.c:204:9: note: ===vect_slp_analyze_bb===
embann.c:204:9: note: === vect_analyze_data_refs ===
embann.c:204:9: note: got vectype for stmt: _252 = pTrainingData_51->data[j_250];
vector(16) unsigned char
embann.c:204:9: note: not vectorized: not enough data-refs in basic block.
embann.c:204:9: note: ===vect_slp_analyze_bb===
embann.c:204:9: note: === vect_analyze_data_refs ===
embann.c:204:9: note: got vectype for stmt: _258 = pTrainingData_51->data[j_256];
vector(16) unsigned char
embann.c:204:9: note: not vectorized: not enough data-refs in basic block.
embann.c:204:9: note: ===vect_slp_analyze_bb===
embann.c:204:9: note: === vect_analyze_data_refs ===
embann.c:204:9: note: got vectype for stmt: _264 = pTrainingData_51->data[j_262];
vector(16) unsigned char
embann.c:204:9: note: not vectorized: not enough data-refs in basic block.
embann.c:204:9: note: ===vect_slp_analyze_bb===
embann.c:204:9: note: === vect_analyze_data_refs ===
embann.c:204:9: note: got vectype for stmt: _270 = pTrainingData_51->data[j_268];
vector(16) unsigned char
embann.c:204:9: note: not vectorized: not enough data-refs in basic block.
embann.c:204:9: note: ===vect_slp_analyze_bb===
embann.c:204:9: note: === vect_analyze_data_refs ===
embann.c:204:9: note: got vectype for stmt: _276 = pTrainingData_51->data[j_274];
vector(16) unsigned char
embann.c:204:9: note: not vectorized: not enough data-refs in basic block.
embann.c:204:9: note: ===vect_slp_analyze_bb===
embann.c:204:9: note: === vect_analyze_data_refs ===
embann.c:204:9: note: got vectype for stmt: _282 = pTrainingData_51->data[j_280];
vector(16) unsigned char
embann.c:204:9: note: not vectorized: not enough data-refs in basic block.
embann.c:204:9: note: ===vect_slp_analyze_bb===
embann.c:204:9: note: === vect_analyze_data_refs ===
embann.c:204:9: note: got vectype for stmt: _288 = pTrainingData_51->data[j_286];
vector(16) unsigned char
embann.c:204:9: note: not vectorized: not enough data-refs in basic block.
embann.c:204:9: note: ===vect_slp_analyze_bb===
embann.c:204:9: note: === vect_analyze_data_refs ===
embann.c:204:9: note: got vectype for stmt: _294 = pTrainingData_51->data[j_292];
vector(16) unsigned char
embann.c:204:9: note: not vectorized: not enough data-refs in basic block.
embann.c:204:9: note: ===vect_slp_analyze_bb===
embann.c:204:9: note: === vect_analyze_data_refs ===
embann.c:204:9: note: got vectype for stmt: _300 = pTrainingData_51->data[j_298];
vector(16) unsigned char
embann.c:204:9: note: not vectorized: not enough data-refs in basic block.
embann.c:204:9: note: ===vect_slp_analyze_bb===
embann.c:204:58: note: === vect_analyze_data_refs ===
embann.c:204:58: note: got vectype for stmt: _91 = pTrainingData_51->data[j_7];
vector(16) unsigned char
embann.c:204:58: note: not vectorized: not enough data-refs in basic block.
embann.c:204:58: note: ===vect_slp_analyze_bb===
embann.c:202:11: note: === vect_analyze_data_refs ===
embann.c:202:11: note: got vectype for stmt: pTrainingData_35 = pTrainingData_51->next;
vector(2) long unsigned int
embann.c:202:11: note: not vectorized: not enough data-refs in basic block.
embann.c:202:11: note: ===vect_slp_analyze_bb===
embann.c:202:11: note: ===vect_slp_analyze_bb===
embann.c:204:9: note: === vect_analyze_data_refs ===
embann.c:204:9: note: got vectype for stmt: _43 = pTrainingData_51->length;
vector(4) unsigned int
embann.c:204:9: note: not vectorized: not enough data-refs in basic block.
embann.c:204:9: note: ===vect_slp_analyze_bb===
embann.c:204:9: note: === vect_analyze_data_refs ===
embann.c:204:9: note: not vectorized: not enough data-refs in basic block.
embann.c:204:9: note: ===vect_slp_analyze_bb===
embann.c:204:9: note: === vect_analyze_data_refs ===
embann.c:204:9: note: not vectorized: not enough data-refs in basic block.
embann.c:204:9: note: ===vect_slp_analyze_bb===
embann.c:230:26: note: === vect_analyze_data_refs ===
embann.c:230:26: note: not vectorized: no vectype for stmt: vect__1.234_62 = MEM[(uint8_t[0:] *)vectp_pTrainingData.232_64];
 scalar_type: vector(16) unsigned char
embann.c:230:26: note: not vectorized: not enough data-refs in basic block.
embann.c:230:26: note: ===vect_slp_analyze_bb===
embann.c:230:26: note: ===vect_slp_analyze_bb===
embann.c:230:26: note: === vect_analyze_data_refs ===
embann.c:230:26: note: not vectorized: not enough data-refs in basic block.
embann.c:230:26: note: ===vect_slp_analyze_bb===
embann.c:228:9: note: === vect_analyze_data_refs ===
embann.c:228:9: note: got vectype for stmt: _44 = pTrainingData_49->data[j_71];
vector(16) unsigned char
embann.c:228:9: note: not vectorized: not enough data-refs in basic block.
embann.c:228:9: note: ===vect_slp_analyze_bb===
embann.c:228:9: note: === vect_analyze_data_refs ===
embann.c:228:9: note: got vectype for stmt: _1 = pTrainingData_49->data[j_28];
vector(16) unsigned char
embann.c:228:9: note: not vectorized: not enough data-refs in basic block.
embann.c:228:9: note: ===vect_slp_analyze_bb===
embann.c:228:9: note: === vect_analyze_data_refs ===
embann.c:228:9: note: got vectype for stmt: _126 = pTrainingData_49->data[j_47];
vector(16) unsigned char
embann.c:228:9: note: not vectorized: not enough data-refs in basic block.
embann.c:228:9: note: ===vect_slp_analyze_bb===
embann.c:228:9: note: === vect_analyze_data_refs ===
embann.c:228:9: note: got vectype for stmt: _134 = pTrainingData_49->data[j_133];
vector(16) unsigned char
embann.c:228:9: note: not vectorized: not enough data-refs in basic block.
embann.c:228:9: note: ===vect_slp_analyze_bb===
embann.c:228:9: note: === vect_analyze_data_refs ===
embann.c:228:9: note: got vectype for stmt: _142 = pTrainingData_49->data[j_141];
vector(16) unsigned char
embann.c:228:9: note: not vectorized: not enough data-refs in basic block.
embann.c:228:9: note: ===vect_slp_analyze_bb===
embann.c:228:9: note: === vect_analyze_data_refs ===
embann.c:228:9: note: got vectype for stmt: _150 = pTrainingData_49->data[j_149];
vector(16) unsigned char
embann.c:228:9: note: not vectorized: not enough data-refs in basic block.
embann.c:228:9: note: ===vect_slp_analyze_bb===
embann.c:228:9: note: === vect_analyze_data_refs ===
embann.c:228:9: note: got vectype for stmt: _158 = pTrainingData_49->data[j_157];
vector(16) unsigned char
embann.c:228:9: note: not vectorized: not enough data-refs in basic block.
embann.c:228:9: note: ===vect_slp_analyze_bb===
embann.c:228:9: note: === vect_analyze_data_refs ===
embann.c:228:9: note: got vectype for stmt: _166 = pTrainingData_49->data[j_165];
vector(16) unsigned char
embann.c:228:9: note: not vectorized: not enough data-refs in basic block.
embann.c:228:9: note: ===vect_slp_analyze_bb===
embann.c:228:9: note: === vect_analyze_data_refs ===
embann.c:228:9: note: got vectype for stmt: _174 = pTrainingData_49->data[j_173];
vector(16) unsigned char
embann.c:228:9: note: not vectorized: not enough data-refs in basic block.
embann.c:228:9: note: ===vect_slp_analyze_bb===
embann.c:228:9: note: === vect_analyze_data_refs ===
embann.c:228:9: note: got vectype for stmt: _182 = pTrainingData_49->data[j_181];
vector(16) unsigned char
embann.c:228:9: note: not vectorized: not enough data-refs in basic block.
embann.c:228:9: note: ===vect_slp_analyze_bb===
embann.c:228:9: note: === vect_analyze_data_refs ===
embann.c:228:9: note: got vectype for stmt: _190 = pTrainingData_49->data[j_189];
vector(16) unsigned char
embann.c:228:9: note: not vectorized: not enough data-refs in basic block.
embann.c:228:9: note: ===vect_slp_analyze_bb===
embann.c:228:9: note: === vect_analyze_data_refs ===
embann.c:228:9: note: got vectype for stmt: _198 = pTrainingData_49->data[j_197];
vector(16) unsigned char
embann.c:228:9: note: not vectorized: not enough data-refs in basic block.
embann.c:228:9: note: ===vect_slp_analyze_bb===
embann.c:228:9: note: === vect_analyze_data_refs ===
embann.c:228:9: note: got vectype for stmt: _206 = pTrainingData_49->data[j_205];
vector(16) unsigned char
embann.c:228:9: note: not vectorized: not enough data-refs in basic block.
embann.c:228:9: note: ===vect_slp_analyze_bb===
embann.c:228:9: note: === vect_analyze_data_refs ===
embann.c:228:9: note: got vectype for stmt: _214 = pTrainingData_49->data[j_213];
vector(16) unsigned char
embann.c:228:9: note: not vectorized: not enough data-refs in basic block.
embann.c:228:9: note: ===vect_slp_analyze_bb===
embann.c:228:58: note: === vect_analyze_data_refs ===
embann.c:228:58: note: got vectype for stmt: _81 = pTrainingData_49->data[j_83];
vector(16) unsigned char
embann.c:228:58: note: not vectorized: not enough data-refs in basic block.
embann.c:228:58: note: ===vect_slp_analyze_bb===
embann.c:228:58: note: === vect_analyze_data_refs ===
embann.c:228:58: note: not vectorized: not enough data-refs in basic block.
embann.c:228:58: note: ===vect_slp_analyze_bb===
embann.c:226:11: note: === vect_analyze_data_refs ===
embann.c:226:11: note: got vectype for stmt: pTrainingData_19 = pTrainingData_49->next;
vector(2) long unsigned int
embann.c:226:11: note: not vectorized: not enough data-refs in basic block.
embann.c:226:11: note: ===vect_slp_analyze_bb===
embann.c:226:11: note: === vect_analyze_data_refs ===
embann.c:226:11: note: not vectorized: not enough data-refs in basic block.
embann.c:226:11: note: ===vect_slp_analyze_bb===
embann.c:226:11: note: ===vect_slp_analyze_bb===
embann.c:228:9: note: === vect_analyze_data_refs ===
embann.c:228:9: note: got vectype for stmt: _6 = pTrainingData_49->length;
vector(4) unsigned int
embann.c:228:9: note: not vectorized: not enough data-refs in basic block.
embann.c:228:9: note: ===vect_slp_analyze_bb===
embann.c:238:12: note: === vect_analyze_data_refs ===
embann.c:238:12: note: not vectorized: not enough data-refs in basic block.
embann.c:238:12: note: ===vect_slp_analyze_bb===
embann.c:214:10: note: === vect_analyze_data_refs ===
embann.c:214:10: note: got vectype for stmt: _40 = trainingDataCollection.numEntries;
vector(4) unsigned int
embann.c:214:10: note: not vectorized: not enough data-refs in basic block.
embann.c:214:10: note: ===vect_slp_analyze_bb===

Analyzing loop at embann.c:255
embann.c:255:11: note: ===== analyze_loop_nest =====
embann.c:255:11: note: === vect_analyze_loop_form ===
embann.c:255:11: note: not vectorized: control flow in loop.
embann.c:255:11: note: bad loop form.

Analyzing loop at embann.c:257
embann.c:257:9: note: ===== analyze_loop_nest =====
embann.c:257:9: note: === vect_analyze_loop_form ===
embann.c:257:9: note: === get_loop_niters ===
embann.c:257:9: note: Symbolic number of iterations is _6
embann.c:257:9: note: === vect_analyze_data_refs ===
embann.c:257:9: note: got vectype for stmt: _1 = pTrainingData_25->data[j_23];
vector(16) unsigned char
embann.c:257:9: note: === vect_analyze_scalar_cycles ===
embann.c:257:9: note: Analyze phi: max_3 = PHI <max_26(9), max_11(11)>
embann.c:257:9: note: Access function of PHI: max_3
embann.c:257:9: note: Analyze phi: j_23 = PHI <0(9), j_12(11)>
embann.c:257:9: note: Access function of PHI: {0, +, 1}_2
embann.c:257:9: note: step: 1,  init: 0
embann.c:257:9: note: Detected induction.
embann.c:257:9: note: Analyze phi: max_3 = PHI <max_26(9), max_11(11)>
embann.c:257:9: note: detected reduction: max_11 = MAX_EXPR <_1, max_3>;
embann.c:257:9: note: Detected reduction.
embann.c:257:9: note: === vect_pattern_recog ===
embann.c:257:9: note: === vect_analyze_data_ref_accesses ===
embann.c:257:9: note: === vect_mark_stmts_to_be_vectorized ===
embann.c:257:9: note: init: phi relevant? max_3 = PHI <max_26(9), max_11(11)>
embann.c:257:9: note: init: phi relevant? j_23 = PHI <0(9), j_12(11)>
embann.c:257:9: note: init: stmt relevant? _1 = pTrainingData_25->data[j_23];
embann.c:257:9: note: init: stmt relevant? max_11 = MAX_EXPR <_1, max_3>;
embann.c:257:9: note: vec_stmt_relevant_p: used out of loop.
embann.c:257:9: note: vect_is_simple_use: operand _1
embann.c:257:9: note: def_stmt: _1 = pTrainingData_25->data[j_23];
embann.c:257:9: note: type of def: internal
embann.c:257:9: note: vec_stmt_relevant_p: stmt live but not relevant.
embann.c:257:9: note: mark relevant 1, live 1: max_11 = MAX_EXPR <_1, max_3>;
embann.c:257:9: note: init: stmt relevant? j_12 = j_23 + 1;
embann.c:257:9: note: init: stmt relevant? if (_6 > j_12)
embann.c:257:9: note: worklist: examine stmt: max_11 = MAX_EXPR <_1, max_3>;
embann.c:257:9: note: vect_is_simple_use: operand _1
embann.c:257:9: note: def_stmt: _1 = pTrainingData_25->data[j_23];
embann.c:257:9: note: type of def: internal
embann.c:257:9: note: mark relevant 1, live 0: _1 = pTrainingData_25->data[j_23];
embann.c:257:9: note: vect_is_simple_use: operand max_3
embann.c:257:9: note: def_stmt: max_3 = PHI <max_26(9), max_11(11)>
embann.c:257:9: note: type of def: reduction
embann.c:257:9: note: mark relevant 1, live 0: max_3 = PHI <max_26(9), max_11(11)>
embann.c:257:9: note: worklist: examine stmt: max_3 = PHI <max_26(9), max_11(11)>
embann.c:257:9: note: vect_is_simple_use: operand max_26
embann.c:257:9: note: def_stmt: max_26 = PHI <max_10(3), max_24(10)>
embann.c:257:9: note: type of def: external
embann.c:257:9: note: def_stmt is out of loop.
embann.c:257:9: note: vect_is_simple_use: operand max_11
embann.c:257:9: note: def_stmt: max_11 = MAX_EXPR <_1, max_3>;
embann.c:257:9: note: type of def: reduction
embann.c:257:9: note: reduc-stmt defining reduc-phi in the same nest.
embann.c:257:9: note: worklist: examine stmt: _1 = pTrainingData_25->data[j_23];
embann.c:257:9: note: === vect_analyze_data_ref_dependences ===
embann.c:257:9: note: === vect_determine_vectorization_factor ===
embann.c:257:9: note: ==> examining phi: max_3 = PHI <max_26(9), max_11(11)>
embann.c:257:9: note: get vectype for scalar type:  uint8_t
embann.c:257:9: note: vectype: vector(16) unsigned char
embann.c:257:9: note: nunits = 16
embann.c:257:9: note: ==> examining phi: j_23 = PHI <0(9), j_12(11)>
embann.c:257:9: note: ==> examining statement: _1 = pTrainingData_25->data[j_23];
embann.c:257:9: note: get vectype for scalar type:  unsigned char
embann.c:257:9: note: vectype: vector(16) unsigned char
embann.c:257:9: note: nunits = 16
embann.c:257:9: note: ==> examining statement: max_11 = MAX_EXPR <_1, max_3>;
embann.c:257:9: note: get vectype for scalar type:  uint8_t
embann.c:257:9: note: vectype: vector(16) unsigned char
embann.c:257:9: note: get vectype for scalar type:  uint8_t
embann.c:257:9: note: vectype: vector(16) unsigned char
embann.c:257:9: note: nunits = 16
embann.c:257:9: note: ==> examining statement: j_12 = j_23 + 1;
embann.c:257:9: note: skip.
embann.c:257:9: note: ==> examining statement: if (_6 > j_12)
embann.c:257:9: note: skip.
embann.c:257:9: note: vectorization factor = 16
embann.c:257:9: note: === vect_analyze_slp ===
embann.c:257:9: note: === vect_make_slp_decision ===
embann.c:257:9: note: === vect_analyze_data_refs_alignment ===
embann.c:257:9: note: recording new base alignment for pTrainingData_25
embann.c:257:9: note:   alignment:    8
embann.c:257:9: note:   misalignment: 0
embann.c:257:9: note:   based on:     _1 = pTrainingData_25->data[j_23];
embann.c:257:9: note: vect_compute_data_ref_alignment:
embann.c:257:9: note: can't force alignment of ref: pTrainingData_25->data[j_23]
embann.c:257:9: note: === vect_prune_runtime_alias_test_list ===
embann.c:257:9: note: === vect_enhance_data_refs_alignment ===
embann.c:257:9: note: Unknown misalignment, naturally aligned
embann.c:257:9: note: vect_can_advance_ivs_p:
embann.c:257:9: note: Analyze phi: max_3 = PHI <max_26(9), max_11(11)>
embann.c:257:9: note: reduc or virtual phi. skip.
embann.c:257:9: note: Analyze phi: j_23 = PHI <0(9), j_12(11)>
embann.c:257:9: note: vect_model_load_cost: aligned.
embann.c:257:9: note: vect_get_data_access_cost: inside_cost = 12, outside_cost = 0.
embann.c:257:9: note: cost model: epilogue peel iters set to vf/2 because loop iterations are unknown .
embann.c:257:9: note: vect_model_load_cost: unaligned supported by hardware.
embann.c:257:9: note: vect_get_data_access_cost: inside_cost = 12, outside_cost = 0.
embann.c:257:9: note: cost model: epilogue peel iters set to vf/2 because loop iterations are unknown .
embann.c:257:9: note: Vectorizing an unaligned access.
embann.c:257:9: note: === vect_analyze_loop_operations ===
embann.c:257:9: note: examining phi: max_3 = PHI <max_26(9), max_11(11)>
embann.c:257:9: note: examining phi: j_23 = PHI <0(9), j_12(11)>
embann.c:257:9: note: ==> examining statement: _1 = pTrainingData_25->data[j_23];
embann.c:257:9: note: num. args = 4 (not unary/binary/ternary op).
embann.c:257:9: note: vect_is_simple_use: operand pTrainingData_25->data[j_23]
embann.c:257:9: note: not ssa-name.
embann.c:257:9: note: use not simple.
embann.c:257:9: note: can't use a fully-masked loop because the target doesn't have the appropriate masked load or store.
embann.c:257:9: note: vect_model_load_cost: unaligned supported by hardware.
embann.c:257:9: note: vect_model_load_cost: inside_cost = 12, prologue_cost = 0 .
embann.c:257:9: note: ==> examining statement: max_11 = MAX_EXPR <_1, max_3>;
embann.c:257:9: note: vect_is_simple_use: operand _1
embann.c:257:9: note: def_stmt: _1 = pTrainingData_25->data[j_23];
embann.c:257:9: note: type of def: internal
embann.c:257:9: note: vect_is_simple_use: operand max_3
embann.c:257:9: note: def_stmt: max_3 = PHI <max_26(9), max_11(11)>
embann.c:257:9: note: type of def: reduction
embann.c:257:9: note: reduc op not supported by target.
vect_model_reduction_cost: inside_cost = 4, prologue_cost = 4, epilogue_cost = 36 .
embann.c:257:9: note: ==> examining statement: j_12 = j_23 + 1;
embann.c:257:9: note: irrelevant.
embann.c:257:9: note: ==> examining statement: if (_6 > j_12)
embann.c:257:9: note: irrelevant.
embann.c:257:9: note: not using a fully-masked loop.
embann.c:257:9: note: cost model: epilogue peel iters set to vf/2 because loop iterations are unknown .
embann.c:257:9: note: Cost model analysis: 
  Vector inside of loop cost: 16
  Vector prologue cost: 36
  Vector epilogue cost: 164
  Scalar iteration cost: 16
  Scalar outside cost: 32
  Vector outside cost: 200
  prologue iterations: 0
  epilogue iterations: 8
  Calculated minimum iters for profitability: 11
embann.c:257:9: note:   Runtime profitability threshold = 16
embann.c:257:9: note:   Static estimate profitability threshold = 16
embann.c:257:9: note: epilog loop required
embann.c:257:9: note: vect_can_advance_ivs_p:
embann.c:257:9: note: Analyze phi: max_3 = PHI <max_26(9), max_11(11)>
embann.c:257:9: note: reduc or virtual phi. skip.
embann.c:257:9: note: Analyze phi: j_23 = PHI <0(9), j_12(11)>
embann.c:257:9: note: loop vectorized
embann.c:257:9: note: === vec_transform_loop ===
embann.c:257:9: note: Profitability threshold is 16 loop iterations.
embann.c:257:9: note: vect_update_ivs_after_vectorizer: phi: max_3 = PHI <max_11(11), max_26(14)>
embann.c:257:9: note: reduc or virtual phi. skip.
embann.c:257:9: note: vect_update_ivs_after_vectorizer: phi: j_23 = PHI <j_12(11), 0(14)>
embann.c:257:9: note: ------>vectorizing phi: max_3 = PHI <max_11(11), max_26(21)>
embann.c:257:9: note: transform phi.
embann.c:257:9: note: ------>vectorizing phi: j_23 = PHI <j_12(11), 0(21)>
embann.c:257:9: note: ------>vectorizing phi: vect_max_11.274_30 = PHI <(11), (21)>
embann.c:257:9: note: ------>vectorizing statement: _1 = pTrainingData_25->data[j_23];
embann.c:257:9: note: transform statement.
embann.c:257:9: note: transform load. ncopies = 1
embann.c:257:9: note: create vector_type-pointer variable to type: vector(16) unsigned char  vectorizing a record based array ref: *pTrainingData_25
embann.c:257:9: note: created vectp_pTrainingData.276_31
embann.c:257:9: note: add new stmt: vect__1.277_34 = MEM[(uint8_t[0:] *)vectp_pTrainingData.275_32];
embann.c:257:9: note: ------>vectorizing statement: max_11 = MAX_EXPR <_1, max_3>;
embann.c:257:9: note: transform statement.
embann.c:257:9: note: vect_is_simple_use: operand _1
embann.c:257:9: note: def_stmt: _1 = pTrainingData_25->data[j_23];
embann.c:257:9: note: type of def: internal
embann.c:257:9: note: vect_is_simple_use: operand max_3
embann.c:257:9: note: def_stmt: max_3 = PHI <max_11(11), max_26(21)>
embann.c:257:9: note: type of def: reduction
embann.c:257:9: note: reduc op not supported by target.
embann.c:257:9: note: transform reduction.
embann.c:257:9: note: vect_get_vec_def_for_operand: _1
embann.c:257:9: note: vect_is_simple_use: operand _1
embann.c:257:9: note: def_stmt: _1 = pTrainingData_25->data[j_23];
embann.c:257:9: note: type of def: internal
embann.c:257:9: note:   def_stmt =  _1 = pTrainingData_25->data[j_23];
embann.c:257:9: note: vect_get_vec_def_for_operand: max_3
embann.c:257:9: note: vect_is_simple_use: operand max_3
embann.c:257:9: note: def_stmt: max_3 = PHI <max_11(11), max_26(21)>
embann.c:257:9: note: type of def: reduction
embann.c:257:9: note:   def_stmt =  max_3 = PHI <max_11(11), max_26(21)>
embann.c:257:9: note: add new stmt: vect_max_11.278_35 = MAX_EXPR <vect__1.277_34, vect_max_11.274_30>;
embann.c:257:9: note: vect_is_simple_use: operand max_26
embann.c:257:9: note: def_stmt: max_26 = PHI <max_10(3), max_24(10)>
embann.c:257:9: note: type of def: external
embann.c:257:9: note: vect_get_vec_def_for_operand: max_26
embann.c:257:9: note: vect_is_simple_use: operand max_26
embann.c:257:9: note: def_stmt: max_26 = PHI <max_10(3), max_24(10)>
embann.c:257:9: note: type of def: external
embann.c:257:9: note:   def_stmt =  max_26 = PHI <max_10(3), max_24(10)>
embann.c:257:9: note: created new init_stmt: vect_cst__36 = {max_26, max_26, max_26, max_26, max_26, max_26, max_26, max_26, max_26, max_26, max_26, max_26, max_26, max_26, max_26, max_26};
embann.c:257:9: note: transform reduction: created def-use cycle: vect_max_11.274_30 = PHI <vect_max_11.278_35(11), vect_cst__36(21)>
vect_max_11.278_35 = MAX_EXPR <vect__1.277_34, vect_max_11.274_30>;
embann.c:257:9: note: Reduce using vector shifts
embann.c:257:9: note: extract scalar result
embann.c:257:9: note: ------>vectorizing statement: j_12 = j_23 + 1;
embann.c:257:9: note: ------>vectorizing statement: vectp_pTrainingData.275_33 = vectp_pTrainingData.275_32 + 16;
embann.c:257:9: note: ------>vectorizing statement: if (_6 > j_12)
embann.c:257:9: note: New loop exit condition: if (ivtmp_48 < bnd.271_22)
embann.c:257:9: note: LOOP VECTORIZED

embann.c:241:9: note: vectorized 1 loops in function.
embann.c:257:9: note: loop with 14 iterations completely unrolled (header execution count 19408839)
embann.c:241:9: note: ===vect_slp_analyze_bb===
embann.c:245:8: note: === vect_analyze_data_refs ===
embann.c:245:8: note: got vectype for stmt: pTrainingData_9 = trainingDataCollection.head;
vector(2) long unsigned int
embann.c:245:8: note: not vectorized: not enough data-refs in basic block.
embann.c:245:8: note: ===vect_slp_analyze_bb===
embann.c:247:13: note: === vect_analyze_data_refs ===
embann.c:247:13: note: got vectype for stmt: max_10 = pTrainingData_9->data[0];
vector(16) unsigned char
embann.c:247:13: note: not vectorized: not enough data-refs in basic block.
embann.c:247:13: note: ===vect_slp_analyze_bb===
embann.c:251:9: note: ===vect_slp_analyze_bb===
embann.c:251:9: note: === vect_analyze_data_refs ===
embann.c:251:9: note: not vectorized: not enough data-refs in basic block.
embann.c:251:9: note: ===vect_slp_analyze_bb===
embann.c:251:9: note: === vect_analyze_data_refs ===
embann.c:251:9: note: not vectorized: not enough data-refs in basic block.
embann.c:251:9: note: ===vect_slp_analyze_bb===
embann.c:259:36: note: === vect_analyze_data_refs ===
embann.c:259:36: note: not vectorized: no vectype for stmt: vect__1.277_34 = MEM[(uint8_t[0:] *)vectp_pTrainingData.275_32];
 scalar_type: vector(16) unsigned char
embann.c:259:36: note: not vectorized: not enough data-refs in basic block.
embann.c:259:36: note: ===vect_slp_analyze_bb===
embann.c:259:36: note: ===vect_slp_analyze_bb===
embann.c:259:36: note: === vect_analyze_data_refs ===
embann.c:259:36: note: not vectorized: not enough data-refs in basic block.
embann.c:259:36: note: ===vect_slp_analyze_bb===
embann.c:257:9: note: === vect_analyze_data_refs ===
embann.c:257:9: note: got vectype for stmt: _3 = pTrainingData_25->data[j_21];
vector(16) unsigned char
embann.c:257:9: note: not vectorized: not enough data-refs in basic block.
embann.c:257:9: note: ===vect_slp_analyze_bb===
embann.c:257:9: note: === vect_analyze_data_refs ===
embann.c:257:9: note: got vectype for stmt: _49 = pTrainingData_25->data[j_18];
vector(16) unsigned char
embann.c:257:9: note: not vectorized: not enough data-refs in basic block.
embann.c:257:9: note: ===vect_slp_analyze_bb===
embann.c:257:9: note: === vect_analyze_data_refs ===
embann.c:257:9: note: got vectype for stmt: _54 = pTrainingData_25->data[j_53];
vector(16) unsigned char
embann.c:257:9: note: not vectorized: not enough data-refs in basic block.
embann.c:257:9: note: ===vect_slp_analyze_bb===
embann.c:257:9: note: === vect_analyze_data_refs ===
embann.c:257:9: note: got vectype for stmt: _59 = pTrainingData_25->data[j_58];
vector(16) unsigned char
embann.c:257:9: note: not vectorized: not enough data-refs in basic block.
embann.c:257:9: note: ===vect_slp_analyze_bb===
embann.c:257:9: note: === vect_analyze_data_refs ===
embann.c:257:9: note: got vectype for stmt: _64 = pTrainingData_25->data[j_63];
vector(16) unsigned char
embann.c:257:9: note: not vectorized: not enough data-refs in basic block.
embann.c:257:9: note: ===vect_slp_analyze_bb===
embann.c:257:9: note: === vect_analyze_data_refs ===
embann.c:257:9: note: got vectype for stmt: _69 = pTrainingData_25->data[j_68];
vector(16) unsigned char
embann.c:257:9: note: not vectorized: not enough data-refs in basic block.
embann.c:257:9: note: ===vect_slp_analyze_bb===
embann.c:257:9: note: === vect_analyze_data_refs ===
embann.c:257:9: note: got vectype for stmt: _74 = pTrainingData_25->data[j_73];
vector(16) unsigned char
embann.c:257:9: note: not vectorized: not enough data-refs in basic block.
embann.c:257:9: note: ===vect_slp_analyze_bb===
embann.c:257:9: note: === vect_analyze_data_refs ===
embann.c:257:9: note: got vectype for stmt: _79 = pTrainingData_25->data[j_78];
vector(16) unsigned char
embann.c:257:9: note: not vectorized: not enough data-refs in basic block.
embann.c:257:9: note: ===vect_slp_analyze_bb===
embann.c:257:9: note: === vect_analyze_data_refs ===
embann.c:257:9: note: got vectype for stmt: _84 = pTrainingData_25->data[j_83];
vector(16) unsigned char
embann.c:257:9: note: not vectorized: not enough data-refs in basic block.
embann.c:257:9: note: ===vect_slp_analyze_bb===
embann.c:257:9: note: === vect_analyze_data_refs ===
embann.c:257:9: note: got vectype for stmt: _89 = pTrainingData_25->data[j_88];
vector(16) unsigned char
embann.c:257:9: note: not vectorized: not enough data-refs in basic block.
embann.c:257:9: note: ===vect_slp_analyze_bb===
embann.c:257:9: note: === vect_analyze_data_refs ===
embann.c:257:9: note: got vectype for stmt: _94 = pTrainingData_25->data[j_93];
vector(16) unsigned char
embann.c:257:9: note: not vectorized: not enough data-refs in basic block.
embann.c:257:9: note: ===vect_slp_analyze_bb===
embann.c:257:9: note: === vect_analyze_data_refs ===
embann.c:257:9: note: got vectype for stmt: _99 = pTrainingData_25->data[j_98];
vector(16) unsigned char
embann.c:257:9: note: not vectorized: not enough data-refs in basic block.
embann.c:257:9: note: ===vect_slp_analyze_bb===
embann.c:257:9: note: === vect_analyze_data_refs ===
embann.c:257:9: note: got vectype for stmt: _104 = pTrainingData_25->data[j_103];
vector(16) unsigned char
embann.c:257:9: note: not vectorized: not enough data-refs in basic block.
embann.c:257:9: note: ===vect_slp_analyze_bb===
embann.c:257:9: note: === vect_analyze_data_refs ===
embann.c:257:9: note: got vectype for stmt: _109 = pTrainingData_25->data[j_108];
vector(16) unsigned char
embann.c:257:9: note: not vectorized: not enough data-refs in basic block.
embann.c:257:9: note: ===vect_slp_analyze_bb===
embann.c:257:58: note: === vect_analyze_data_refs ===
embann.c:257:58: note: got vectype for stmt: _2 = pTrainingData_25->data[j_4];
vector(16) unsigned char
embann.c:257:58: note: not vectorized: not enough data-refs in basic block.
embann.c:257:58: note: ===vect_slp_analyze_bb===
embann.c:257:58: note: ===vect_slp_analyze_bb===
embann.c:255:11: note: === vect_analyze_data_refs ===
embann.c:255:11: note: got vectype for stmt: pTrainingData_13 = pTrainingData_25->next;
vector(2) long unsigned int
embann.c:255:11: note: not vectorized: not enough data-refs in basic block.
embann.c:255:11: note: ===vect_slp_analyze_bb===
embann.c:255:11: note: ===vect_slp_analyze_bb===
embann.c:257:9: note: === vect_analyze_data_refs ===
embann.c:257:9: note: got vectype for stmt: _6 = pTrainingData_25->length;
vector(4) unsigned int
embann.c:257:9: note: not vectorized: not enough data-refs in basic block.
embann.c:257:9: note: ===vect_slp_analyze_bb===
embann.c:267:12: note: === vect_analyze_data_refs ===
embann.c:267:12: note: not vectorized: not enough data-refs in basic block.

Analyzing loop at embann.c:283
embann.c:283:11: note: ===== analyze_loop_nest =====
embann.c:283:11: note: === vect_analyze_loop_form ===
embann.c:283:11: note: not vectorized: control flow in loop.
embann.c:283:11: note: bad loop form.

Analyzing loop at embann.c:285
embann.c:285:9: note: ===== analyze_loop_nest =====
embann.c:285:9: note: === vect_analyze_loop_form ===
embann.c:285:9: note: === get_loop_niters ===
embann.c:285:9: note: Symbolic number of iterations is _6
embann.c:285:9: note: === vect_analyze_data_refs ===
embann.c:285:9: note: got vectype for stmt: _1 = pTrainingData_25->data[j_23];
vector(16) unsigned char
embann.c:285:9: note: === vect_analyze_scalar_cycles ===
embann.c:285:9: note: Analyze phi: min_3 = PHI <min_26(9), min_11(11)>
embann.c:285:9: note: Access function of PHI: min_3
embann.c:285:9: note: Analyze phi: j_23 = PHI <0(9), j_12(11)>
embann.c:285:9: note: Access function of PHI: {0, +, 1}_2
embann.c:285:9: note: step: 1,  init: 0
embann.c:285:9: note: Detected induction.
embann.c:285:9: note: Analyze phi: min_3 = PHI <min_26(9), min_11(11)>
embann.c:285:9: note: detected reduction: min_11 = MIN_EXPR <_1, min_3>;
embann.c:285:9: note: Detected reduction.
embann.c:285:9: note: === vect_pattern_recog ===
embann.c:285:9: note: === vect_analyze_data_ref_accesses ===
embann.c:285:9: note: === vect_mark_stmts_to_be_vectorized ===
embann.c:285:9: note: init: phi relevant? min_3 = PHI <min_26(9), min_11(11)>
embann.c:285:9: note: init: phi relevant? j_23 = PHI <0(9), j_12(11)>
embann.c:285:9: note: init: stmt relevant? _1 = pTrainingData_25->data[j_23];
embann.c:285:9: note: init: stmt relevant? min_11 = MIN_EXPR <_1, min_3>;
embann.c:285:9: note: vec_stmt_relevant_p: used out of loop.
embann.c:285:9: note: vect_is_simple_use: operand _1
embann.c:285:9: note: def_stmt: _1 = pTrainingData_25->data[j_23];
embann.c:285:9: note: type of def: internal
embann.c:285:9: note: vec_stmt_relevant_p: stmt live but not relevant.
embann.c:285:9: note: mark relevant 1, live 1: min_11 = MIN_EXPR <_1, min_3>;
embann.c:285:9: note: init: stmt relevant? j_12 = j_23 + 1;
embann.c:285:9: note: init: stmt relevant? if (_6 > j_12)
embann.c:285:9: note: worklist: examine stmt: min_11 = MIN_EXPR <_1, min_3>;
embann.c:285:9: note: vect_is_simple_use: operand _1
embann.c:285:9: note: def_stmt: _1 = pTrainingData_25->data[j_23];
embann.c:285:9: note: type of def: internal
embann.c:285:9: note: mark relevant 1, live 0: _1 = pTrainingData_25->data[j_23];
embann.c:285:9: note: vect_is_simple_use: operand min_3
embann.c:285:9: note: def_stmt: min_3 = PHI <min_26(9), min_11(11)>
embann.c:285:9: note: type of def: reduction
embann.c:285:9: note: mark relevant 1, live 0: min_3 = PHI <min_26(9), min_11(11)>
embann.c:285:9: note: worklist: examine stmt: min_3 = PHI <min_26(9), min_11(11)>
embann.c:285:9: note: vect_is_simple_use: operand min_26
embann.c:285:9: note: def_stmt: min_26 = PHI <min_10(3), min_24(10)>
embann.c:285:9: note: type of def: external
embann.c:285:9: note: def_stmt is out of loop.
embann.c:285:9: note: vect_is_simple_use: operand min_11
embann.c:285:9: note: def_stmt: min_11 = MIN_EXPR <_1, min_3>;
embann.c:285:9: note: type of def: reduction
embann.c:285:9: note: reduc-stmt defining reduc-phi in the same nest.
embann.c:285:9: note: worklist: examine stmt: _1 = pTrainingData_25->data[j_23];
embann.c:285:9: note: === vect_analyze_data_ref_dependences ===
embann.c:285:9: note: === vect_determine_vectorization_factor ===
embann.c:285:9: note: ==> examining phi: min_3 = PHI <min_26(9), min_11(11)>
embann.c:285:9: note: get vectype for scalar type:  uint8_t
embann.c:285:9: note: vectype: vector(16) unsigned char
embann.c:285:9: note: nunits = 16
embann.c:285:9: note: ==> examining phi: j_23 = PHI <0(9), j_12(11)>
embann.c:285:9: note: ==> examining statement: _1 = pTrainingData_25->data[j_23];
embann.c:285:9: note: get vectype for scalar type:  unsigned char
embann.c:285:9: note: vectype: vector(16) unsigned char
embann.c:285:9: note: nunits = 16
embann.c:285:9: note: ==> examining statement: min_11 = MIN_EXPR <_1, min_3>;
embann.c:285:9: note: get vectype for scalar type:  uint8_t
embann.c:285:9: note: vectype: vector(16) unsigned char
embann.c:285:9: note: get vectype for scalar type:  uint8_t
embann.c:285:9: note: vectype: vector(16) unsigned char
embann.c:285:9: note: nunits = 16
embann.c:285:9: note: ==> examining statement: j_12 = j_23 + 1;
embann.c:285:9: note: skip.
embann.c:285:9: note: ==> examining statement: if (_6 > j_12)
embann.c:285:9: note: skip.
embann.c:285:9: note: vectorization factor = 16
embann.c:285:9: note: === vect_analyze_slp ===
embann.c:285:9: note: === vect_make_slp_decision ===
embann.c:285:9: note: === vect_analyze_data_refs_alignment ===
embann.c:285:9: note: recording new base alignment for pTrainingData_25
embann.c:285:9: note:   alignment:    8
embann.c:285:9: note:   misalignment: 0
embann.c:285:9: note:   based on:     _1 = pTrainingData_25->data[j_23];
embann.c:285:9: note: vect_compute_data_ref_alignment:
embann.c:285:9: note: can't force alignment of ref: pTrainingData_25->data[j_23]
embann.c:285:9: note: === vect_prune_runtime_alias_test_list ===
embann.c:285:9: note: === vect_enhance_data_refs_alignment ===
embann.c:285:9: note: Unknown misalignment, naturally aligned
embann.c:285:9: note: vect_can_advance_ivs_p:
embann.c:285:9: note: Analyze phi: min_3 = PHI <min_26(9), min_11(11)>
embann.c:285:9: note: reduc or virtual phi. skip.
embann.c:285:9: note: Analyze phi: j_23 = PHI <0(9), j_12(11)>
embann.c:285:9: note: vect_model_load_cost: aligned.
embann.c:285:9: note: vect_get_data_access_cost: inside_cost = 12, outside_cost = 0.
embann.c:285:9: note: cost model: epilogue peel iters set to vf/2 because loop iterations are unknown .
embann.c:285:9: note: vect_model_load_cost: unaligned supported by hardware.
embann.c:285:9: note: vect_get_data_access_cost: inside_cost = 12, outside_cost = 0.
embann.c:285:9: note: cost model: epilogue peel iters set to vf/2 because loop iterations are unknown .
embann.c:285:9: note: Vectorizing an unaligned access.
embann.c:285:9: note: === vect_analyze_loop_operations ===
embann.c:285:9: note: examining phi: min_3 = PHI <min_26(9), min_11(11)>
embann.c:285:9: note: examining phi: j_23 = PHI <0(9), j_12(11)>
embann.c:285:9: note: ==> examining statement: _1 = pTrainingData_25->data[j_23];
embann.c:285:9: note: num. args = 4 (not unary/binary/ternary op).
embann.c:285:9: note: vect_is_simple_use: operand pTrainingData_25->data[j_23]
embann.c:285:9: note: not ssa-name.
embann.c:285:9: note: use not simple.
embann.c:285:9: note: can't use a fully-masked loop because the target doesn't have the appropriate masked load or store.
embann.c:285:9: note: vect_model_load_cost: unaligned supported by hardware.
embann.c:285:9: note: vect_model_load_cost: inside_cost = 12, prologue_cost = 0 .
embann.c:285:9: note: ==> examining statement: min_11 = MIN_EXPR <_1, min_3>;
embann.c:285:9: note: vect_is_simple_use: operand _1
embann.c:285:9: note: def_stmt: _1 = pTrainingData_25->data[j_23];
embann.c:285:9: note: type of def: internal
embann.c:285:9: note: vect_is_simple_use: operand min_3
embann.c:285:9: note: def_stmt: min_3 = PHI <min_26(9), min_11(11)>
embann.c:285:9: note: type of def: reduction
embann.c:285:9: note: reduc op not supported by target.
vect_model_reduction_cost: inside_cost = 4, prologue_cost = 4, epilogue_cost = 36 .
embann.c:285:9: note: ==> examining statement: j_12 = j_23 + 1;
embann.c:285:9: note: irrelevant.
embann.c:285:9: note: ==> examining statement: if (_6 > j_12)
embann.c:285:9: note: irrelevant.
embann.c:285:9: note: not using a fully-masked loop.
embann.c:285:9: note: cost model: epilogue peel iters set to vf/2 because loop iterations are unknown .
embann.c:285:9: note: Cost model analysis: 
  Vector inside of loop cost: 16
  Vector prologue cost: 36
  Vector epilogue cost: 164
  Scalar iteration cost: 16
  Scalar outside cost: 32
  Vector outside cost: 200
  prologue iterations: 0
  epilogue iterations: 8
  Calculated minimum iters for profitability: 11
embann.c:285:9: note:   Runtime profitability threshold = 16
embann.c:285:9: note:   Static estimate profitability threshold = 16
embann.c:285:9: note: epilog loop required
embann.c:285:9: note: vect_can_advance_ivs_p:
embann.c:285:9: note: Analyze phi: min_3 = PHI <min_26(9), min_11(11)>
embann.c:285:9: note: reduc or virtual phi. skip.
embann.c:285:9: note: Analyze phi: j_23 = PHI <0(9), j_12(11)>
embann.c:285:9: note: loop vectorized
embann.c:285:9: note: === vec_transform_loop ===
embann.c:285:9: note: Profitability threshold is 16 loop iterations.
embann.c:285:9: note: vect_update_ivs_after_vectorizer: phi: min_3 = PHI <min_11(11), min_26(14)>
embann.c:285:9: note: reduc or virtual phi. skip.
embann.c:285:9: note: vect_update_ivs_after_vectorizer: phi: j_23 = PHI <j_12(11), 0(14)>
embann.c:285:9: note: ------>vectorizing phi: min_3 = PHI <min_11(11), min_26(21)>
embann.c:285:9: note: transform phi.
embann.c:285:9: note: ------>vectorizing phi: j_23 = PHI <j_12(11), 0(21)>
embann.c:285:9: note: ------>vectorizing phi: vect_min_11.292_30 = PHI <(11), (21)>
embann.c:285:9: note: ------>vectorizing statement: _1 = pTrainingData_25->data[j_23];
embann.c:285:9: note: transform statement.
embann.c:285:9: note: transform load. ncopies = 1
embann.c:285:9: note: create vector_type-pointer variable to type: vector(16) unsigned char  vectorizing a record based array ref: *pTrainingData_25
embann.c:285:9: note: created vectp_pTrainingData.294_31
embann.c:285:9: note: add new stmt: vect__1.295_34 = MEM[(uint8_t[0:] *)vectp_pTrainingData.293_32];
embann.c:285:9: note: ------>vectorizing statement: min_11 = MIN_EXPR <_1, min_3>;
embann.c:285:9: note: transform statement.
embann.c:285:9: note: vect_is_simple_use: operand _1
embann.c:285:9: note: def_stmt: _1 = pTrainingData_25->data[j_23];
embann.c:285:9: note: type of def: internal
embann.c:285:9: note: vect_is_simple_use: operand min_3
embann.c:285:9: note: def_stmt: min_3 = PHI <min_11(11), min_26(21)>
embann.c:285:9: note: type of def: reduction
embann.c:285:9: note: reduc op not supported by target.
embann.c:285:9: note: transform reduction.
embann.c:285:9: note: vect_get_vec_def_for_operand: _1
embann.c:285:9: note: vect_is_simple_use: operand _1
embann.c:285:9: note: def_stmt: _1 = pTrainingData_25->data[j_23];
embann.c:285:9: note: type of def: internal
embann.c:285:9: note:   def_stmt =  _1 = pTrainingData_25->data[j_23];
embann.c:285:9: note: vect_get_vec_def_for_operand: min_3
embann.c:285:9: note: vect_is_simple_use: operand min_3
embann.c:285:9: note: def_stmt: min_3 = PHI <min_11(11), min_26(21)>
embann.c:285:9: note: type of def: reduction
embann.c:285:9: note:   def_stmt =  min_3 = PHI <min_11(11), min_26(21)>
embann.c:285:9: note: add new stmt: vect_min_11.296_35 = MIN_EXPR <vect__1.295_34, vect_min_11.292_30>;
embann.c:285:9: note: vect_is_simple_use: operand min_26
embann.c:285:9: note: def_stmt: min_26 = PHI <min_10(3), min_24(10)>
embann.c:285:9: note: type of def: external
embann.c:285:9: note: vect_get_vec_def_for_operand: min_26
embann.c:285:9: note: vect_is_simple_use: operand min_26
embann.c:285:9: note: def_stmt: min_26 = PHI <min_10(3), min_24(10)>
embann.c:285:9: note: type of def: external
embann.c:285:9: note:   def_stmt =  min_26 = PHI <min_10(3), min_24(10)>
embann.c:285:9: note: created new init_stmt: vect_cst__36 = {min_26, min_26, min_26, min_26, min_26, min_26, min_26, min_26, min_26, min_26, min_26, min_26, min_26, min_26, min_26, min_26};
embann.c:285:9: note: transform reduction: created def-use cycle: vect_min_11.292_30 = PHI <vect_min_11.296_35(11), vect_cst__36(21)>
vect_min_11.296_35 = MIN_EXPR <vect__1.295_34, vect_min_11.292_30>;
embann.c:285:9: note: Reduce using vector shifts
embann.c:285:9: note: extract scalar result
embann.c:285:9: note: ------>vectorizing statement: j_12 = j_23 + 1;
embann.c:285:9: note: ------>vectorizing statement: vectp_pTrainingData.293_33 = vectp_pTrainingData.293_32 + 16;
embann.c:285:9: note: ------>vectorizing statement: if (_6 > j_12)
embann.c:285:9: note: New loop exit condition: if (ivtmp_48 < bnd.289_22)
embann.c:285:9: note: LOOP VECTORIZED

embann.c:270:9: note: vectorized 1 loops in function.
embann.c:285:9: note: loop with 14 iterations completely unrolled (header execution count 19408839)
embann.c:270:9: note: ===vect_slp_analyze_bb===
embann.c:274:8: note: === vect_analyze_data_refs ===
embann.c:274:8: note: got vectype for stmt: pTrainingData_9 = trainingDataCollection.head;
vector(2) long unsigned int
embann.c:274:8: note: not vectorized: not enough data-refs in basic block.
embann.c:274:8: note: ===vect_slp_analyze_bb===
embann.c:276:13: note: === vect_analyze_data_refs ===
embann.c:276:13: note: got vectype for stmt: min_10 = pTrainingData_9->data[0];
vector(16) unsigned char
embann.c:276:13: note: not vectorized: not enough data-refs in basic block.
embann.c:276:13: note: ===vect_slp_analyze_bb===
embann.c:280:9: note: ===vect_slp_analyze_bb===
embann.c:280:9: note: === vect_analyze_data_refs ===
embann.c:280:9: note: not vectorized: not enough data-refs in basic block.
embann.c:280:9: note: ===vect_slp_analyze_bb===
embann.c:280:9: note: === vect_analyze_data_refs ===
embann.c:280:9: note: not vectorized: not enough data-refs in basic block.
embann.c:280:9: note: ===vect_slp_analyze_bb===
embann.c:287:36: note: === vect_analyze_data_refs ===
embann.c:287:36: note: not vectorized: no vectype for stmt: vect__1.295_34 = MEM[(uint8_t[0:] *)vectp_pTrainingData.293_32];
 scalar_type: vector(16) unsigned char
embann.c:287:36: note: not vectorized: not enough data-refs in basic block.
embann.c:287:36: note: ===vect_slp_analyze_bb===
embann.c:287:36: note: ===vect_slp_analyze_bb===
embann.c:287:36: note: === vect_analyze_data_refs ===
embann.c:287:36: note: not vectorized: not enough data-refs in basic block.
embann.c:287:36: note: ===vect_slp_analyze_bb===
embann.c:285:9: note: === vect_analyze_data_refs ===
embann.c:285:9: note: got vectype for stmt: _3 = pTrainingData_25->data[j_21];
vector(16) unsigned char
embann.c:285:9: note: not vectorized: not enough data-refs in basic block.
embann.c:285:9: note: ===vect_slp_analyze_bb===
embann.c:285:9: note: === vect_analyze_data_refs ===
embann.c:285:9: note: got vectype for stmt: _49 = pTrainingData_25->data[j_18];
vector(16) unsigned char
embann.c:285:9: note: not vectorized: not enough data-refs in basic block.
embann.c:285:9: note: ===vect_slp_analyze_bb===
embann.c:285:9: note: === vect_analyze_data_refs ===
embann.c:285:9: note: got vectype for stmt: _54 = pTrainingData_25->data[j_53];
vector(16) unsigned char
embann.c:285:9: note: not vectorized: not enough data-refs in basic block.
embann.c:285:9: note: ===vect_slp_analyze_bb===
embann.c:285:9: note: === vect_analyze_data_refs ===
embann.c:285:9: note: got vectype for stmt: _59 = pTrainingData_25->data[j_58];
vector(16) unsigned char
embann.c:285:9: note: not vectorized: not enough data-refs in basic block.
embann.c:285:9: note: ===vect_slp_analyze_bb===
embann.c:285:9: note: === vect_analyze_data_refs ===
embann.c:285:9: note: got vectype for stmt: _64 = pTrainingData_25->data[j_63];
vector(16) unsigned char
embann.c:285:9: note: not vectorized: not enough data-refs in basic block.
embann.c:285:9: note: ===vect_slp_analyze_bb===
embann.c:285:9: note: === vect_analyze_data_refs ===
embann.c:285:9: note: got vectype for stmt: _69 = pTrainingData_25->data[j_68];
vector(16) unsigned char
embann.c:285:9: note: not vectorized: not enough data-refs in basic block.
embann.c:285:9: note: ===vect_slp_analyze_bb===
embann.c:285:9: note: === vect_analyze_data_refs ===
embann.c:285:9: note: got vectype for stmt: _74 = pTrainingData_25->data[j_73];
vector(16) unsigned char
embann.c:285:9: note: not vectorized: not enough data-refs in basic block.
embann.c:285:9: note: ===vect_slp_analyze_bb===
embann.c:285:9: note: === vect_analyze_data_refs ===
embann.c:285:9: note: got vectype for stmt: _79 = pTrainingData_25->data[j_78];
vector(16) unsigned char
embann.c:285:9: note: not vectorized: not enough data-refs in basic block.
embann.c:285:9: note: ===vect_slp_analyze_bb===
embann.c:285:9: note: === vect_analyze_data_refs ===
embann.c:285:9: note: got vectype for stmt: _84 = pTrainingData_25->data[j_83];
vector(16) unsigned char
embann.c:285:9: note: not vectorized: not enough data-refs in basic block.
embann.c:285:9: note: ===vect_slp_analyze_bb===
embann.c:285:9: note: === vect_analyze_data_refs ===
embann.c:285:9: note: got vectype for stmt: _89 = pTrainingData_25->data[j_88];
vector(16) unsigned char
embann.c:285:9: note: not vectorized: not enough data-refs in basic block.
embann.c:285:9: note: ===vect_slp_analyze_bb===
embann.c:285:9: note: === vect_analyze_data_refs ===
embann.c:285:9: note: got vectype for stmt: _94 = pTrainingData_25->data[j_93];
vector(16) unsigned char
embann.c:285:9: note: not vectorized: not enough data-refs in basic block.
embann.c:285:9: note: ===vect_slp_analyze_bb===
embann.c:285:9: note: === vect_analyze_data_refs ===
embann.c:285:9: note: got vectype for stmt: _99 = pTrainingData_25->data[j_98];
vector(16) unsigned char
embann.c:285:9: note: not vectorized: not enough data-refs in basic block.
embann.c:285:9: note: ===vect_slp_analyze_bb===
embann.c:285:9: note: === vect_analyze_data_refs ===
embann.c:285:9: note: got vectype for stmt: _104 = pTrainingData_25->data[j_103];
vector(16) unsigned char
embann.c:285:9: note: not vectorized: not enough data-refs in basic block.
embann.c:285:9: note: ===vect_slp_analyze_bb===
embann.c:285:9: note: === vect_analyze_data_refs ===
embann.c:285:9: note: got vectype for stmt: _109 = pTrainingData_25->data[j_108];
vector(16) unsigned char
embann.c:285:9: note: not vectorized: not enough data-refs in basic block.
embann.c:285:9: note: ===vect_slp_analyze_bb===
embann.c:285:58: note: === vect_analyze_data_refs ===
embann.c:285:58: note: got vectype for stmt: _2 = pTrainingData_25->data[j_4];
vector(16) unsigned char
embann.c:285:58: note: not vectorized: not enough data-refs in basic block.
embann.c:285:58: note: ===vect_slp_analyze_bb===
embann.c:285:58: note: ===vect_slp_analyze_bb===
embann.c:283:11: note: === vect_analyze_data_refs ===
embann.c:283:11: note: got vectype for stmt: pTrainingData_13 = pTrainingData_25->next;
vector(2) long unsigned int
embann.c:283:11: note: not vectorized: not enough data-refs in basic block.
embann.c:283:11: note: ===vect_slp_analyze_bb===
embann.c:283:11: note: ===vect_slp_analyze_bb===
embann.c:285:9: note: === vect_analyze_data_refs ===
embann.c:285:9: note: got vectype for stmt: _6 = pTrainingData_25->length;
vector(4) unsigned int
embann.c:285:9: note: not vectorized: not enough data-refs in basic block.
embann.c:285:9: note: ===vect_slp_analyze_bb===
embann.c:295:12: note: === vect_analyze_data_refs ===
embann.c:295:12: note: not vectorized: not enough data-refs in basic block.

Analyzing loop at embann.c:572
embann.c:572:5: note: ===== analyze_loop_nest =====
embann.c:572:5: note: === vect_analyze_loop_form ===
embann.c:572:5: note: === get_loop_niters ===
embann.c:572:5: note: Symbolic number of iterations is _22
embann.c:572:5: note: === vect_analyze_data_refs ===
embann.c:572:5: note: got vectype for stmt: _42 = network.25_1->outputLayer.neuron[_40];
vector(2) long unsigned int
embann.c:572:5: note: got vectype for stmt: _45 = network.25_1->outputLayer.neuron[_44];
vector(2) long unsigned int
embann.c:572:5: note: not vectorized: not suitable for gather load _45 = network.25_1->outputLayer.neuron[_44];
embann.c:572:5: note: bad data references.
embann.c:572:5: note: ===vect_slp_analyze_bb===
embann.c:572:5: note: === vect_analyze_data_refs ===
embann.c:572:5: note: got vectype for stmt: _42 = network.25_1->outputLayer.neuron[_40];
vector(2) long unsigned int
embann.c:572:5: note: got vectype for stmt: _45 = network.25_1->outputLayer.neuron[_44];
vector(2) long unsigned int
embann.c:572:5: note: === vect_analyze_data_ref_accesses ===
embann.c:572:5: note: not consecutive access _42 = network.25_1->outputLayer.neuron[_40];
embann.c:572:5: note: not consecutive access _45 = network.25_1->outputLayer.neuron[_44];
embann.c:572:5: note: not vectorized: no grouped stores in basic block.

Analyzing loop at embann.c:331
embann.c:331:5: note: ===== analyze_loop_nest =====
embann.c:331:5: note: === vect_analyze_loop_form ===
embann.c:331:5: note: not vectorized: control flow in loop.
embann.c:331:5: note: bad loop form.

Analyzing loop at embann.c:334
embann.c:334:9: note: ===== analyze_loop_nest =====
embann.c:334:9: note: === vect_analyze_loop_form ===
embann.c:334:9: note: === get_loop_niters ===
embann.c:334:9: note: Symbolic number of iterations is _26
embann.c:334:9: note: === vect_analyze_data_refs ===
embann.c:334:9: note: got vectype for stmt: _114 = *_113;
vector(2) long unsigned int
embann.c:334:9: note: got vectype for stmt: _115 = _114->activation;
vector(4) float
embann.c:334:9: note: not vectorized: not suitable for gather load _115 = _114->activation;
embann.c:334:9: note: bad data references.

Analyzing loop at embann.c:306
embann.c:306:5: note: ===== analyze_loop_nest =====
embann.c:306:5: note: === vect_analyze_loop_form ===
embann.c:306:5: note: not vectorized: multiple nested loops.
embann.c:306:5: note: bad loop form.

Analyzing loop at embann.c:331
embann.c:331:5: note: ===== analyze_loop_nest =====
embann.c:331:5: note: === vect_analyze_loop_form ===
embann.c:331:5: note: not vectorized: control flow in loop.
embann.c:331:5: note: bad loop form.

Analyzing loop at embann.c:334
embann.c:334:9: note: ===== analyze_loop_nest =====
embann.c:334:9: note: === vect_analyze_loop_form ===
embann.c:334:9: note: === get_loop_niters ===
embann.c:334:9: note: Symbolic number of iterations is _15
embann.c:334:9: note: === vect_analyze_data_refs ===
embann.c:334:9: note: got vectype for stmt: _88 = *_87;
vector(2) long unsigned int
embann.c:334:9: note: got vectype for stmt: _89 = _88->activation;
vector(4) float
embann.c:334:9: note: not vectorized: not suitable for gather load _89 = _88->activation;
embann.c:334:9: note: bad data references.

Analyzing loop at embann.c:331
embann.c:331:5: note: ===== analyze_loop_nest =====
embann.c:331:5: note: === vect_analyze_loop_form ===
embann.c:331:5: note: not vectorized: control flow in loop.
embann.c:331:5: note: bad loop form.

Analyzing loop at embann.c:334
embann.c:334:9: note: ===== analyze_loop_nest =====
embann.c:334:9: note: === vect_analyze_loop_form ===
embann.c:334:9: note: === get_loop_niters ===
embann.c:334:9: note: Symbolic number of iterations is _5
embann.c:334:9: note: === vect_analyze_data_refs ===
embann.c:334:9: note: got vectype for stmt: _62 = *_61;
vector(2) long unsigned int
embann.c:334:9: note: got vectype for stmt: _63 = _62->activation;
vector(4) float
embann.c:334:9: note: not vectorized: not suitable for gather load _63 = _62->activation;
embann.c:334:9: note: bad data references.
embann.c:299:9: note: vectorized 0 loops in function.
embann.c:299:9: note: ===vect_slp_analyze_bb===
embann.c:331:5: note: === vect_analyze_data_refs ===
embann.c:331:5: note: got vectype for stmt: network.25_1 = network;
vector(2) long unsigned int
embann.c:331:5: note: got vectype for stmt: _2 = network.25_1->hiddenLayer[0].numNeurons;
vector(8) short unsigned int
embann.c:331:5: note: got vectype for stmt: _5 = network.25_1->inputLayer.numNeurons;
vector(8) short unsigned int
embann.c:331:5: note: === vect_analyze_data_ref_accesses ===
embann.c:331:5: note: Detected interleaving load network.25_1->inputLayer.numNeurons and network.25_1->hiddenLayer[0].numNeurons
embann.c:331:5: note: not consecutive access network.25_1 = network;
embann.c:331:5: note: Detected interleaving load of size 9 starting with _5 = network.25_1->inputLayer.numNeurons;
embann.c:331:5: note: not vectorized: no grouped stores in basic block.
embann.c:331:5: note: ===vect_slp_analyze_bb===
embann.c:306:5: note: === vect_analyze_data_refs ===
embann.c:306:5: note: got vectype for stmt: _7 = network.25_1->properties.numHiddenLayers;
vector(16) unsigned char
embann.c:306:5: note: not vectorized: not enough data-refs in basic block.
embann.c:306:5: note: ===vect_slp_analyze_bb===
embann.c:306:5: note: ===vect_slp_analyze_bb===
embann.c:334:9: note: === vect_analyze_data_refs ===
embann.c:334:9: note: got vectype for stmt: _56 = *_55;
vector(2) long unsigned int
embann.c:334:9: note: got vectype for stmt: _56->activation = 0.0;
vector(4) float
embann.c:334:9: note: === vect_analyze_data_ref_accesses ===
embann.c:334:9: note: not consecutive access _56 = *_55;
embann.c:334:9: note: not consecutive access _56->activation = 0.0;
embann.c:334:9: note: not vectorized: no grouped stores in basic block.
embann.c:334:9: note: ===vect_slp_analyze_bb===
embann.c:334:9: note: ===vect_slp_analyze_bb===
embann.c:334:9: note: === vect_analyze_data_refs ===
embann.c:334:9: note: got vectype for stmt: _62 = *_61;
vector(2) long unsigned int
embann.c:334:9: note: got vectype for stmt: _63 = _62->activation;
vector(4) float
embann.c:334:9: note: got vectype for stmt: _65 = _56->params[_64];
vector(2) long unsigned int
embann.c:334:9: note: got vectype for stmt: _66 = _65->weight;
vector(4) float
embann.c:334:9: note: got vectype for stmt: _56->activation = _68;
vector(4) float
embann.c:334:9: note: === vect_analyze_data_ref_accesses ===
embann.c:334:9: note: not consecutive access _62 = *_61;
embann.c:334:9: note: not consecutive access _56->activation = _68;
embann.c:334:9: note: not consecutive access _65 = _56->params[_64];
embann.c:334:9: note: not consecutive access _63 = _62->activation;
embann.c:334:9: note: not consecutive access _66 = _65->weight;
embann.c:334:9: note: not vectorized: no grouped stores in basic block.
embann.c:334:9: note: ===vect_slp_analyze_bb===
embann.c:334:9: note: ===vect_slp_analyze_bb===
embann.c:334:9: note: === vect_analyze_data_refs ===
embann.c:334:9: note: not vectorized: not enough data-refs in basic block.
embann.c:334:9: note: ===vect_slp_analyze_bb===
embann.c:331:5: note: === vect_analyze_data_refs ===
embann.c:331:5: note: got vectype for stmt: _56->activation = prephitmp_252;
vector(4) float
embann.c:331:5: note: not vectorized: not enough data-refs in basic block.
embann.c:331:5: note: ===vect_slp_analyze_bb===
embann.c:331:5: note: ===vect_slp_analyze_bb===
embann.c:331:5: note: === vect_analyze_data_refs ===
embann.c:331:5: note: got vectype for stmt: _22 = network.25_1->outputLayer.numNeurons;
vector(8) short unsigned int
embann.c:331:5: note: got vectype for stmt: _26 = network.25_1->hiddenLayer[_25].numNeurons;
vector(8) short unsigned int
embann.c:331:5: note: === vect_analyze_data_ref_accesses ===
embann.c:331:5: note: not consecutive access _22 = network.25_1->outputLayer.numNeurons;
embann.c:331:5: note: not consecutive access _26 = network.25_1->hiddenLayer[_25].numNeurons;
embann.c:331:5: note: not vectorized: no grouped stores in basic block.
embann.c:331:5: note: ===vect_slp_analyze_bb===
embann.c:331:5: note: ===vect_slp_analyze_bb===
embann.c:331:5: note: === vect_analyze_data_refs ===
embann.c:331:5: note: got vectype for stmt: _12 = network.25_1->hiddenLayer[_11].numNeurons;
vector(8) short unsigned int
embann.c:331:5: note: got vectype for stmt: _15 = network.25_1->hiddenLayer[_14].numNeurons;
vector(8) short unsigned int
embann.c:331:5: note: === vect_analyze_data_ref_accesses ===
embann.c:331:5: note: Detected interleaving load network.25_1->hiddenLayer[_14].numNeurons and network.25_1->hiddenLayer[_11].numNeurons
embann.c:331:5: note: Detected interleaving load of size 5 starting with _15 = network.25_1->hiddenLayer[_14].numNeurons;
embann.c:331:5: note: not vectorized: no grouped stores in basic block.
embann.c:331:5: note: ===vect_slp_analyze_bb===
embann.c:306:5: note: === vect_analyze_data_refs ===
embann.c:306:5: note: not vectorized: not enough data-refs in basic block.
embann.c:306:5: note: ===vect_slp_analyze_bb===
embann.c:306:5: note: ===vect_slp_analyze_bb===
embann.c:306:5: note: ===vect_slp_analyze_bb===
embann.c:334:9: note: === vect_analyze_data_refs ===
embann.c:334:9: note: got vectype for stmt: _82 = *_81;
vector(2) long unsigned int
embann.c:334:9: note: got vectype for stmt: _82->activation = 0.0;
vector(4) float
embann.c:334:9: note: === vect_analyze_data_ref_accesses ===
embann.c:334:9: note: not consecutive access _82 = *_81;
embann.c:334:9: note: not consecutive access _82->activation = 0.0;
embann.c:334:9: note: not vectorized: no grouped stores in basic block.
embann.c:334:9: note: ===vect_slp_analyze_bb===
embann.c:334:9: note: ===vect_slp_analyze_bb===
embann.c:334:9: note: === vect_analyze_data_refs ===
embann.c:334:9: note: got vectype for stmt: _88 = *_87;
vector(2) long unsigned int
embann.c:334:9: note: got vectype for stmt: _89 = _88->activation;
vector(4) float
embann.c:334:9: note: got vectype for stmt: _91 = _82->params[_90];
vector(2) long unsigned int
embann.c:334:9: note: got vectype for stmt: _92 = _91->weight;
vector(4) float
embann.c:334:9: note: got vectype for stmt: _82->activation = _94;
vector(4) float
embann.c:334:9: note: === vect_analyze_data_ref_accesses ===
embann.c:334:9: note: not consecutive access _88 = *_87;
embann.c:334:9: note: not consecutive access _82->activation = _94;
embann.c:334:9: note: not consecutive access _91 = _82->params[_90];
embann.c:334:9: note: not consecutive access _89 = _88->activation;
embann.c:334:9: note: not consecutive access _92 = _91->weight;
embann.c:334:9: note: not vectorized: no grouped stores in basic block.
embann.c:334:9: note: ===vect_slp_analyze_bb===
embann.c:334:9: note: ===vect_slp_analyze_bb===
embann.c:334:9: note: === vect_analyze_data_refs ===
embann.c:334:9: note: not vectorized: not enough data-refs in basic block.
embann.c:334:9: note: ===vect_slp_analyze_bb===
embann.c:331:5: note: === vect_analyze_data_refs ===
embann.c:331:5: note: got vectype for stmt: _82->activation = prephitmp_289;
vector(4) float
embann.c:331:5: note: not vectorized: not enough data-refs in basic block.
embann.c:331:5: note: ===vect_slp_analyze_bb===
embann.c:331:5: note: ===vect_slp_analyze_bb===
embann.c:331:5: note: ===vect_slp_analyze_bb===
embann.c:334:9: note: === vect_analyze_data_refs ===
embann.c:334:9: note: got vectype for stmt: _108 = *_107;
vector(2) long unsigned int
embann.c:334:9: note: got vectype for stmt: _108->activation = 0.0;
vector(4) float
embann.c:334:9: note: === vect_analyze_data_ref_accesses ===
embann.c:334:9: note: not consecutive access _108 = *_107;
embann.c:334:9: note: not consecutive access _108->activation = 0.0;
embann.c:334:9: note: not vectorized: no grouped stores in basic block.
embann.c:334:9: note: ===vect_slp_analyze_bb===
embann.c:334:9: note: ===vect_slp_analyze_bb===
embann.c:334:9: note: === vect_analyze_data_refs ===
embann.c:334:9: note: got vectype for stmt: _114 = *_113;
vector(2) long unsigned int
embann.c:334:9: note: got vectype for stmt: _115 = _114->activation;
vector(4) float
embann.c:334:9: note: got vectype for stmt: _117 = _108->params[_116];
vector(2) long unsigned int
embann.c:334:9: note: got vectype for stmt: _118 = _117->weight;
vector(4) float
embann.c:334:9: note: got vectype for stmt: _108->activation = _120;
vector(4) float
embann.c:334:9: note: === vect_analyze_data_ref_accesses ===
embann.c:334:9: note: not consecutive access _114 = *_113;
embann.c:334:9: note: not consecutive access _108->activation = _120;
embann.c:334:9: note: not consecutive access _117 = _108->params[_116];
embann.c:334:9: note: not consecutive access _115 = _114->activation;
embann.c:334:9: note: not consecutive access _118 = _117->weight;
embann.c:334:9: note: not vectorized: no grouped stores in basic block.
embann.c:334:9: note: ===vect_slp_analyze_bb===
embann.c:334:9: note: ===vect_slp_analyze_bb===
embann.c:334:9: note: === vect_analyze_data_refs ===
embann.c:334:9: note: not vectorized: not enough data-refs in basic block.
embann.c:334:9: note: ===vect_slp_analyze_bb===
embann.c:331:5: note: === vect_analyze_data_refs ===
embann.c:331:5: note: got vectype for stmt: _108->activation = prephitmp_313;
vector(4) float
embann.c:331:5: note: not vectorized: not enough data-refs in basic block.
embann.c:331:5: note: ===vect_slp_analyze_bb===
embann.c:331:5: note: ===vect_slp_analyze_bb===
embann.c:331:5: note: ===vect_slp_analyze_bb===
embann.c:574:12: note: === vect_analyze_data_refs ===
embann.c:574:12: note: got vectype for stmt: _295 = network.25_1->outputLayer.neuron[_302];
vector(2) long unsigned int
embann.c:574:12: note: got vectype for stmt: _280 = network.25_1->outputLayer.neuron[_294];
vector(2) long unsigned int
embann.c:574:12: note: === vect_analyze_data_ref_accesses ===
embann.c:574:12: note: not consecutive access _280 = network.25_1->outputLayer.neuron[_294];
embann.c:574:12: note: not consecutive access _295 = network.25_1->outputLayer.neuron[_302];
embann.c:574:12: note: not vectorized: no grouped stores in basic block.
embann.c:574:12: note: ===vect_slp_analyze_bb===
embann.c:577:30: note: === vect_analyze_data_refs ===
embann.c:577:30: note: not vectorized: not enough data-refs in basic block.
embann.c:577:30: note: ===vect_slp_analyze_bb===
embann.c:572:5: note: === vect_analyze_data_refs ===
embann.c:572:5: note: not vectorized: not enough data-refs in basic block.
embann.c:572:5: note: ===vect_slp_analyze_bb===
embann.c:572:5: note: ===vect_slp_analyze_bb===
embann.c:572:5: note: === vect_analyze_data_refs ===
embann.c:572:5: note: not vectorized: not enough data-refs in basic block.
embann.c:572:5: note: ===vect_slp_analyze_bb===
embann.c:325:31: note: === vect_analyze_data_refs ===
embann.c:325:31: note: got vectype for stmt: network.25_1->properties.networkResponse = prephitmp_320;
vector(8) short unsigned int
embann.c:325:31: note: not vectorized: not enough data-refs in basic block.

Analyzing loop at embann.c:331
embann.c:331:5: note: ===== analyze_loop_nest =====
embann.c:331:5: note: === vect_analyze_loop_form ===
embann.c:331:5: note: not vectorized: control flow in loop.
embann.c:331:5: note: bad loop form.

Analyzing loop at embann.c:334
embann.c:334:9: note: ===== analyze_loop_nest =====
embann.c:334:9: note: === vect_analyze_loop_form ===
embann.c:334:9: note: === get_loop_niters ===
embann.c:334:9: note: Symbolic number of iterations is numInputs_29(D)
embann.c:334:9: note: === vect_analyze_data_refs ===
embann.c:334:9: note: got vectype for stmt: _9 = *_8;
vector(2) long unsigned int
embann.c:334:9: note: got vectype for stmt: _10 = _9->activation;
vector(4) float
embann.c:334:9: note: not vectorized: not suitable for gather load _10 = _9->activation;
embann.c:334:9: note: bad data references.
embann.c:328:6: note: vectorized 0 loops in function.
embann.c:328:6: note: ===vect_slp_analyze_bb===
embann.c:331:5: note: === vect_analyze_data_refs ===
embann.c:331:5: note: not vectorized: not enough data-refs in basic block.
embann.c:331:5: note: ===vect_slp_analyze_bb===
embann.c:344:1: note: === vect_analyze_data_refs ===
embann.c:344:1: note: not vectorized: not enough data-refs in basic block.
embann.c:344:1: note: ===vect_slp_analyze_bb===
embann.c:344:1: note: ===vect_slp_analyze_bb===
embann.c:334:9: note: === vect_analyze_data_refs ===
embann.c:334:9: note: got vectype for stmt: _4 = *_3;
vector(2) long unsigned int
embann.c:334:9: note: got vectype for stmt: _4->activation = 0.0;
vector(4) float
embann.c:334:9: note: === vect_analyze_data_ref_accesses ===
embann.c:334:9: note: not consecutive access _4 = *_3;
embann.c:334:9: note: not consecutive access _4->activation = 0.0;
embann.c:334:9: note: not vectorized: no grouped stores in basic block.
embann.c:334:9: note: ===vect_slp_analyze_bb===
embann.c:334:9: note: ===vect_slp_analyze_bb===
embann.c:334:9: note: === vect_analyze_data_refs ===
embann.c:334:9: note: got vectype for stmt: _9 = *_8;
vector(2) long unsigned int
embann.c:334:9: note: got vectype for stmt: _10 = _9->activation;
vector(4) float
embann.c:334:9: note: got vectype for stmt: _12 = _4->params[_11];
vector(2) long unsigned int
embann.c:334:9: note: got vectype for stmt: _13 = _12->weight;
vector(4) float
embann.c:334:9: note: got vectype for stmt: _4->activation = _15;
vector(4) float
embann.c:334:9: note: === vect_analyze_data_ref_accesses ===
embann.c:334:9: note: not consecutive access _9 = *_8;
embann.c:334:9: note: not consecutive access _4->activation = _15;
embann.c:334:9: note: not consecutive access _12 = _4->params[_11];
embann.c:334:9: note: not consecutive access _10 = _9->activation;
embann.c:334:9: note: not consecutive access _13 = _12->weight;
embann.c:334:9: note: not vectorized: no grouped stores in basic block.
embann.c:334:9: note: ===vect_slp_analyze_bb===
embann.c:334:9: note: ===vect_slp_analyze_bb===
embann.c:334:9: note: === vect_analyze_data_refs ===
embann.c:334:9: note: not vectorized: not enough data-refs in basic block.
embann.c:334:9: note: ===vect_slp_analyze_bb===
embann.c:331:5: note: === vect_analyze_data_refs ===
embann.c:331:5: note: got vectype for stmt: _4->activation = prephitmp_87;
vector(4) float
embann.c:331:5: note: not vectorized: not enough data-refs in basic block.
embann.c:331:5: note: ===vect_slp_analyze_bb===
embann.c:331:5: note: ===vect_slp_analyze_bb===
embann.c:350:42: note: === vect_analyze_data_refs ===
embann.c:350:42: note: not vectorized: not enough data-refs in basic block.
embann.c:351:8: note: === vect_analyze_data_refs ===
embann.c:351:8: note: not vectorized: not enough data-refs in basic block.
embann.c:351:8: note: ===vect_slp_analyze_bb===
embann.c:351:29: note: ===vect_slp_analyze_bb===
embann.c:359:8: note: === vect_analyze_data_refs ===
embann.c:359:8: note: got vectype for stmt: _3 = trainingDataCollection.tail;
vector(2) long unsigned int
embann.c:359:8: note: got vectype for stmt: trainingDataNode_12->prev = _3;
vector(2) long unsigned int
embann.c:359:8: note: got vectype for stmt: trainingDataNode_12->next = 0B;
vector(2) long unsigned int
embann.c:359:8: note: got vectype for stmt: trainingDataNode_12->length = length_9(D);
vector(4) unsigned int
embann.c:359:8: note: got vectype for stmt: trainingDataNode_12->correctResponse = correctResponse_17(D);
vector(8) short unsigned int
embann.c:359:8: note: got vectype for stmt: _4 = *data_19(D);
vector(16) unsigned char
embann.c:359:8: note: got vectype for stmt: trainingDataNode_12->data[0] = _4;
vector(16) unsigned char
embann.c:359:8: note: got vectype for stmt: _5 = trainingDataCollection.head;
vector(2) long unsigned int
embann.c:359:8: note: === vect_analyze_data_ref_accesses ===
embann.c:359:8: note: Detected interleaving load trainingDataCollection.head and trainingDataCollection.tail
embann.c:359:8: note: Detected interleaving store trainingDataNode_12->prev and trainingDataNode_12->next
embann.c:359:8: note: Detected interleaving load of size 2 starting with _5 = trainingDataCollection.head;
embann.c:359:8: note: not consecutive access trainingDataNode_12->data[0] = _4;
embann.c:359:8: note: not consecutive access trainingDataNode_12->correctResponse = correctResponse_17(D);
embann.c:359:8: note: not consecutive access trainingDataNode_12->length = length_9(D);
embann.c:359:8: note: Detected interleaving store of size 2 starting with trainingDataNode_12->prev = _3;
embann.c:359:8: note: not consecutive access _4 = *data_19(D);
embann.c:359:8: note: === vect_pattern_recog ===
embann.c:359:8: note: === vect_analyze_slp ===
embann.c:359:8: note: Build SLP for trainingDataNode_12->prev = _3;
embann.c:359:8: note: Build SLP for trainingDataNode_12->next = 0B;
embann.c:359:8: note: Build SLP failed: different operation in stmt trainingDataNode_12->next = 0B;
embann.c:359:8: note: original stmt trainingDataNode_12->prev = _3;
embann.c:359:8: note: recording new base alignment for &trainingDataCollection
embann.c:359:8: note:   alignment:    16
embann.c:359:8: note:   misalignment: 0
embann.c:359:8: note:   based on:     _3 = trainingDataCollection.tail;
embann.c:359:8: note: recording new base alignment for trainingDataNode_12
embann.c:359:8: note:   alignment:    8
embann.c:359:8: note:   misalignment: 0
embann.c:359:8: note:   based on:     trainingDataNode_12->prev = _3;
embann.c:359:8: note: recording new base alignment for data_19(D)
embann.c:359:8: note:   alignment:    1
embann.c:359:8: note:   misalignment: 0
embann.c:359:8: note:   based on:     _4 = *data_19(D);
embann.c:359:8: note: ===vect_slp_analyze_bb===
embann.c:361:37: note: === vect_analyze_data_refs ===
embann.c:361:37: note: got vectype for stmt: trainingDataCollection.head = trainingDataNode_12;
vector(2) long unsigned int
embann.c:361:37: note: not vectorized: not enough data-refs in basic block.
embann.c:361:37: note: ===vect_slp_analyze_bb===
embann.c:366:43: note: === vect_analyze_data_refs ===
embann.c:366:43: note: got vectype for stmt: _3->next = trainingDataNode_12;
vector(2) long unsigned int
embann.c:366:43: note: not vectorized: not enough data-refs in basic block.
embann.c:366:43: note: ===vect_slp_analyze_bb===
embann.c:371:1: note: === vect_analyze_data_refs ===
embann.c:371:1: note: got vectype for stmt: trainingDataCollection.tail = trainingDataNode_12;
vector(2) long unsigned int
embann.c:371:1: note: got vectype for stmt: _6 = trainingDataCollection.numEntries;
vector(4) unsigned int
embann.c:371:1: note: got vectype for stmt: trainingDataCollection.numEntries = _7;
vector(4) unsigned int
embann.c:371:1: note: === vect_analyze_data_ref_accesses ===
embann.c:371:1: note: not consecutive access _6 = trainingDataCollection.numEntries;
embann.c:371:1: note: not consecutive access trainingDataCollection.numEntries = _7;
embann.c:371:1: note: not consecutive access trainingDataCollection.tail = trainingDataNode_12;
embann.c:371:1: note: not vectorized: no grouped stores in basic block.
embann.c:371:1: note: ===vect_slp_analyze_bb===
embann.c:377:42: note: === vect_analyze_data_refs ===
embann.c:377:42: note: not vectorized: not enough data-refs in basic block.
embann.c:378:8: note: === vect_analyze_data_refs ===
embann.c:378:8: note: not vectorized: not enough data-refs in basic block.
embann.c:378:8: note: ===vect_slp_analyze_bb===
embann.c:378:29: note: ===vect_slp_analyze_bb===
embann.c:384:5: note: === vect_analyze_data_refs ===
embann.c:384:5: note: got vectype for stmt: _3 = trainingDataCollection.tail;
vector(2) long unsigned int
embann.c:384:5: note: got vectype for stmt: trainingDataNode_12->prev = _3;
vector(2) long unsigned int
embann.c:384:5: note: got vectype for stmt: trainingDataNode_12->next = 0B;
vector(2) long unsigned int
embann.c:384:5: note: got vectype for stmt: trainingDataNode_12->length = length_9(D);
vector(4) unsigned int
embann.c:384:5: note: got vectype for stmt: trainingDataNode_12->correctResponse = correctResponse_17(D);
vector(8) short unsigned int
embann.c:384:5: note: === vect_analyze_data_ref_accesses ===
embann.c:384:5: note: Detected interleaving store trainingDataNode_12->prev and trainingDataNode_12->next
embann.c:384:5: note: not consecutive access _3 = trainingDataCollection.tail;
embann.c:384:5: note: not consecutive access trainingDataNode_12->correctResponse = correctResponse_17(D);
embann.c:384:5: note: not consecutive access trainingDataNode_12->length = length_9(D);
embann.c:384:5: note: Detected interleaving store of size 2 starting with trainingDataNode_12->prev = _3;
embann.c:384:5: note: === vect_pattern_recog ===
embann.c:384:5: note: === vect_analyze_slp ===
embann.c:384:5: note: Build SLP for trainingDataNode_12->prev = _3;
embann.c:384:5: note: Build SLP for trainingDataNode_12->next = 0B;
embann.c:384:5: note: Build SLP failed: different operation in stmt trainingDataNode_12->next = 0B;
embann.c:384:5: note: original stmt trainingDataNode_12->prev = _3;
embann.c:384:5: note: recording new base alignment for &trainingDataCollection
embann.c:384:5: note:   alignment:    16
embann.c:384:5: note:   misalignment: 0
embann.c:384:5: note:   based on:     _3 = trainingDataCollection.tail;
embann.c:384:5: note: recording new base alignment for trainingDataNode_12
embann.c:384:5: note:   alignment:    8
embann.c:384:5: note:   misalignment: 0
embann.c:384:5: note:   based on:     trainingDataNode_12->prev = _3;
embann.c:386:8: note: === vect_analyze_data_refs ===
embann.c:386:8: note: got vectype for stmt: _5 = trainingDataCollection.head;
vector(2) long unsigned int
embann.c:386:8: note: not vectorized: not enough data-refs in basic block.
embann.c:386:8: note: ===vect_slp_analyze_bb===
embann.c:388:37: note: === vect_analyze_data_refs ===
embann.c:388:37: note: got vectype for stmt: trainingDataCollection.head = trainingDataNode_12;
vector(2) long unsigned int
embann.c:388:37: note: not vectorized: not enough data-refs in basic block.
embann.c:388:37: note: ===vect_slp_analyze_bb===
embann.c:393:43: note: === vect_analyze_data_refs ===
embann.c:393:43: note: got vectype for stmt: _3->next = trainingDataNode_12;
vector(2) long unsigned int
embann.c:393:43: note: not vectorized: not enough data-refs in basic block.
embann.c:393:43: note: ===vect_slp_analyze_bb===
embann.c:398:1: note: === vect_analyze_data_refs ===
embann.c:398:1: note: got vectype for stmt: trainingDataCollection.tail = trainingDataNode_12;
vector(2) long unsigned int
embann.c:398:1: note: got vectype for stmt: _6 = trainingDataCollection.numEntries;
vector(4) unsigned int
embann.c:398:1: note: got vectype for stmt: trainingDataCollection.numEntries = _7;
vector(4) unsigned int
embann.c:398:1: note: === vect_analyze_data_ref_accesses ===
embann.c:398:1: note: not consecutive access _6 = trainingDataCollection.numEntries;
embann.c:398:1: note: not consecutive access trainingDataCollection.numEntries = _7;
embann.c:398:1: note: not consecutive access trainingDataCollection.tail = trainingDataNode_12;
embann.c:398:1: note: not vectorized: no grouped stores in basic block.
embann.c:398:1: note: ===vect_slp_analyze_bb===
embann.c:403:1: note: === vect_analyze_data_refs ===
embann.c:403:1: note: not vectorized: not enough data-refs in basic block.

Analyzing loop at embann.c:529
embann.c:529:5: note: ===== analyze_loop_nest =====
embann.c:529:5: note: === vect_analyze_loop_form ===
embann.c:529:5: note: not vectorized: multiple nested loops.
embann.c:529:5: note: bad loop form.

Analyzing loop at embann.c:542
embann.c:542:9: note: ===== analyze_loop_nest =====
embann.c:542:9: note: === vect_analyze_loop_form ===
embann.c:542:9: note: === get_loop_niters ===
embann.c:542:9: note: Symbolic number of iterations is (uint16_t) pretmp_204
embann.c:542:9: note: === vect_analyze_data_refs ===
embann.c:542:9: note: got vectype for stmt: _61 = network.59_1->inputLayer.neuron[_60];
vector(2) long unsigned int
embann.c:542:9: note: got vectype for stmt: _62 = _61->activation;
vector(4) float
embann.c:542:9: note: not vectorized: not suitable for gather load _62 = _61->activation;
embann.c:542:9: note: bad data references.

Analyzing loop at embann.c:532
embann.c:532:9: note: ===== analyze_loop_nest =====
embann.c:532:9: note: === vect_analyze_loop_form ===
embann.c:532:9: note: === get_loop_niters ===
embann.c:532:9: note: Symbolic number of iterations is (uint16_t) _149
embann.c:532:9: note: === vect_analyze_data_refs ===
embann.c:532:9: note: got vectype for stmt: _47 = *dOutputErrorToOutputSum.60_76[_46];
vector(4) float
embann.c:532:9: note: got vectype for stmt: _48 = network.59_1->outputLayer.neuron[_46];
vector(2) long unsigned int
embann.c:532:9: note: got vectype for stmt: _50 = _48->params[_211];
vector(2) long unsigned int
embann.c:532:9: note: not vectorized: not suitable for gather load _50 = _48->params[_211];
embann.c:532:9: note: bad data references.

Analyzing loop at embann.c:502
embann.c:502:5: note: ===== analyze_loop_nest =====
embann.c:502:5: note: === vect_analyze_loop_form ===
embann.c:502:5: note: not vectorized: control flow in loop.
embann.c:502:5: note: bad loop form.

Analyzing loop at embann.c:518
embann.c:518:9: note: ===== analyze_loop_nest =====
embann.c:518:9: note: === vect_analyze_loop_form ===
embann.c:518:9: note: === get_loop_niters ===
embann.c:518:9: note: Symbolic number of iterations is _77
embann.c:518:9: note: === vect_analyze_data_refs ===
embann.c:518:9: note: got vectype for stmt: _37 = network.59_1->hiddenLayer[_35].neuron[_36];
vector(2) long unsigned int
embann.c:518:9: note: got vectype for stmt: _38 = _37->activation;
vector(4) float
embann.c:518:9: note: not vectorized: not suitable for gather load _38 = _37->activation;
embann.c:518:9: note: bad data references.
embann.c:494:6: note: vectorized 0 loops in function.
embann.c:494:6: note: ===vect_slp_analyze_bb===
embann.c:496:11: note: === vect_analyze_data_refs ===
embann.c:496:11: note: got vectype for stmt: network.59_1 = network;
vector(2) long unsigned int
embann.c:496:11: note: got vectype for stmt: _71 = network.59_1->outputLayer.numNeurons;
vector(8) short unsigned int
embann.c:496:11: note: === vect_analyze_data_ref_accesses ===
embann.c:496:11: note: not consecutive access network.59_1 = network;
embann.c:496:11: note: not consecutive access _71 = network.59_1->outputLayer.numNeurons;
embann.c:496:11: note: not vectorized: no grouped stores in basic block.
embann.c:499:11: note: === vect_analyze_data_refs ===
embann.c:499:11: note: got vectype for stmt: _77 = network.59_1->hiddenLayer[0].numNeurons;
vector(8) short unsigned int
embann.c:499:11: note: not vectorized: not enough data-refs in basic block.
embann.c:502:5: note: === vect_analyze_data_refs ===
embann.c:502:5: note: not vectorized: not enough data-refs in basic block.
embann.c:502:5: note: ===vect_slp_analyze_bb===
embann.c:520:40: note: === vect_analyze_data_refs ===
embann.c:520:40: note: not vectorized: not enough data-refs in basic block.
embann.c:520:40: note: ===vect_slp_analyze_bb===
embann.c:504:12: note: === vect_analyze_data_refs ===
embann.c:504:12: note: got vectype for stmt: pretmp_176 = network.59_1->outputLayer.neuron[_175];
vector(2) long unsigned int
embann.c:504:12: note: got vectype for stmt: pretmp_177 = pretmp_176->activation;
vector(4) float
embann.c:504:12: note: === vect_analyze_data_ref_accesses ===
embann.c:504:12: note: not consecutive access pretmp_176 = network.59_1->outputLayer.neuron[_175];
embann.c:504:12: note: not consecutive access pretmp_177 = pretmp_176->activation;
embann.c:504:12: note: not vectorized: no grouped stores in basic block.
embann.c:504:12: note: ===vect_slp_analyze_bb===
embann.c:506:40: note: === vect_analyze_data_refs ===
embann.c:506:40: note: got vectype for stmt: *dOutputErrorToOutputSum.60_76[_175] = _25;
vector(4) float
embann.c:506:40: note: not vectorized: not enough data-refs in basic block.
embann.c:506:40: note: ===vect_slp_analyze_bb===
embann.c:518:9: note: === vect_analyze_data_refs ===
embann.c:518:9: note: not vectorized: not enough data-refs in basic block.
embann.c:518:9: note: ===vect_slp_analyze_bb===
embann.c:502:5: note: === vect_analyze_data_refs ===
embann.c:502:5: note: got vectype for stmt: _45 = network.59_1->outputLayer.numNeurons;
vector(8) short unsigned int
embann.c:502:5: note: not vectorized: not enough data-refs in basic block.
embann.c:502:5: note: ===vect_slp_analyze_bb===
embann.c:502:5: note: ===vect_slp_analyze_bb===
embann.c:512:40: note: === vect_analyze_data_refs ===
embann.c:512:40: note: got vectype for stmt: *dOutputErrorToOutputSum.60_76[_175] = _30;
vector(4) float
embann.c:512:40: note: not vectorized: not enough data-refs in basic block.
embann.c:512:40: note: ===vect_slp_analyze_bb===
embann.c:522:74: note: === vect_analyze_data_refs ===
embann.c:522:74: note: got vectype for stmt: _33 = network.59_1->properties.numHiddenLayers;
vector(16) unsigned char
embann.c:522:74: note: not vectorized: not enough data-refs in basic block.
embann.c:522:74: note: ===vect_slp_analyze_bb===
embann.c:518:9: note: === vect_analyze_data_refs ===
embann.c:518:9: note: got vectype for stmt: _37 = network.59_1->hiddenLayer[_35].neuron[_36];
vector(2) long unsigned int
embann.c:518:9: note: got vectype for stmt: _38 = _37->activation;
vector(4) float
embann.c:518:9: note: got vectype for stmt: *outputNeuronWeightChange.63_81[_175]{lb: 0 sz: _40 * 4}[_36] = _41;
vector(4) float
embann.c:518:9: note: === vect_analyze_data_ref_accesses ===
embann.c:518:9: note: not consecutive access _37 = network.59_1->hiddenLayer[_35].neuron[_36];
embann.c:518:9: note: not consecutive access _38 = _37->activation;
embann.c:518:9: note: not consecutive access *outputNeuronWeightChange.63_81[_175]{lb: 0 sz: _40 * 4}[_36] = _41;
embann.c:518:9: note: not vectorized: no grouped stores in basic block.
embann.c:518:9: note: ===vect_slp_analyze_bb===
embann.c:518:9: note: ===vect_slp_analyze_bb===
embann.c:518:9: note: === vect_analyze_data_refs ===
embann.c:518:9: note: got vectype for stmt: pretmp_201 = network.59_1->hiddenLayer[0].numNeurons;
vector(8) short unsigned int
embann.c:518:9: note: not vectorized: not enough data-refs in basic block.
embann.c:518:9: note: ===vect_slp_analyze_bb===
embann.c:529:5: note: === vect_analyze_data_refs ===
embann.c:529:5: note: not vectorized: not enough data-refs in basic block.
embann.c:529:5: note: ===vect_slp_analyze_bb===
embann.c:538:93: note: === vect_analyze_data_refs ===
embann.c:538:93: note: got vectype for stmt: pretmp_204 = network.59_1->inputLayer.numNeurons;
vector(8) short unsigned int
embann.c:538:93: note: not vectorized: not enough data-refs in basic block.
embann.c:538:93: note: ===vect_slp_analyze_bb===
embann.c:538:93: note: === vect_analyze_data_refs ===
embann.c:538:93: note: not vectorized: not enough data-refs in basic block.
embann.c:538:93: note: ===vect_slp_analyze_bb===
embann.c:532:9: note: === vect_analyze_data_refs ===
embann.c:532:9: note: got vectype for stmt: _47 = *dOutputErrorToOutputSum.60_76[_46];
vector(4) float
embann.c:532:9: note: got vectype for stmt: _48 = network.59_1->outputLayer.neuron[_46];
vector(2) long unsigned int
embann.c:532:9: note: got vectype for stmt: _50 = _48->params[_211];
vector(2) long unsigned int
embann.c:532:9: note: got vectype for stmt: _51 = _50->weight;
vector(4) float
embann.c:532:9: note: got vectype for stmt: _54 = *outputNeuronWeightChange.63_81[_46]{lb: 0 sz: _53 * 4}[_211];
vector(4) float
embann.c:532:9: note: got vectype for stmt: _50->weight = _55;
vector(4) float
embann.c:532:9: note: === vect_analyze_data_ref_accesses ===
embann.c:532:9: note: not consecutive access _48 = network.59_1->outputLayer.neuron[_46];
embann.c:532:9: note: not consecutive access _50 = _48->params[_211];
embann.c:532:9: note: not consecutive access _51 = _50->weight;
embann.c:532:9: note: not consecutive access _50->weight = _55;
embann.c:532:9: note: not consecutive access _47 = *dOutputErrorToOutputSum.60_76[_46];
embann.c:532:9: note: not consecutive access _54 = *outputNeuronWeightChange.63_81[_46]{lb: 0 sz: _53 * 4}[_211];
embann.c:532:9: note: not vectorized: no grouped stores in basic block.
embann.c:532:9: note: ===vect_slp_analyze_bb===
embann.c:532:9: note: ===vect_slp_analyze_bb===
embann.c:532:9: note: === vect_analyze_data_refs ===
embann.c:532:9: note: not vectorized: not enough data-refs in basic block.
embann.c:532:9: note: ===vect_slp_analyze_bb===
embann.c:542:9: note: === vect_analyze_data_refs ===
embann.c:542:9: note: not vectorized: not enough data-refs in basic block.
embann.c:542:9: note: ===vect_slp_analyze_bb===
embann.c:529:5: note: === vect_analyze_data_refs ===
embann.c:529:5: note: not vectorized: not enough data-refs in basic block.
embann.c:529:5: note: ===vect_slp_analyze_bb===
embann.c:564:14: note: === vect_analyze_data_refs ===
embann.c:564:14: note: got vectype for stmt: _57 = network.59_1->hiddenLayer[0].neuron[_56];
vector(2) long unsigned int
embann.c:564:14: note: got vectype for stmt: _58 = _57->activation;
vector(4) float
embann.c:564:14: note: === vect_analyze_data_ref_accesses ===
embann.c:564:14: note: not consecutive access _57 = network.59_1->hiddenLayer[0].neuron[_56];
embann.c:564:14: note: not consecutive access _58 = _57->activation;
embann.c:564:14: note: not vectorized: no grouped stores in basic block.
embann.c:564:14: note: ===vect_slp_analyze_bb===
embann.c:542:9: note: === vect_analyze_data_refs ===
embann.c:542:9: note: got vectype for stmt: _61 = network.59_1->inputLayer.neuron[_60];
vector(2) long unsigned int
embann.c:542:9: note: got vectype for stmt: _62 = _61->activation;
vector(4) float
embann.c:542:9: note: got vectype for stmt: _64 = _57->params[_60];
vector(2) long unsigned int
embann.c:542:9: note: got vectype for stmt: _65 = _64->weight;
vector(4) float
embann.c:542:9: note: got vectype for stmt: _64->weight = _66;
vector(4) float
embann.c:542:9: note: === vect_analyze_data_ref_accesses ===
embann.c:542:9: note: not consecutive access _61 = network.59_1->inputLayer.neuron[_60];
embann.c:542:9: note: not consecutive access _64 = _57->params[_60];
embann.c:542:9: note: not consecutive access _62 = _61->activation;
embann.c:542:9: note: not consecutive access _65 = _64->weight;
embann.c:542:9: note: not consecutive access _64->weight = _66;
embann.c:542:9: note: not vectorized: no grouped stores in basic block.
embann.c:542:9: note: ===vect_slp_analyze_bb===
embann.c:542:9: note: ===vect_slp_analyze_bb===
embann.c:542:9: note: ===vect_slp_analyze_bb===
embann.c:532:9: note: === vect_analyze_data_refs ===
embann.c:532:9: note: not vectorized: not enough data-refs in basic block.
embann.c:532:9: note: ===vect_slp_analyze_bb===
embann.c:554:1: note: === vect_analyze_data_refs ===
embann.c:554:1: note: not vectorized: not enough data-refs in basic block.

Analyzing loop at embann.c:417
embann.c:417:11: note: ===== analyze_loop_nest =====
embann.c:417:11: note: === vect_analyze_loop_form ===
embann.c:417:11: note: not vectorized: multiple nested loops.
embann.c:417:11: note: bad loop form.

Analyzing loop at embann.c:756
embann.c:756:5: note: ===== analyze_loop_nest =====
embann.c:756:5: note: === vect_analyze_loop_form ===
embann.c:756:5: note: not vectorized: control flow in loop.
embann.c:756:5: note: bad loop form.

Analyzing loop at embann.c:182
embann.c:182:5: note: ===== analyze_loop_nest =====
embann.c:182:5: note: === vect_analyze_loop_form ===
embann.c:182:5: note: === get_loop_niters ===
embann.c:182:5: note: Symbolic number of iterations is (uint32_t) _89
embann.c:182:5: note: === vect_analyze_data_refs ===
embann.c:182:5: note: got vectype for stmt: _46 = *_45;
vector(16) unsigned char
embann.c:182:5: note: got vectype for stmt: _50 = network.45_2->inputLayer.neuron[i_91];
vector(2) long unsigned int
embann.c:182:5: note: got vectype for stmt: _50->activation = _51;
vector(4) float
embann.c:182:5: note: not vectorized: not suitable for scatter store _50->activation = _51;
embann.c:182:5: note: bad data references.
embann.c:405:6: note: vectorized 0 loops in function.
embann.c:405:6: note: ===vect_slp_analyze_bb===
embann.c:409:8: note: === vect_analyze_data_refs ===
embann.c:409:8: note: not vectorized: not enough data-refs in basic block.
embann.c:409:8: note: ===vect_slp_analyze_bb===
embann.c:411:9: note: ===vect_slp_analyze_bb===
embann.c:415:16: note: === vect_analyze_data_refs ===
embann.c:415:16: note: got vectype for stmt: _39 = time.tv_usec;
vector(2) long int
embann.c:415:16: note: not vectorized: not enough data-refs in basic block.
embann.c:415:16: note: ===vect_slp_analyze_bb===
embann.c:420:29: note: === vect_analyze_data_refs ===
embann.c:420:29: note: got vectype for stmt: network.45_2 = network;
vector(2) long unsigned int
embann.c:420:29: note: got vectype for stmt: _3 = network.45_2->outputLayer.numNeurons;
vector(8) short unsigned int
embann.c:420:29: note: === vect_analyze_data_ref_accesses ===
embann.c:420:29: note: not consecutive access network.45_2 = network;
embann.c:420:29: note: not consecutive access _3 = network.45_2->outputLayer.numNeurons;
embann.c:420:29: note: not vectorized: no grouped stores in basic block.
embann.c:182:5: note: === vect_analyze_data_refs ===
embann.c:182:5: note: got vectype for stmt: _7 = trainingDataCollection.numEntries;
vector(4) unsigned int
embann.c:182:5: note: got vectype for stmt: _10 = trainingDataCollection.head;
vector(2) long unsigned int
embann.c:182:5: note: got vectype for stmt: _89 = network.45_2->inputLayer.numNeurons;
vector(8) short unsigned int
embann.c:182:5: note: === vect_analyze_data_ref_accesses ===
embann.c:182:5: note: not consecutive access _7 = trainingDataCollection.numEntries;
embann.c:182:5: note: not consecutive access _10 = trainingDataCollection.head;
embann.c:182:5: note: not consecutive access _89 = network.45_2->inputLayer.numNeurons;
embann.c:182:5: note: not vectorized: no grouped stores in basic block.
embann.c:182:5: note: ===vect_slp_analyze_bb===
embann.c:428:12: note: === vect_analyze_data_refs ===
embann.c:428:12: note: not vectorized: not enough data-refs in basic block.
embann.c:428:12: note: ===vect_slp_analyze_bb===
embann.c:428:12: note: ===vect_slp_analyze_bb===
embann.c:182:5: note: === vect_analyze_data_refs ===
embann.c:182:5: note: got vectype for stmt: _46 = *_45;
vector(16) unsigned char
embann.c:182:5: note: got vectype for stmt: _50 = network.45_2->inputLayer.neuron[i_91];
vector(2) long unsigned int
embann.c:182:5: note: got vectype for stmt: _50->activation = _51;
vector(4) float
embann.c:182:5: note: === vect_analyze_data_ref_accesses ===
embann.c:182:5: note: not consecutive access _46 = *_45;
embann.c:182:5: note: not consecutive access _50 = network.45_2->inputLayer.neuron[i_91];
embann.c:182:5: note: not consecutive access _50->activation = _51;
embann.c:182:5: note: not vectorized: no grouped stores in basic block.
embann.c:182:5: note: ===vect_slp_analyze_bb===
embann.c:182:5: note: ===vect_slp_analyze_bb===
embann.c:756:5: note: === vect_analyze_data_refs ===
embann.c:756:5: note: got vectype for stmt: network.145_35 = network;
vector(2) long unsigned int
embann.c:756:5: note: got vectype for stmt: _49 = network.145_35->outputLayer.numNeurons;
vector(8) short unsigned int
embann.c:756:5: note: === vect_analyze_data_ref_accesses ===
embann.c:756:5: note: not consecutive access network.145_35 = network;
embann.c:756:5: note: not consecutive access _49 = network.145_35->outputLayer.numNeurons;
embann.c:756:5: note: not vectorized: no grouped stores in basic block.
embann.c:756:5: note: ===vect_slp_analyze_bb===
embann.c:431:13: note: === vect_analyze_data_refs ===
embann.c:431:13: note: not vectorized: not enough data-refs in basic block.
embann.c:431:13: note: ===vect_slp_analyze_bb===
embann.c:431:13: note: ===vect_slp_analyze_bb===
embann.c:758:12: note: === vect_analyze_data_refs ===
embann.c:758:12: note: not vectorized: not enough data-refs in basic block.
embann.c:758:12: note: ===vect_slp_analyze_bb===
embann.c:760:13: note: === vect_analyze_data_refs ===
embann.c:760:13: note: got vectype for stmt: _69 = network.145_95->outputLayer.neuron[_109];
vector(2) long unsigned int
embann.c:760:13: note: got vectype for stmt: _70 = _69->activation;
vector(4) float
embann.c:760:13: note: === vect_analyze_data_ref_accesses ===
embann.c:760:13: note: not consecutive access _70 = _69->activation;
embann.c:760:13: note: not consecutive access _69 = network.145_95->outputLayer.neuron[_109];
embann.c:760:13: note: not vectorized: no grouped stores in basic block.
embann.c:760:13: note: ===vect_slp_analyze_bb===
embann.c:765:13: note: === vect_analyze_data_refs ===
embann.c:765:13: note: got vectype for stmt: _74 = network.145_95->outputLayer.neuron[_73];
vector(2) long unsigned int
embann.c:765:13: note: got vectype for stmt: _75 = _74->activation;
vector(4) float
embann.c:765:13: note: === vect_analyze_data_ref_accesses ===
embann.c:765:13: note: not consecutive access _75 = _74->activation;
embann.c:765:13: note: not consecutive access _74 = network.145_95->outputLayer.neuron[_73];
embann.c:765:13: note: not vectorized: no grouped stores in basic block.
embann.c:765:13: note: ===vect_slp_analyze_bb===
embann.c:756:5: note: === vect_analyze_data_refs ===
embann.c:756:5: note: got vectype for stmt: network.145_68 = network;
vector(2) long unsigned int
embann.c:756:5: note: got vectype for stmt: _80 = network.145_68->outputLayer.numNeurons;
vector(8) short unsigned int
embann.c:756:5: note: === vect_analyze_data_ref_accesses ===
embann.c:756:5: note: not consecutive access network.145_68 = network;
embann.c:756:5: note: not consecutive access _80 = network.145_68->outputLayer.numNeurons;
embann.c:756:5: note: not vectorized: no grouped stores in basic block.
embann.c:756:5: note: ===vect_slp_analyze_bb===
embann.c:756:5: note: ===vect_slp_analyze_bb===
embann.c:434:9: note: ===vect_slp_analyze_bb===
embann.c:417:11: note: === vect_analyze_data_refs ===
embann.c:417:11: note: got vectype for stmt: _55 = time.tv_usec;
vector(2) long int
embann.c:417:11: note: not vectorized: not enough data-refs in basic block.
embann.c:417:11: note: ===vect_slp_analyze_bb===
embann.c:436:1: note: === vect_analyze_data_refs ===
embann.c:436:1: note: not vectorized: not enough data-refs in basic block.

Analyzing loop at embann.c:451
embann.c:451:24: note: ===== analyze_loop_nest =====
embann.c:451:24: note: === vect_analyze_loop_form ===
embann.c:451:24: note: not vectorized: multiple nested loops.
embann.c:451:24: note: bad loop form.

Analyzing loop at embann.c:479
embann.c:479:37: note: ===== analyze_loop_nest =====
embann.c:479:37: note: === vect_analyze_loop_form ===
embann.c:479:37: note: not vectorized: control flow in loop.
embann.c:479:37: note: bad loop form.

Analyzing loop at embann.c:464
embann.c:464:9: note: ===== analyze_loop_nest =====
embann.c:464:9: note: === vect_analyze_loop_form ===
embann.c:464:9: note: === get_loop_niters ===
embann.c:464:9: note: Symbolic number of iterations is _115
embann.c:464:9: note: === vect_analyze_data_refs ===
embann.c:464:9: note: got vectype for stmt: pretmp_215 = prephitmp_198->outputLayer.neuron[_213];
vector(2) long unsigned int
embann.c:464:9: note: got vectype for stmt: pretmp_216 = pretmp_215->activation;
vector(4) float
embann.c:464:9: note: not vectorized: not suitable for gather load pretmp_216 = pretmp_215->activation;
embann.c:464:9: note: bad data references.
embann.c:464:9: note: ===vect_slp_analyze_bb===
embann.c:464:9: note: === vect_analyze_data_refs ===
embann.c:464:9: note: got vectype for stmt: pretmp_215 = prephitmp_198->outputLayer.neuron[_213];
vector(2) long unsigned int
embann.c:464:9: note: got vectype for stmt: pretmp_216 = pretmp_215->activation;
vector(4) float
embann.c:464:9: note: === vect_analyze_data_ref_accesses ===
embann.c:464:9: note: not consecutive access pretmp_215 = prephitmp_198->outputLayer.neuron[_213];
embann.c:464:9: note: not consecutive access pretmp_216 = pretmp_215->activation;
embann.c:464:9: note: not vectorized: no grouped stores in basic block.

Analyzing loop at embann.c:756
embann.c:756:5: note: ===== analyze_loop_nest =====
embann.c:756:5: note: === vect_analyze_loop_form ===
embann.c:756:5: note: not vectorized: control flow in loop.
embann.c:756:5: note: bad loop form.

Analyzing loop at embann.c:182
embann.c:182:5: note: ===== analyze_loop_nest =====
embann.c:182:5: note: === vect_analyze_loop_form ===
embann.c:182:5: note: === get_loop_niters ===
embann.c:182:5: note: Symbolic number of iterations is (unsigned int) _140
embann.c:182:5: note: === vect_analyze_data_refs ===
embann.c:182:5: note: got vectype for stmt: _104 = *_103;
vector(16) unsigned char
embann.c:182:5: note: got vectype for stmt: _108 = prephitmp_189->inputLayer.neuron[i_158];
vector(2) long unsigned int
embann.c:182:5: note: got vectype for stmt: _108->activation = _109;
vector(4) float
embann.c:182:5: note: not vectorized: not suitable for scatter store _108->activation = _109;
embann.c:182:5: note: bad data references.
embann.c:438:6: note: vectorized 0 loops in function.
embann.c:438:6: note: ===vect_slp_analyze_bb===
embann.c:441:11: note: === vect_analyze_data_refs ===
embann.c:441:11: note: got vectype for stmt: network.47_1 = network;
vector(2) long unsigned int
embann.c:441:11: note: got vectype for stmt: _73 = network.47_1->outputLayer.numNeurons;
vector(8) short unsigned int
embann.c:441:11: note: === vect_analyze_data_ref_accesses ===
embann.c:441:11: note: not consecutive access network.47_1 = network;
embann.c:441:11: note: not consecutive access _73 = network.47_1->outputLayer.numNeurons;
embann.c:441:11: note: not vectorized: no grouped stores in basic block.
embann.c:444:8: note: === vect_analyze_data_refs ===
embann.c:444:8: note: not vectorized: not enough data-refs in basic block.
embann.c:444:8: note: ===vect_slp_analyze_bb===
embann.c:446:9: note: === vect_analyze_data_refs ===
embann.c:446:9: note: got vectype for stmt: pretmp_186 = network;
vector(2) long unsigned int
embann.c:446:9: note: not vectorized: not enough data-refs in basic block.
embann.c:446:9: note: ===vect_slp_analyze_bb===
embann.c:446:9: note: === vect_analyze_data_refs ===
embann.c:446:9: note: not vectorized: not enough data-refs in basic block.
embann.c:446:9: note: ===vect_slp_analyze_bb===
embann.c:452:29: note: === vect_analyze_data_refs ===
embann.c:452:29: note: got vectype for stmt: _12 = prephitmp_189->outputLayer.numNeurons;
vector(8) short unsigned int
embann.c:452:29: note: not vectorized: not enough data-refs in basic block.
embann.c:182:5: note: === vect_analyze_data_refs ===
embann.c:182:5: note: got vectype for stmt: _16 = trainingDataCollection.numEntries;
vector(4) unsigned int
embann.c:182:5: note: got vectype for stmt: *currentCost.48_77[_19] = 0.0;
vector(4) float
embann.c:182:5: note: got vectype for stmt: _20 = trainingDataCollection.head;
vector(2) long unsigned int
embann.c:182:5: note: got vectype for stmt: _140 = prephitmp_189->inputLayer.numNeurons;
vector(8) short unsigned int
embann.c:182:5: note: === vect_analyze_data_ref_accesses ===
embann.c:182:5: note: not consecutive access _16 = trainingDataCollection.numEntries;
embann.c:182:5: note: not consecutive access _20 = trainingDataCollection.head;
embann.c:182:5: note: not consecutive access *currentCost.48_77[_19] = 0.0;
embann.c:182:5: note: not consecutive access _140 = prephitmp_189->inputLayer.numNeurons;
embann.c:182:5: note: not vectorized: no grouped stores in basic block.
embann.c:182:5: note: ===vect_slp_analyze_bb===
embann.c:457:12: note: === vect_analyze_data_refs ===
embann.c:457:12: note: not vectorized: not enough data-refs in basic block.
embann.c:457:12: note: ===vect_slp_analyze_bb===
embann.c:457:12: note: ===vect_slp_analyze_bb===
embann.c:182:5: note: === vect_analyze_data_refs ===
embann.c:182:5: note: got vectype for stmt: _104 = *_103;
vector(16) unsigned char
embann.c:182:5: note: got vectype for stmt: _108 = prephitmp_189->inputLayer.neuron[i_158];
vector(2) long unsigned int
embann.c:182:5: note: got vectype for stmt: _108->activation = _109;
vector(4) float
embann.c:182:5: note: === vect_analyze_data_ref_accesses ===
embann.c:182:5: note: not consecutive access _104 = *_103;
embann.c:182:5: note: not consecutive access _108->activation = _109;
embann.c:182:5: note: not consecutive access _108 = prephitmp_189->inputLayer.neuron[i_158];
embann.c:182:5: note: not vectorized: no grouped stores in basic block.
embann.c:182:5: note: ===vect_slp_analyze_bb===
embann.c:182:5: note: ===vect_slp_analyze_bb===
embann.c:756:5: note: === vect_analyze_data_refs ===
embann.c:756:5: note: got vectype for stmt: network.145_141 = network;
vector(2) long unsigned int
embann.c:756:5: note: got vectype for stmt: _136 = network.145_141->outputLayer.numNeurons;
vector(8) short unsigned int
embann.c:756:5: note: === vect_analyze_data_ref_accesses ===
embann.c:756:5: note: not consecutive access network.145_141 = network;
embann.c:756:5: note: not consecutive access _136 = network.145_141->outputLayer.numNeurons;
embann.c:756:5: note: not vectorized: no grouped stores in basic block.
embann.c:756:5: note: ===vect_slp_analyze_bb===
embann.c:756:5: note: ===vect_slp_analyze_bb===
embann.c:758:12: note: === vect_analyze_data_refs ===
embann.c:758:12: note: not vectorized: not enough data-refs in basic block.
embann.c:758:12: note: ===vect_slp_analyze_bb===
embann.c:760:13: note: === vect_analyze_data_refs ===
embann.c:760:13: note: got vectype for stmt: _119 = network.145_162->outputLayer.neuron[_194];
vector(2) long unsigned int
embann.c:760:13: note: got vectype for stmt: _120 = _119->activation;
vector(4) float
embann.c:760:13: note: === vect_analyze_data_ref_accesses ===
embann.c:760:13: note: not consecutive access _120 = _119->activation;
embann.c:760:13: note: not consecutive access _119 = network.145_162->outputLayer.neuron[_194];
embann.c:760:13: note: not vectorized: no grouped stores in basic block.
embann.c:760:13: note: ===vect_slp_analyze_bb===
embann.c:765:13: note: === vect_analyze_data_refs ===
embann.c:765:13: note: got vectype for stmt: _124 = network.145_162->outputLayer.neuron[_123];
vector(2) long unsigned int
embann.c:765:13: note: got vectype for stmt: _125 = _124->activation;
vector(4) float
embann.c:765:13: note: === vect_analyze_data_ref_accesses ===
embann.c:765:13: note: not consecutive access _125 = _124->activation;
embann.c:765:13: note: not consecutive access _124 = network.145_162->outputLayer.neuron[_123];
embann.c:765:13: note: not vectorized: no grouped stores in basic block.
embann.c:765:13: note: ===vect_slp_analyze_bb===
embann.c:756:5: note: === vect_analyze_data_refs ===
embann.c:756:5: note: got vectype for stmt: network.145_118 = network;
vector(2) long unsigned int
embann.c:756:5: note: got vectype for stmt: _130 = network.145_118->outputLayer.numNeurons;
vector(8) short unsigned int
embann.c:756:5: note: === vect_analyze_data_ref_accesses ===
embann.c:756:5: note: not consecutive access network.145_118 = network;
embann.c:756:5: note: not consecutive access _130 = network.145_118->outputLayer.numNeurons;
embann.c:756:5: note: not vectorized: no grouped stores in basic block.
embann.c:756:5: note: ===vect_slp_analyze_bb===
embann.c:756:5: note: ===vect_slp_analyze_bb===
embann.c:756:5: note: === vect_analyze_data_refs ===
embann.c:756:5: note: got vectype for stmt: pretmp_231 = *currentCost.48_77[_19];
vector(4) float
embann.c:756:5: note: not vectorized: not enough data-refs in basic block.
embann.c:756:5: note: ===vect_slp_analyze_bb===
embann.c:460:13: note: === vect_analyze_data_refs ===
embann.c:460:13: note: not vectorized: not enough data-refs in basic block.
embann.c:460:13: note: === vect_analyze_data_refs ===
embann.c:460:13: note: got vectype for stmt: pretmp_197 = network;
vector(2) long unsigned int
embann.c:460:13: note: not vectorized: not enough data-refs in basic block.
embann.c:460:13: note: ===vect_slp_analyze_bb===
embann.c:464:9: note: === vect_analyze_data_refs ===
embann.c:464:9: note: got vectype for stmt: _115 = prephitmp_198->outputLayer.numNeurons;
vector(8) short unsigned int
embann.c:464:9: note: not vectorized: not enough data-refs in basic block.
embann.c:464:9: note: ===vect_slp_analyze_bb===
embann.c:464:9: note: ===vect_slp_analyze_bb===
embann.c:466:16: note: === vect_analyze_data_refs ===
embann.c:466:16: note: got vectype for stmt: pretmp_210 = prephitmp_198->outputLayer.neuron[_212];
vector(2) long unsigned int
embann.c:466:16: note: got vectype for stmt: pretmp_209 = pretmp_210->activation;
vector(4) float
embann.c:466:16: note: === vect_analyze_data_ref_accesses ===
embann.c:466:16: note: not consecutive access pretmp_210 = prephitmp_198->outputLayer.neuron[_212];
embann.c:466:16: note: not consecutive access pretmp_209 = pretmp_210->activation;
embann.c:466:16: note: not vectorized: no grouped stores in basic block.
embann.c:466:16: note: ===vect_slp_analyze_bb===
embann.c:468:43: note: === vect_analyze_data_refs ===
embann.c:468:43: note: not vectorized: not enough data-refs in basic block.
embann.c:468:43: note: ===vect_slp_analyze_bb===
embann.c:472:43: note: === vect_analyze_data_refs ===
embann.c:472:43: note: not vectorized: not enough data-refs in basic block.
embann.c:472:43: note: ===vect_slp_analyze_bb===
embann.c:464:9: note: === vect_analyze_data_refs ===
embann.c:464:9: note: not vectorized: not enough data-refs in basic block.
embann.c:464:9: note: ===vect_slp_analyze_bb===
embann.c:464:9: note: ===vect_slp_analyze_bb===
embann.c:475:35: note: === vect_analyze_data_refs ===
embann.c:475:35: note: got vectype for stmt: *currentCost.48_77[_19] = cstore_160;
vector(4) float
embann.c:475:35: note: got vectype for stmt: *currentCost.48_77[_19] = _52;
vector(4) float
embann.c:475:35: note: === vect_analyze_data_ref_accesses ===
embann.c:475:35: note: not consecutive access *currentCost.48_77[_19] = cstore_160;
embann.c:475:35: note: not consecutive access *currentCost.48_77[_19] = _52;
embann.c:475:35: note: not vectorized: no grouped stores in basic block.
embann.c:475:35: note: ===vect_slp_analyze_bb===
embann.c:479:13: note: === vect_analyze_data_refs ===
embann.c:479:13: note: got vectype for stmt: _54 = *currentCost.48_77[_53];
vector(4) float
embann.c:479:13: note: not vectorized: not enough data-refs in basic block.
embann.c:481:16: note: === vect_analyze_data_refs ===
embann.c:481:16: note: not vectorized: not enough data-refs in basic block.
embann.c:481:16: note: ===vect_slp_analyze_bb===
embann.c:485:16: note: === vect_analyze_data_refs ===
embann.c:485:16: note: got vectype for stmt: network.55_56 = network;
vector(2) long unsigned int
embann.c:485:16: note: got vectype for stmt: _57 = network.55_56->outputLayer.numNeurons;
vector(8) short unsigned int
embann.c:485:16: note: === vect_analyze_data_ref_accesses ===
embann.c:485:16: note: not consecutive access network.55_56 = network;
embann.c:485:16: note: not consecutive access _57 = network.55_56->outputLayer.numNeurons;
embann.c:485:16: note: not vectorized: no grouped stores in basic block.
embann.c:485:16: note: ===vect_slp_analyze_bb===
embann.c:477:9: note: === vect_analyze_data_refs ===
embann.c:477:9: note: not vectorized: not enough data-refs in basic block.
embann.c:477:9: note: ===vect_slp_analyze_bb===
embann.c:477:9: note: ===vect_slp_analyze_bb===
embann.c:477:9: note: ===vect_slp_analyze_bb===
embann.c:477:9: note: ===vect_slp_analyze_bb===
embann.c:449:11: note: === vect_analyze_data_refs ===
embann.c:449:11: note: not vectorized: not enough data-refs in basic block.
embann.c:449:11: note: ===vect_slp_analyze_bb===
embann.c:449:11: note: === vect_analyze_data_refs ===
embann.c:449:11: note: got vectype for stmt: pretmp_188 = network;
vector(2) long unsigned int
embann.c:449:11: note: not vectorized: not enough data-refs in basic block.
embann.c:449:11: note: ===vect_slp_analyze_bb===
embann.c:492:1: note: === vect_analyze_data_refs ===
embann.c:492:1: note: not vectorized: not enough data-refs in basic block.
embann.c:492:1: note: ===vect_slp_analyze_bb===
embann.c:490:9: note: ===vect_slp_analyze_bb===
embann.c:477:9: note: === vect_analyze_data_refs ===
embann.c:477:9: note: not vectorized: not enough data-refs in basic block.
embann.c:477:9: note: ===vect_slp_analyze_bb===
embann.c:490:9: note: === vect_analyze_data_refs ===
embann.c:490:9: note: got vectype for stmt: *currentCost.48_77[_19] = _166;
vector(4) float
embann.c:490:9: note: not vectorized: not enough data-refs in basic block.
embann.c:490:9: note: ===vect_slp_analyze_bb===
embann.c:564:14: note: === vect_analyze_data_refs ===
embann.c:564:14: note: not vectorized: not enough data-refs in basic block.

Analyzing loop at embann.c:572
embann.c:572:5: note: ===== analyze_loop_nest =====
embann.c:572:5: note: === vect_analyze_loop_form ===
embann.c:572:5: note: === get_loop_niters ===
embann.c:572:5: note: Symbolic number of iterations is (uint16_t) _16
embann.c:572:5: note: === vect_analyze_data_refs ===
embann.c:572:5: note: got vectype for stmt: _2 = network.91_15->outputLayer.neuron[_1];
vector(2) long unsigned int
embann.c:572:5: note: got vectype for stmt: _4 = network.91_15->outputLayer.neuron[_3];
vector(2) long unsigned int
embann.c:572:5: note: not vectorized: not suitable for gather load _4 = network.91_15->outputLayer.neuron[_3];
embann.c:572:5: note: bad data references.
embann.c:572:5: note: ===vect_slp_analyze_bb===
embann.c:572:5: note: === vect_analyze_data_refs ===
embann.c:572:5: note: got vectype for stmt: _2 = network.91_15->outputLayer.neuron[_1];
vector(2) long unsigned int
embann.c:572:5: note: got vectype for stmt: _4 = network.91_15->outputLayer.neuron[_3];
vector(2) long unsigned int
embann.c:572:5: note: === vect_analyze_data_ref_accesses ===
embann.c:572:5: note: not consecutive access _2 = network.91_15->outputLayer.neuron[_1];
embann.c:572:5: note: not consecutive access _4 = network.91_15->outputLayer.neuron[_3];
embann.c:572:5: note: not vectorized: no grouped stores in basic block.
embann.c:568:9: note: vectorized 0 loops in function.
embann.c:568:9: note: ===vect_slp_analyze_bb===
embann.c:572:5: note: === vect_analyze_data_refs ===
embann.c:572:5: note: got vectype for stmt: network.91_15 = network;
vector(2) long unsigned int
embann.c:572:5: note: got vectype for stmt: _16 = network.91_15->outputLayer.numNeurons;
vector(8) short unsigned int
embann.c:572:5: note: === vect_analyze_data_ref_accesses ===
embann.c:572:5: note: not consecutive access network.91_15 = network;
embann.c:572:5: note: not consecutive access _16 = network.91_15->outputLayer.numNeurons;
embann.c:572:5: note: not vectorized: no grouped stores in basic block.
embann.c:572:5: note: ===vect_slp_analyze_bb===
embann.c:572:5: note: ===vect_slp_analyze_bb===
embann.c:572:5: note: ===vect_slp_analyze_bb===
embann.c:574:12: note: === vect_analyze_data_refs ===
embann.c:574:12: note: got vectype for stmt: _8 = network.91_15->outputLayer.neuron[_9];
vector(2) long unsigned int
embann.c:574:12: note: got vectype for stmt: _21 = network.91_15->outputLayer.neuron[_13];
vector(2) long unsigned int
embann.c:574:12: note: === vect_analyze_data_ref_accesses ===
embann.c:574:12: note: not consecutive access _8 = network.91_15->outputLayer.neuron[_9];
embann.c:574:12: note: not consecutive access _21 = network.91_15->outputLayer.neuron[_13];
embann.c:574:12: note: not vectorized: no grouped stores in basic block.
embann.c:574:12: note: ===vect_slp_analyze_bb===
embann.c:577:30: note: === vect_analyze_data_refs ===
embann.c:577:30: note: not vectorized: not enough data-refs in basic block.
embann.c:577:30: note: ===vect_slp_analyze_bb===
embann.c:572:5: note: === vect_analyze_data_refs ===
embann.c:572:5: note: not vectorized: not enough data-refs in basic block.
embann.c:572:5: note: ===vect_slp_analyze_bb===
embann.c:572:5: note: ===vect_slp_analyze_bb===
embann.c:582:12: note: === vect_analyze_data_refs ===
embann.c:582:12: note: not vectorized: not enough data-refs in basic block.

Analyzing loop at embann.c:610
embann.c:610:55: note: ===== analyze_loop_nest =====
embann.c:610:55: note: === vect_analyze_loop_form ===
embann.c:610:55: note: not vectorized: control flow in loop.
embann.c:610:55: note: bad loop form.

Analyzing loop at embann.c:634
embann.c:634:21: note: ===== analyze_loop_nest =====
embann.c:634:21: note: === vect_analyze_loop_form ===
embann.c:634:21: note: === get_loop_niters ===
embann.c:634:21: note: not vectorized: number of iterations cannot be computed.
embann.c:634:21: note: bad loop form.

Analyzing loop at embann.c:598
embann.c:598:9: note: ===== analyze_loop_nest =====
embann.c:598:9: note: === vect_analyze_loop_form ===
embann.c:598:9: note: === get_loop_niters ===
embann.c:598:9: note: not vectorized: number of iterations cannot be computed.
embann.c:598:9: note: bad loop form.

Analyzing loop at embann.c:588
embann.c:588:5: note: ===== analyze_loop_nest =====
embann.c:588:5: note: === vect_analyze_loop_form ===
embann.c:588:5: note: === get_loop_niters ===
embann.c:588:5: note: not vectorized: number of iterations cannot be computed.
embann.c:588:5: note: bad loop form.
embann.c:585:6: note: vectorized 0 loops in function.
embann.c:585:6: note: ===vect_slp_analyze_bb===
embann.c:588:5: note: === vect_analyze_data_refs ===
embann.c:588:5: note: got vectype for stmt: network.94_85 = network;
vector(2) long unsigned int
embann.c:588:5: note: got vectype for stmt: _114 = network.94_85->inputLayer.numNeurons;
vector(8) short unsigned int
embann.c:588:5: note: === vect_analyze_data_ref_accesses ===
embann.c:588:5: note: not consecutive access network.94_85 = network;
embann.c:588:5: note: not consecutive access _114 = network.94_85->inputLayer.numNeurons;
embann.c:588:5: note: not vectorized: no grouped stores in basic block.
embann.c:588:5: note: ===vect_slp_analyze_bb===
embann.c:588:5: note: ===vect_slp_analyze_bb===
embann.c:590:9: note: === vect_analyze_data_refs ===
embann.c:590:9: note: got vectype for stmt: _1 = network.94_111->inputLayer.neuron[_112];
vector(2) long unsigned int
embann.c:590:9: note: got vectype for stmt: _2 = _1->activation;
vector(4) float
embann.c:590:9: note: === vect_analyze_data_ref_accesses ===
embann.c:590:9: note: not consecutive access _2 = _1->activation;
embann.c:590:9: note: not consecutive access _1 = network.94_111->inputLayer.neuron[_112];
embann.c:590:9: note: not vectorized: no grouped stores in basic block.
embann.c:588:5: note: === vect_analyze_data_refs ===
embann.c:588:5: note: got vectype for stmt: network.94_5 = network;
vector(2) long unsigned int
embann.c:588:5: note: got vectype for stmt: _6 = network.94_5->inputLayer.numNeurons;
vector(8) short unsigned int
embann.c:588:5: note: === vect_analyze_data_ref_accesses ===
embann.c:588:5: note: not consecutive access network.94_5 = network;
embann.c:588:5: note: not consecutive access _6 = network.94_5->inputLayer.numNeurons;
embann.c:588:5: note: not vectorized: no grouped stores in basic block.
embann.c:588:5: note: ===vect_slp_analyze_bb===
embann.c:588:5: note: ===vect_slp_analyze_bb===
embann.c:588:5: note: ===vect_slp_analyze_bb===
embann.c:592:5: note: === vect_analyze_data_refs ===
embann.c:592:5: note: got vectype for stmt: _11 = network.94_93->inputLayer.neuron[_54];
vector(2) long unsigned int
embann.c:592:5: note: got vectype for stmt: _12 = _11->activation;
vector(4) float
embann.c:592:5: note: === vect_analyze_data_ref_accesses ===
embann.c:592:5: note: not consecutive access _12 = _11->activation;
embann.c:592:5: note: not consecutive access _11 = network.94_93->inputLayer.neuron[_54];
embann.c:592:5: note: not vectorized: no grouped stores in basic block.
embann.c:595:8: note: === vect_analyze_data_refs ===
embann.c:595:8: note: got vectype for stmt: network.97_14 = network;
vector(2) long unsigned int
embann.c:595:8: note: got vectype for stmt: _15 = network.97_14->properties.numHiddenLayers;
vector(16) unsigned char
embann.c:595:8: note: === vect_analyze_data_ref_accesses ===
embann.c:595:8: note: not consecutive access network.97_14 = network;
embann.c:595:8: note: not consecutive access _15 = network.97_14->properties.numHiddenLayers;
embann.c:595:8: note: not vectorized: no grouped stores in basic block.
embann.c:595:8: note: ===vect_slp_analyze_bb===
embann.c:603:5: note: ===vect_slp_analyze_bb===
embann.c:598:9: note: === vect_analyze_data_refs ===
embann.c:598:9: note: got vectype for stmt: network.99_117 = network;
vector(2) long unsigned int
embann.c:598:9: note: got vectype for stmt: _116 = network.99_117->properties.numHiddenLayers;
vector(16) unsigned char
embann.c:598:9: note: === vect_analyze_data_ref_accesses ===
embann.c:598:9: note: not consecutive access network.99_117 = network;
embann.c:598:9: note: not consecutive access _116 = network.99_117->properties.numHiddenLayers;
embann.c:598:9: note: not vectorized: no grouped stores in basic block.
embann.c:598:9: note: ===vect_slp_analyze_bb===
embann.c:598:9: note: ===vect_slp_analyze_bb===
embann.c:600:13: note: === vect_analyze_data_refs ===
embann.c:600:13: note: not vectorized: not enough data-refs in basic block.
embann.c:598:9: note: === vect_analyze_data_refs ===
embann.c:598:9: note: got vectype for stmt: network.99_17 = network;
vector(2) long unsigned int
embann.c:598:9: note: got vectype for stmt: _18 = network.99_17->properties.numHiddenLayers;
vector(16) unsigned char
embann.c:598:9: note: === vect_analyze_data_ref_accesses ===
embann.c:598:9: note: not consecutive access network.99_17 = network;
embann.c:598:9: note: not consecutive access _18 = network.99_17->properties.numHiddenLayers;
embann.c:598:9: note: not vectorized: no grouped stores in basic block.
embann.c:598:9: note: ===vect_slp_analyze_bb===
embann.c:598:9: note: ===vect_slp_analyze_bb===
embann.c:598:9: note: ===vect_slp_analyze_bb===
embann.c:609:12: note: === vect_analyze_data_refs ===
embann.c:609:12: note: got vectype for stmt: network.100_19 = network;
vector(2) long unsigned int
embann.c:609:12: note: got vectype for stmt: _20 = network.100_19->inputLayer.numNeurons;
vector(8) short unsigned int
embann.c:609:12: note: === vect_analyze_data_ref_accesses ===
embann.c:609:12: note: not consecutive access network.100_19 = network;
embann.c:609:12: note: not consecutive access _20 = network.100_19->inputLayer.numNeurons;
embann.c:609:12: note: not vectorized: no grouped stores in basic block.
embann.c:609:12: note: ===vect_slp_analyze_bb===
embann.c:609:51: note: === vect_analyze_data_refs ===
embann.c:609:51: note: got vectype for stmt: _21 = network.100_19->hiddenLayer[0].numNeurons;
vector(8) short unsigned int
embann.c:609:51: note: not vectorized: not enough data-refs in basic block.
embann.c:609:51: note: ===vect_slp_analyze_bb===
embann.c:610:55: note: === vect_analyze_data_refs ===
embann.c:610:55: note: got vectype for stmt: _22 = network.100_19->outputLayer.numNeurons;
vector(8) short unsigned int
embann.c:610:55: note: not vectorized: not enough data-refs in basic block.
embann.c:610:55: note: ===vect_slp_analyze_bb===
embann.c:658:5: note: === vect_analyze_data_refs ===
embann.c:658:5: note: got vectype for stmt: network.115_49 = network;
vector(2) long unsigned int
embann.c:658:5: note: got vectype for stmt: _50 = network.115_49->properties.networkResponse;
vector(8) short unsigned int
embann.c:658:5: note: === vect_analyze_data_ref_accesses ===
embann.c:658:5: note: not consecutive access network.115_49 = network;
embann.c:658:5: note: not consecutive access _50 = network.115_49->properties.networkResponse;
embann.c:658:5: note: not vectorized: no grouped stores in basic block.
embann.c:659:1: note: === vect_analyze_data_refs ===
embann.c:659:1: note: not vectorized: not enough data-refs in basic block.
embann.c:659:1: note: ===vect_slp_analyze_bb===
embann.c:619:17: note: === vect_analyze_data_refs ===
embann.c:619:17: note: got vectype for stmt: _24 = network.100_19->inputLayer.neuron[_23];
vector(2) long unsigned int
embann.c:619:17: note: got vectype for stmt: _25 = _24->activation;
vector(4) float
embann.c:619:17: note: === vect_analyze_data_ref_accesses ===
embann.c:619:17: note: not consecutive access _24 = network.100_19->inputLayer.neuron[_23];
embann.c:619:17: note: not consecutive access _25 = _24->activation;
embann.c:619:17: note: not vectorized: no grouped stores in basic block.
embann.c:619:17: note: ===vect_slp_analyze_bb===
embann.c:623:17: note: ===vect_slp_analyze_bb===
embann.c:626:16: note: === vect_analyze_data_refs ===
embann.c:626:16: note: got vectype for stmt: network.105_27 = network;
vector(2) long unsigned int
embann.c:626:16: note: got vectype for stmt: _28 = network.105_27->hiddenLayer[0].numNeurons;
vector(8) short unsigned int
embann.c:626:16: note: === vect_analyze_data_ref_accesses ===
embann.c:626:16: note: not consecutive access network.105_27 = network;
embann.c:626:16: note: not consecutive access _28 = network.105_27->hiddenLayer[0].numNeurons;
embann.c:626:16: note: not vectorized: no grouped stores in basic block.
embann.c:626:16: note: ===vect_slp_analyze_bb===
embann.c:628:20: note: === vect_analyze_data_refs ===
embann.c:628:20: note: got vectype for stmt: _29 = network.105_27->properties.numHiddenLayers;
vector(16) unsigned char
embann.c:628:20: note: not vectorized: not enough data-refs in basic block.
embann.c:628:20: note: ===vect_slp_analyze_bb===
embann.c:634:21: note: === vect_analyze_data_refs ===
embann.c:634:21: note: not vectorized: not enough data-refs in basic block.
embann.c:634:21: note: ===vect_slp_analyze_bb===
embann.c:630:21: note: === vect_analyze_data_refs ===
embann.c:630:21: note: got vectype for stmt: _31 = network.105_27->hiddenLayer[0].neuron[_30];
vector(2) long unsigned int
embann.c:630:21: note: got vectype for stmt: _32 = _31->activation;
vector(4) float
embann.c:630:21: note: === vect_analyze_data_ref_accesses ===
embann.c:630:21: note: not consecutive access _31 = network.105_27->hiddenLayer[0].neuron[_30];
embann.c:630:21: note: not consecutive access _32 = _31->activation;
embann.c:630:21: note: not vectorized: no grouped stores in basic block.
embann.c:630:21: note: === vect_analyze_data_refs ===
embann.c:630:21: note: got vectype for stmt: pretmp_129 = network;
vector(2) long unsigned int
embann.c:630:21: note: not vectorized: not enough data-refs in basic block.
embann.c:630:21: note: ===vect_slp_analyze_bb===
embann.c:630:21: note: === vect_analyze_data_refs ===
embann.c:630:21: note: not vectorized: not enough data-refs in basic block.
embann.c:630:21: note: ===vect_slp_analyze_bb===
embann.c:636:25: note: === vect_analyze_data_refs ===
embann.c:636:25: note: got vectype for stmt: _36 = network.110_110->hiddenLayer[_34].neuron[_134];
vector(2) long unsigned int
embann.c:636:25: note: got vectype for stmt: _37 = _36->activation;
vector(4) float
embann.c:636:25: note: === vect_analyze_data_ref_accesses ===
embann.c:636:25: note: not consecutive access _37 = _36->activation;
embann.c:636:25: note: not consecutive access _36 = network.110_110->hiddenLayer[_34].neuron[_134];
embann.c:636:25: note: not vectorized: no grouped stores in basic block.
embann.c:634:21: note: === vect_analyze_data_refs ===
embann.c:634:21: note: got vectype for stmt: network.110_39 = network;
vector(2) long unsigned int
embann.c:634:21: note: got vectype for stmt: _40 = network.110_39->properties.numHiddenLayers;
vector(16) unsigned char
embann.c:634:21: note: === vect_analyze_data_ref_accesses ===
embann.c:634:21: note: not consecutive access network.110_39 = network;
embann.c:634:21: note: not consecutive access _40 = network.110_39->properties.numHiddenLayers;
embann.c:634:21: note: not vectorized: no grouped stores in basic block.
embann.c:634:21: note: ===vect_slp_analyze_bb===
embann.c:634:21: note: ===vect_slp_analyze_bb===
embann.c:634:21: note: ===vect_slp_analyze_bb===
embann.c:643:20: note: === vect_analyze_data_refs ===
embann.c:643:20: note: got vectype for stmt: network.111_41 = network;
vector(2) long unsigned int
embann.c:643:20: note: got vectype for stmt: _42 = network.111_41->properties.numHiddenLayers;
vector(16) unsigned char
embann.c:643:20: note: === vect_analyze_data_ref_accesses ===
embann.c:643:20: note: not consecutive access network.111_41 = network;
embann.c:643:20: note: not consecutive access _42 = network.111_41->properties.numHiddenLayers;
embann.c:643:20: note: not vectorized: no grouped stores in basic block.
embann.c:643:20: note: ===vect_slp_analyze_bb===
embann.c:645:21: note: === vect_analyze_data_refs ===
embann.c:645:21: note: got vectype for stmt: pretmp_128 = network;
vector(2) long unsigned int
embann.c:645:21: note: not vectorized: not enough data-refs in basic block.
embann.c:645:21: note: ===vect_slp_analyze_bb===
embann.c:649:16: note: === vect_analyze_data_refs ===
embann.c:649:16: note: got vectype for stmt: _44 = prephitmp_130->outputLayer.numNeurons;
vector(8) short unsigned int
embann.c:649:16: note: not vectorized: not enough data-refs in basic block.
embann.c:649:16: note: ===vect_slp_analyze_bb===
embann.c:651:17: note: === vect_analyze_data_refs ===
embann.c:651:17: note: got vectype for stmt: _46 = prephitmp_130->outputLayer.neuron[_45];
vector(2) long unsigned int
embann.c:651:17: note: got vectype for stmt: _47 = _46->activation;
vector(4) float
embann.c:651:17: note: === vect_analyze_data_ref_accesses ===
embann.c:651:17: note: not consecutive access _47 = _46->activation;
embann.c:651:17: note: not consecutive access _46 = prephitmp_130->outputLayer.neuron[_45];
embann.c:651:17: note: not vectorized: no grouped stores in basic block.
embann.c:654:9: note: ===vect_slp_analyze_bb===
embann.c:654:9: note: ===vect_slp_analyze_bb===
embann.c:663:8: note: === vect_analyze_data_refs ===
embann.c:663:8: note: got vectype for stmt: network.116_2 = network;
vector(2) long unsigned int
embann.c:663:8: note: got vectype for stmt: _3 = network.116_2->inputLayer.numNeurons;
vector(8) short unsigned int
embann.c:663:8: note: === vect_analyze_data_ref_accesses ===
embann.c:663:8: note: not consecutive access network.116_2 = network;
embann.c:663:8: note: not consecutive access _3 = network.116_2->inputLayer.numNeurons;
embann.c:663:8: note: not vectorized: no grouped stores in basic block.
embann.c:663:8: note: ===vect_slp_analyze_bb===
embann.c:665:9: note: === vect_analyze_data_refs ===
embann.c:665:9: note: got vectype for stmt: _5 = network.116_2->inputLayer.neuron[_16];
vector(2) long unsigned int
embann.c:665:9: note: got vectype for stmt: _6 = _5->activation;
vector(4) float
embann.c:665:9: note: === vect_analyze_data_ref_accesses ===
embann.c:665:9: note: not consecutive access _5 = network.116_2->inputLayer.neuron[_16];
embann.c:665:9: note: not consecutive access _6 = _5->activation;
embann.c:665:9: note: not vectorized: no grouped stores in basic block.
embann.c:665:9: note: ===vect_slp_analyze_bb===
embann.c:670:9: note: === vect_analyze_data_refs ===
embann.c:670:9: note: not vectorized: not enough data-refs in basic block.
embann.c:670:9: note: ===vect_slp_analyze_bb===
embann.c:673:1: note: === vect_analyze_data_refs ===
embann.c:673:1: note: not vectorized: not enough data-refs in basic block.

Analyzing loop at embann.c:682
embann.c:682:9: note: ===== analyze_loop_nest =====
embann.c:682:9: note: === vect_analyze_loop_form ===
embann.c:682:9: note: not vectorized: control flow in loop.
embann.c:682:9: note: bad loop form.
embann.c:675:6: note: vectorized 0 loops in function.
embann.c:675:6: note: ===vect_slp_analyze_bb===
embann.c:677:8: note: === vect_analyze_data_refs ===
embann.c:677:8: note: got vectype for stmt: network.119_2 = network;
vector(2) long unsigned int
embann.c:677:8: note: got vectype for stmt: _3 = network.119_2->outputLayer.numNeurons;
vector(8) short unsigned int
embann.c:677:8: note: === vect_analyze_data_ref_accesses ===
embann.c:677:8: note: not consecutive access network.119_2 = network;
embann.c:677:8: note: not consecutive access _3 = network.119_2->outputLayer.numNeurons;
embann.c:677:8: note: not vectorized: no grouped stores in basic block.
embann.c:677:8: note: ===vect_slp_analyze_bb===
embann.c:682:9: note: === vect_analyze_data_refs ===
embann.c:682:9: note: got vectype for stmt: network.126_42 = network;
vector(2) long unsigned int
embann.c:682:9: note: got vectype for stmt: _44 = network.126_42->hiddenLayer[0].numNeurons;
vector(8) short unsigned int
embann.c:682:9: note: === vect_analyze_data_ref_accesses ===
embann.c:682:9: note: not consecutive access network.126_42 = network;
embann.c:682:9: note: not consecutive access _44 = network.126_42->hiddenLayer[0].numNeurons;
embann.c:682:9: note: not vectorized: no grouped stores in basic block.
embann.c:682:9: note: ===vect_slp_analyze_bb===
embann.c:682:9: note: ===vect_slp_analyze_bb===
embann.c:682:9: note: ===vect_slp_analyze_bb===
embann.c:684:13: note: === vect_analyze_data_refs ===
embann.c:684:13: note: got vectype for stmt: _5 = network.126_45->outputLayer.neuron[_61];
vector(2) long unsigned int
embann.c:684:13: note: got vectype for stmt: _7 = _5->params[_6];
vector(2) long unsigned int
embann.c:684:13: note: got vectype for stmt: _8 = _7->weight;
vector(4) float
embann.c:684:13: note: got vectype for stmt: _10 = network.126_45->properties.numHiddenLayers;
vector(16) unsigned char
embann.c:684:13: note: got vectype for stmt: _13 = network.126_45->hiddenLayer[_12].neuron[_6];
vector(2) long unsigned int
embann.c:684:13: note: got vectype for stmt: _14 = _13->activation;
vector(4) float
embann.c:684:13: note: === vect_analyze_data_ref_accesses ===
embann.c:684:13: note: not consecutive access _7 = _5->params[_6];
embann.c:684:13: note: not consecutive access _8 = _7->weight;
embann.c:684:13: note: not consecutive access _14 = _13->activation;
embann.c:684:13: note: not consecutive access _10 = network.126_45->properties.numHiddenLayers;
embann.c:684:13: note: not consecutive access _13 = network.126_45->hiddenLayer[_12].neuron[_6];
embann.c:684:13: note: not consecutive access _5 = network.126_45->outputLayer.neuron[_61];
embann.c:684:13: note: not vectorized: no grouped stores in basic block.
embann.c:689:16: note: === vect_analyze_data_refs ===
embann.c:689:16: note: got vectype for stmt: network.123_17 = network;
vector(2) long unsigned int
embann.c:689:16: note: got vectype for stmt: _18 = network.123_17->hiddenLayer[0].numNeurons;
vector(8) short unsigned int
embann.c:689:16: note: === vect_analyze_data_ref_accesses ===
embann.c:689:16: note: not consecutive access network.123_17 = network;
embann.c:689:16: note: not consecutive access _18 = network.123_17->hiddenLayer[0].numNeurons;
embann.c:689:16: note: not vectorized: no grouped stores in basic block.
embann.c:689:16: note: ===vect_slp_analyze_bb===
embann.c:691:17: note: === vect_analyze_data_refs ===
embann.c:691:17: note: got vectype for stmt: _22 = network.123_17->outputLayer.neuron[_61];
vector(2) long unsigned int
embann.c:691:17: note: got vectype for stmt: _23 = _22->activation;
vector(4) float
embann.c:691:17: note: === vect_analyze_data_ref_accesses ===
embann.c:691:17: note: not consecutive access _22 = network.123_17->outputLayer.neuron[_61];
embann.c:691:17: note: not consecutive access _23 = _22->activation;
embann.c:691:17: note: not vectorized: no grouped stores in basic block.
embann.c:691:17: note: ===vect_slp_analyze_bb===
embann.c:682:9: note: === vect_analyze_data_refs ===
embann.c:682:9: note: got vectype for stmt: network.126_25 = network;
vector(2) long unsigned int
embann.c:682:9: note: got vectype for stmt: _26 = network.126_25->hiddenLayer[0].numNeurons;
vector(8) short unsigned int
embann.c:682:9: note: === vect_analyze_data_ref_accesses ===
embann.c:682:9: note: not consecutive access network.126_25 = network;
embann.c:682:9: note: not consecutive access _26 = network.126_25->hiddenLayer[0].numNeurons;
embann.c:682:9: note: not vectorized: no grouped stores in basic block.
embann.c:682:9: note: ===vect_slp_analyze_bb===
embann.c:682:9: note: ===vect_slp_analyze_bb===
embann.c:698:9: note: === vect_analyze_data_refs ===
embann.c:698:9: note: not vectorized: not enough data-refs in basic block.
embann.c:698:9: note: ===vect_slp_analyze_bb===
embann.c:702:1: note: === vect_analyze_data_refs ===
embann.c:702:1: note: not vectorized: not enough data-refs in basic block.

Analyzing loop at embann.c:714
embann.c:714:13: note: ===== analyze_loop_nest =====
embann.c:714:13: note: === vect_analyze_loop_form ===
embann.c:714:13: note: not vectorized: control flow in loop.
embann.c:714:13: note: bad loop form.

Analyzing loop at embann.c:730
embann.c:730:13: note: ===== analyze_loop_nest =====
embann.c:730:13: note: === vect_analyze_loop_form ===
embann.c:730:13: note: not vectorized: control flow in loop.
embann.c:730:13: note: bad loop form.
embann.c:704:6: note: vectorized 0 loops in function.
embann.c:704:6: note: ===vect_slp_analyze_bb===
embann.c:706:8: note: === vect_analyze_data_refs ===
embann.c:706:8: note: got vectype for stmt: network.128_2 = network;
vector(2) long unsigned int
embann.c:706:8: note: got vectype for stmt: _3 = network.128_2->hiddenLayer[0].numNeurons;
vector(8) short unsigned int
embann.c:706:8: note: === vect_analyze_data_ref_accesses ===
embann.c:706:8: note: not consecutive access network.128_2 = network;
embann.c:706:8: note: not consecutive access _3 = network.128_2->hiddenLayer[0].numNeurons;
embann.c:706:8: note: not vectorized: no grouped stores in basic block.
embann.c:706:8: note: ===vect_slp_analyze_bb===
embann.c:711:12: note: === vect_analyze_data_refs ===
embann.c:711:12: note: not vectorized: not enough data-refs in basic block.
embann.c:711:12: note: ===vect_slp_analyze_bb===
embann.c:730:13: note: === vect_analyze_data_refs ===
embann.c:730:13: note: got vectype for stmt: network.140_72 = network;
vector(2) long unsigned int
embann.c:730:13: note: got vectype for stmt: _74 = network.140_72->hiddenLayer[0].numNeurons;
vector(8) short unsigned int
embann.c:730:13: note: === vect_analyze_data_ref_accesses ===
embann.c:730:13: note: not consecutive access network.140_72 = network;
embann.c:730:13: note: not consecutive access _74 = network.140_72->hiddenLayer[0].numNeurons;
embann.c:730:13: note: not vectorized: no grouped stores in basic block.
embann.c:730:13: note: ===vect_slp_analyze_bb===
embann.c:730:13: note: ===vect_slp_analyze_bb===
embann.c:714:13: note: === vect_analyze_data_refs ===
embann.c:714:13: note: got vectype for stmt: network.134_70 = network;
vector(2) long unsigned int
embann.c:714:13: note: got vectype for stmt: _73 = network.134_70->inputLayer.numNeurons;
vector(8) short unsigned int
embann.c:714:13: note: === vect_analyze_data_ref_accesses ===
embann.c:714:13: note: not consecutive access network.134_70 = network;
embann.c:714:13: note: not consecutive access _73 = network.134_70->inputLayer.numNeurons;
embann.c:714:13: note: not vectorized: no grouped stores in basic block.
embann.c:714:13: note: ===vect_slp_analyze_bb===
embann.c:714:13: note: ===vect_slp_analyze_bb===
embann.c:716:17: note: === vect_analyze_data_refs ===
embann.c:716:17: note: got vectype for stmt: _5 = network.134_75->hiddenLayer[0].neuron[_95];
vector(2) long unsigned int
embann.c:716:17: note: got vectype for stmt: _7 = _5->params[_6];
vector(2) long unsigned int
embann.c:716:17: note: got vectype for stmt: _8 = _7->weight;
vector(4) float
embann.c:716:17: note: got vectype for stmt: _10 = network.134_75->inputLayer.neuron[_6];
vector(2) long unsigned int
embann.c:716:17: note: got vectype for stmt: _11 = _10->activation;
vector(4) float
embann.c:716:17: note: === vect_analyze_data_ref_accesses ===
embann.c:716:17: note: not consecutive access _7 = _5->params[_6];
embann.c:716:17: note: not consecutive access _8 = _7->weight;
embann.c:716:17: note: not consecutive access _11 = _10->activation;
embann.c:716:17: note: not consecutive access _10 = network.134_75->inputLayer.neuron[_6];
embann.c:716:17: note: not consecutive access _5 = network.134_75->hiddenLayer[0].neuron[_95];
embann.c:716:17: note: not vectorized: no grouped stores in basic block.
embann.c:719:20: note: === vect_analyze_data_refs ===
embann.c:719:20: note: got vectype for stmt: network.131_14 = network;
vector(2) long unsigned int
embann.c:719:20: note: got vectype for stmt: _15 = network.131_14->inputLayer.numNeurons;
vector(8) short unsigned int
embann.c:719:20: note: === vect_analyze_data_ref_accesses ===
embann.c:719:20: note: not consecutive access network.131_14 = network;
embann.c:719:20: note: not consecutive access _15 = network.131_14->inputLayer.numNeurons;
embann.c:719:20: note: not vectorized: no grouped stores in basic block.
embann.c:719:20: note: ===vect_slp_analyze_bb===
embann.c:721:21: note: === vect_analyze_data_refs ===
embann.c:721:21: note: got vectype for stmt: _19 = network.131_14->hiddenLayer[0].neuron[_95];
vector(2) long unsigned int
embann.c:721:21: note: got vectype for stmt: _20 = _19->activation;
vector(4) float
embann.c:721:21: note: === vect_analyze_data_ref_accesses ===
embann.c:721:21: note: not consecutive access _19 = network.131_14->hiddenLayer[0].neuron[_95];
embann.c:721:21: note: not consecutive access _20 = _19->activation;
embann.c:721:21: note: not vectorized: no grouped stores in basic block.
embann.c:721:21: note: ===vect_slp_analyze_bb===
embann.c:714:13: note: === vect_analyze_data_refs ===
embann.c:714:13: note: got vectype for stmt: network.134_22 = network;
vector(2) long unsigned int
embann.c:714:13: note: got vectype for stmt: _23 = network.134_22->inputLayer.numNeurons;
vector(8) short unsigned int
embann.c:714:13: note: === vect_analyze_data_ref_accesses ===
embann.c:714:13: note: not consecutive access network.134_22 = network;
embann.c:714:13: note: not consecutive access _23 = network.134_22->inputLayer.numNeurons;
embann.c:714:13: note: not vectorized: no grouped stores in basic block.
embann.c:714:13: note: ===vect_slp_analyze_bb===
embann.c:714:13: note: ===vect_slp_analyze_bb===
embann.c:714:13: note: === vect_analyze_data_refs ===
embann.c:714:13: note: not vectorized: not enough data-refs in basic block.
embann.c:714:13: note: ===vect_slp_analyze_bb===
embann.c:732:17: note: === vect_analyze_data_refs ===
embann.c:732:17: note: got vectype for stmt: _26 = network.140_76->hiddenLayer[_100].neuron[_95];
vector(2) long unsigned int
embann.c:732:17: note: got vectype for stmt: _28 = _26->params[_27];
vector(2) long unsigned int
embann.c:732:17: note: got vectype for stmt: _29 = _28->weight;
vector(4) float
embann.c:732:17: note: got vectype for stmt: _31 = network.140_76->hiddenLayer[_100].neuron[_27];
vector(2) long unsigned int
embann.c:732:17: note: got vectype for stmt: _32 = _31->activation;
vector(4) float
embann.c:732:17: note: === vect_analyze_data_ref_accesses ===
embann.c:732:17: note: not consecutive access _28 = _26->params[_27];
embann.c:732:17: note: not consecutive access _29 = _28->weight;
embann.c:732:17: note: not consecutive access _32 = _31->activation;
embann.c:732:17: note: not consecutive access _31 = network.140_76->hiddenLayer[_100].neuron[_27];
embann.c:732:17: note: not consecutive access _26 = network.140_76->hiddenLayer[_100].neuron[_95];
embann.c:732:17: note: not vectorized: no grouped stores in basic block.
embann.c:736:20: note: === vect_analyze_data_refs ===
embann.c:736:20: note: got vectype for stmt: network.137_35 = network;
vector(2) long unsigned int
embann.c:736:20: note: got vectype for stmt: _36 = network.137_35->hiddenLayer[0].numNeurons;
vector(8) short unsigned int
embann.c:736:20: note: === vect_analyze_data_ref_accesses ===
embann.c:736:20: note: not consecutive access network.137_35 = network;
embann.c:736:20: note: not consecutive access _36 = network.137_35->hiddenLayer[0].numNeurons;
embann.c:736:20: note: not vectorized: no grouped stores in basic block.
embann.c:736:20: note: ===vect_slp_analyze_bb===
embann.c:738:21: note: === vect_analyze_data_refs ===
embann.c:738:21: note: got vectype for stmt: _40 = network.137_35->hiddenLayer[0].neuron[_95];
vector(2) long unsigned int
embann.c:738:21: note: got vectype for stmt: _41 = _40->activation;
vector(4) float
embann.c:738:21: note: === vect_analyze_data_ref_accesses ===
embann.c:738:21: note: not consecutive access _40 = network.137_35->hiddenLayer[0].neuron[_95];
embann.c:738:21: note: not consecutive access _41 = _40->activation;
embann.c:738:21: note: not vectorized: no grouped stores in basic block.
embann.c:738:21: note: ===vect_slp_analyze_bb===
embann.c:730:13: note: === vect_analyze_data_refs ===
embann.c:730:13: note: got vectype for stmt: network.140_43 = network;
vector(2) long unsigned int
embann.c:730:13: note: got vectype for stmt: _44 = network.140_43->hiddenLayer[0].numNeurons;
vector(8) short unsigned int
embann.c:730:13: note: === vect_analyze_data_ref_accesses ===
embann.c:730:13: note: not consecutive access network.140_43 = network;
embann.c:730:13: note: not consecutive access _44 = network.140_43->hiddenLayer[0].numNeurons;
embann.c:730:13: note: not vectorized: no grouped stores in basic block.
embann.c:730:13: note: ===vect_slp_analyze_bb===
embann.c:730:13: note: ===vect_slp_analyze_bb===
embann.c:747:9: note: === vect_analyze_data_refs ===
embann.c:747:9: note: not vectorized: not enough data-refs in basic block.
embann.c:747:9: note: ===vect_slp_analyze_bb===
embann.c:751:1: note: === vect_analyze_data_refs ===
embann.c:751:1: note: not vectorized: not enough data-refs in basic block.

Analyzing loop at embann.c:756
embann.c:756:5: note: ===== analyze_loop_nest =====
embann.c:756:5: note: === vect_analyze_loop_form ===
embann.c:756:5: note: not vectorized: control flow in loop.
embann.c:756:5: note: bad loop form.
embann.c:753:6: note: vectorized 0 loops in function.
embann.c:753:6: note: ===vect_slp_analyze_bb===
embann.c:756:5: note: === vect_analyze_data_refs ===
embann.c:756:5: note: got vectype for stmt: network.145_24 = network;
vector(2) long unsigned int
embann.c:756:5: note: got vectype for stmt: _27 = network.145_24->outputLayer.numNeurons;
vector(8) short unsigned int
embann.c:756:5: note: === vect_analyze_data_ref_accesses ===
embann.c:756:5: note: not consecutive access network.145_24 = network;
embann.c:756:5: note: not consecutive access _27 = network.145_24->outputLayer.numNeurons;
embann.c:756:5: note: not vectorized: no grouped stores in basic block.
embann.c:756:5: note: ===vect_slp_analyze_bb===
embann.c:756:5: note: ===vect_slp_analyze_bb===
embann.c:758:12: note: === vect_analyze_data_refs ===
embann.c:758:12: note: not vectorized: not enough data-refs in basic block.
embann.c:758:12: note: ===vect_slp_analyze_bb===
embann.c:760:13: note: === vect_analyze_data_refs ===
embann.c:760:13: note: got vectype for stmt: _2 = network.145_28->outputLayer.neuron[_1];
vector(2) long unsigned int
embann.c:760:13: note: got vectype for stmt: _3 = _2->activation;
vector(4) float
embann.c:760:13: note: === vect_analyze_data_ref_accesses ===
embann.c:760:13: note: not consecutive access _3 = _2->activation;
embann.c:760:13: note: not consecutive access _2 = network.145_28->outputLayer.neuron[_1];
embann.c:760:13: note: not vectorized: no grouped stores in basic block.
embann.c:760:13: note: ===vect_slp_analyze_bb===
embann.c:765:13: note: === vect_analyze_data_refs ===
embann.c:765:13: note: got vectype for stmt: _7 = network.145_28->outputLayer.neuron[_6];
vector(2) long unsigned int
embann.c:765:13: note: got vectype for stmt: _8 = _7->activation;
vector(4) float
embann.c:765:13: note: === vect_analyze_data_ref_accesses ===
embann.c:765:13: note: not consecutive access _8 = _7->activation;
embann.c:765:13: note: not consecutive access _7 = network.145_28->outputLayer.neuron[_6];
embann.c:765:13: note: not vectorized: no grouped stores in basic block.
embann.c:765:13: note: ===vect_slp_analyze_bb===
embann.c:756:5: note: === vect_analyze_data_refs ===
embann.c:756:5: note: got vectype for stmt: network.145_12 = network;
vector(2) long unsigned int
embann.c:756:5: note: got vectype for stmt: _13 = network.145_12->outputLayer.numNeurons;
vector(8) short unsigned int
embann.c:756:5: note: === vect_analyze_data_ref_accesses ===
embann.c:756:5: note: not consecutive access network.145_12 = network;
embann.c:756:5: note: not consecutive access _13 = network.145_12->outputLayer.numNeurons;
embann.c:756:5: note: not vectorized: no grouped stores in basic block.
embann.c:756:5: note: ===vect_slp_analyze_bb===
embann.c:756:5: note: ===vect_slp_analyze_bb===
embann.c:768:1: note: === vect_analyze_data_refs ===
embann.c:768:1: note: not vectorized: not enough data-refs in basic block.
embann.c:826:5: note: applying unroll and jam with factor 2
embann.c:812:5: note: applying unroll and jam with factor 2
embann.c:798:5: note: applying unroll and jam with factor 2
embann.c:826:5: note: loops interchanged in loop nest
embann.c:812:5: note: loops interchanged in loop nest
embann.c:798:5: note: loops interchanged in loop nest

Analyzing loop at embann.c:826
embann.c:826:5: note: ===== analyze_loop_nest =====
embann.c:826:5: note: === vect_analyze_loop_form ===
embann.c:826:5: note: === vect_analyze_loop_form ===
embann.c:826:5: note: === get_loop_niters ===
embann.c:826:5: note: Considering outer-loop vectorization.
embann.c:826:5: note: === get_loop_niters ===
embann.c:826:5: note: === vect_analyze_data_refs ===
embann.c:826:5: note: analyze in outer loop: *(&testDouble + (sizetype) j_227 * 8)
embann.c:826:5: note: 	outer base_address: &testDouble
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 8
	outer base alignment: 32

	outer base misalignment: 0

	outer offset alignment: 256

	outer step alignment: 8
embann.c:826:5: note: got vectype for stmt: _188 = testDouble[_189];
vector(2) double
embann.c:826:5: note: analyze in outer loop: *(&testDoubleWeight + (sizetype) j_227 * 8)
embann.c:826:5: note: 	outer base_address: &testDoubleWeight
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 8
	outer base alignment: 32

	outer base misalignment: 0

	outer offset alignment: 256

	outer step alignment: 8
embann.c:826:5: note: got vectype for stmt: _176 = testDoubleWeight[_189];
vector(2) double
embann.c:826:5: note: analyze in outer loop: *(&testDoubleBias + (sizetype) j_227 * 8)
embann.c:826:5: note: 	outer base_address: &testDoubleBias
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 8
	outer base alignment: 32

	outer base misalignment: 0

	outer offset alignment: 256

	outer step alignment: 8
embann.c:826:5: note: got vectype for stmt: _160 = testDoubleBias[_189];
vector(2) double
embann.c:826:5: note: analyze in outer loop: *(&testDouble + (sizetype) j_227 * 8)
embann.c:826:5: note: 	outer base_address: &testDouble
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 8
	outer base alignment: 32

	outer base misalignment: 0

	outer offset alignment: 256

	outer step alignment: 8
embann.c:826:5: note: got vectype for stmt: testDouble[_189] = _159;
vector(2) double
embann.c:826:5: note: === vect_analyze_scalar_cycles ===
embann.c:826:5: note: Analyze phi: .MEM_212 = PHI <.MEM_158(37), .MEM_140(40)>
embann.c:826:5: note: Analyze phi: j_227 = PHI <j_226(37), 0(40)>
embann.c:826:5: note: Access function of PHI: {0, +, 1}_9
embann.c:826:5: note: step: 1,  init: 0
embann.c:826:5: note: Detected induction.
embann.c:826:5: note: Analyze phi: ivtmp_225 = PHI <ivtmp_243(37), 256(40)>
embann.c:826:5: note: Access function of PHI: {256, +, 65535}_9
embann.c:826:5: note: step: 65535,  init: 256
embann.c:826:5: note: Detected induction.
embann.c:826:5: note: Analyze phi: ivtmp_244 = PHI <ivtmp_245(37), 256(40)>
embann.c:826:5: note: Access function of PHI: {256, +, 65535}_9
embann.c:826:5: note: step: 65535,  init: 256
embann.c:826:5: note: Detected induction.
embann.c:826:5: note: === vect_analyze_scalar_cycles ===
embann.c:826:5: note: Analyze phi: .MEM_200 = PHI <.MEM_212(33), .MEM_158(35)>
embann.c:826:5: note: Analyze phi: i_208 = PHI <i_152(33), i_228(35)>
embann.c:826:5: note: Access function of PHI: {i_152, +, 1}_8
embann.c:826:5: note: step: 1,  init: i_152
embann.c:826:5: note: Detected induction.
embann.c:826:5: note: Analyze phi: ivtmp_246 = PHI <_248(33), ivtmp_247(35)>
embann.c:826:5: note: Access function of PHI: {_248, +, 4294967295}_8
embann.c:826:5: note: step: 4294967295,  init: _248
embann.c:826:5: note: Detected induction.
embann.c:826:5: note: === vect_pattern_recog ===
embann.c:826:5: note: vect_is_simple_use: operand _188
embann.c:826:5: note: def_stmt: _188 = testDouble[_189];
embann.c:826:5: note: type of def: internal
embann.c:826:5: note: === vect_analyze_data_ref_accesses ===
embann.c:826:5: note: zero step in inner loop of nest
embann.c:826:5: note: not vectorized: complicated access pattern.
embann.c:826:5: note: bad data access.

Analyzing loop at embann.c:828
embann.c:828:9: note: ===== analyze_loop_nest =====
embann.c:828:9: note: === vect_analyze_loop_form ===
embann.c:828:9: note: === get_loop_niters ===
embann.c:828:9: note: Symbolic number of iterations is _203 + 1
embann.c:828:9: note: === vect_analyze_data_refs ===
embann.c:828:9: note: got vectype for stmt: _188 = testDouble[_189];
vector(2) double
embann.c:828:9: note: got vectype for stmt: _176 = testDoubleWeight[_189];
vector(2) double
embann.c:828:9: note: got vectype for stmt: _160 = testDoubleBias[_189];
vector(2) double
embann.c:828:9: note: got vectype for stmt: testDouble[_189] = _159;
vector(2) double
embann.c:828:9: note: === vect_analyze_scalar_cycles ===
embann.c:828:9: note: Analyze phi: .MEM_200 = PHI <.MEM_212(33), .MEM_158(35)>
embann.c:828:9: note: Analyze phi: i_208 = PHI <i_152(33), i_228(35)>
embann.c:828:9: note: Access function of PHI: {i_152, +, 1}_8
embann.c:828:9: note: step: 1,  init: i_152
embann.c:828:9: note: Detected induction.
embann.c:828:9: note: Analyze phi: ivtmp_246 = PHI <_248(33), ivtmp_247(35)>
embann.c:828:9: note: Access function of PHI: {_248, +, 4294967295}_8
embann.c:828:9: note: step: 4294967295,  init: _248
embann.c:828:9: note: Detected induction.
embann.c:828:9: note: === vect_pattern_recog ===
embann.c:828:9: note: vect_is_simple_use: operand _188
embann.c:828:9: note: def_stmt: _188 = testDouble[_189];
embann.c:828:9: note: type of def: internal
embann.c:828:9: note: === vect_analyze_data_ref_accesses ===
embann.c:828:9: note: not vectorized: complicated access pattern.
embann.c:828:9: note: bad data access.
embann.c:770:6: note: ===== analyze_loop_nest =====
embann.c:770:6: note: === vect_analyze_loop_form ===
embann.c:770:6: note: === vect_analyze_loop_form ===
embann.c:770:6: note: === get_loop_niters ===
embann.c:770:6: note: Considering outer-loop vectorization.
embann.c:770:6: note: === get_loop_niters ===
embann.c:770:6: note: === vect_analyze_data_refs ===
embann.c:770:6: note: analyze in outer loop: testDouble
embann.c:770:6: note: 	outer base_address: &testDouble
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 0
	outer base alignment: 32

	outer base misalignment: 0

	outer offset alignment: 256

	outer step alignment: 256
embann.c:770:6: note: got vectype for stmt: _57 = testDouble[_56];
vector(2) double
embann.c:770:6: note: analyze in outer loop: testDoubleWeight
embann.c:770:6: note: 	outer base_address: &testDoubleWeight
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 0
	outer base alignment: 32

	outer base misalignment: 0

	outer offset alignment: 256

	outer step alignment: 256
embann.c:770:6: note: got vectype for stmt: _58 = testDoubleWeight[_56];
vector(2) double
embann.c:770:6: note: analyze in outer loop: testDoubleBias
embann.c:770:6: note: 	outer base_address: &testDoubleBias
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 0
	outer base alignment: 32

	outer base misalignment: 0

	outer offset alignment: 256

	outer step alignment: 256
embann.c:770:6: note: got vectype for stmt: _60 = testDoubleBias[_56];
vector(2) double
embann.c:770:6: note: analyze in outer loop: testDouble
embann.c:770:6: note: 	outer base_address: &testDouble
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 0
	outer base alignment: 32

	outer base misalignment: 0

	outer offset alignment: 256

	outer step alignment: 256
embann.c:770:6: note: got vectype for stmt: testDouble[_56] = _61;
vector(2) double
embann.c:770:6: note: analyze in outer loop: testDouble
embann.c:770:6: note: 	outer base_address: &testDouble
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 0
	outer base alignment: 32

	outer base misalignment: 0

	outer offset alignment: 256

	outer step alignment: 256
embann.c:770:6: note: got vectype for stmt: _145 = testDouble[_146];
vector(2) double
embann.c:770:6: note: analyze in outer loop: testDoubleWeight
embann.c:770:6: note: 	outer base_address: &testDoubleWeight
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 0
	outer base alignment: 32

	outer base misalignment: 0

	outer offset alignment: 256

	outer step alignment: 256
embann.c:770:6: note: got vectype for stmt: _144 = testDoubleWeight[_146];
vector(2) double
embann.c:770:6: note: analyze in outer loop: testDoubleBias
embann.c:770:6: note: 	outer base_address: &testDoubleBias
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 0
	outer base alignment: 32

	outer base misalignment: 0

	outer offset alignment: 256

	outer step alignment: 256
embann.c:770:6: note: got vectype for stmt: _142 = testDoubleBias[_146];
vector(2) double
embann.c:770:6: note: analyze in outer loop: testDouble
embann.c:770:6: note: 	outer base_address: &testDouble
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 0
	outer base alignment: 32

	outer base misalignment: 0

	outer offset alignment: 256

	outer step alignment: 256
embann.c:770:6: note: got vectype for stmt: testDouble[_146] = _141;
vector(2) double
embann.c:770:6: note: === vect_analyze_scalar_cycles ===
embann.c:770:6: note: Analyze phi: i_167 = PHI <0(16), i_136(48)>
embann.c:770:6: note: Access function of PHI: {0, +, 2}_4
embann.c:770:6: note: step: 2,  init: 0
embann.c:770:6: note: Detected induction.
embann.c:770:6: note: Analyze phi: .MEM_175 = PHI <.MEM_118(16), .MEM_140(48)>
embann.c:770:6: note: Analyze phi: ivtmp_135 = PHI <1(16), ivtmp_82(48)>
embann.c:770:6: note: Access function of PHI: {1, +, 2}_4
embann.c:770:6: note: step: 2,  init: 1
embann.c:770:6: note: Detected induction.
embann.c:770:6: note: Analyze phi: ivtmp_222 = PHI <49999(16), ivtmp_224(48)>
embann.c:770:6: note: Access function of PHI: {49999, +, 4294967295}_4
embann.c:770:6: note: step: 4294967295,  init: 49999
embann.c:770:6: note: Detected induction.
embann.c:770:6: note: === vect_analyze_scalar_cycles ===
embann.c:770:6: note: Analyze phi: j_168 = PHI <0(19), j_137(45)>
embann.c:770:6: note: Access function of PHI: {0, +, 1}_5
embann.c:770:6: note: step: 1,  init: 0
embann.c:770:6: note: Detected induction.
embann.c:770:6: note: Analyze phi: .MEM_174 = PHI <.MEM_175(19), .MEM_140(45)>
embann.c:770:6: note: Analyze phi: ivtmp_206 = PHI <256(19), ivtmp_205(45)>
embann.c:770:6: note: Access function of PHI: {256, +, 65535}_5
embann.c:770:6: note: step: 65535,  init: 256
embann.c:770:6: note: Detected induction.
embann.c:770:6: note: === vect_pattern_recog ===
embann.c:770:6: note: vect_is_simple_use: operand _57
embann.c:770:6: note: def_stmt: _57 = testDouble[_56];
embann.c:770:6: note: type of def: internal
embann.c:770:6: note: vect_is_simple_use: operand _145
embann.c:770:6: note: def_stmt: _145 = testDouble[_146];
embann.c:770:6: note: type of def: internal
embann.c:770:6: note: === vect_analyze_data_ref_accesses ===
embann.c:770:6: note: zero step in outer loop.
embann.c:770:6: note: zero step in outer loop.
embann.c:770:6: note: zero step in outer loop.
embann.c:770:6: note: not vectorized: complicated access pattern.
embann.c:770:6: note: bad data access.

Analyzing loop at embann.c:828
embann.c:828:9: note: ===== analyze_loop_nest =====
embann.c:828:9: note: === vect_analyze_loop_form ===
embann.c:828:9: note: === get_loop_niters ===
embann.c:828:9: note: === vect_analyze_data_refs ===
embann.c:828:9: note: got vectype for stmt: _57 = testDouble[_56];
vector(2) double
embann.c:828:9: note: got vectype for stmt: _58 = testDoubleWeight[_56];
vector(2) double
embann.c:828:9: note: got vectype for stmt: _60 = testDoubleBias[_56];
vector(2) double
embann.c:828:9: note: got vectype for stmt: testDouble[_56] = _61;
vector(2) double
embann.c:828:9: note: got vectype for stmt: _145 = testDouble[_146];
vector(2) double
embann.c:828:9: note: got vectype for stmt: _144 = testDoubleWeight[_146];
vector(2) double
embann.c:828:9: note: got vectype for stmt: _142 = testDoubleBias[_146];
vector(2) double
embann.c:828:9: note: got vectype for stmt: testDouble[_146] = _141;
vector(2) double
embann.c:828:9: note: === vect_analyze_scalar_cycles ===
embann.c:828:9: note: Analyze phi: j_168 = PHI <0(19), j_137(45)>
embann.c:828:9: note: Access function of PHI: {0, +, 1}_5
embann.c:828:9: note: step: 1,  init: 0
embann.c:828:9: note: Detected induction.
embann.c:828:9: note: Analyze phi: .MEM_174 = PHI <.MEM_175(19), .MEM_140(45)>
embann.c:828:9: note: Analyze phi: ivtmp_206 = PHI <256(19), ivtmp_205(45)>
embann.c:828:9: note: Access function of PHI: {256, +, 65535}_5
embann.c:828:9: note: step: 65535,  init: 256
embann.c:828:9: note: Detected induction.
embann.c:828:9: note: === vect_pattern_recog ===
embann.c:828:9: note: vect_is_simple_use: operand _57
embann.c:828:9: note: def_stmt: _57 = testDouble[_56];
embann.c:828:9: note: type of def: internal
embann.c:828:9: note: vect_is_simple_use: operand _145
embann.c:828:9: note: def_stmt: _145 = testDouble[_146];
embann.c:828:9: note: type of def: internal
embann.c:828:9: note: === vect_analyze_data_ref_accesses ===
embann.c:828:9: note: === vect_mark_stmts_to_be_vectorized ===
embann.c:828:9: note: init: phi relevant? j_168 = PHI <0(19), j_137(45)>
embann.c:828:9: note: init: phi relevant? .MEM_174 = PHI <.MEM_175(19), .MEM_140(45)>
embann.c:828:9: note: init: phi relevant? ivtmp_206 = PHI <256(19), ivtmp_205(45)>
embann.c:828:9: note: init: stmt relevant? _56 = (int) j_168;
embann.c:828:9: note: init: stmt relevant? _57 = testDouble[_56];
embann.c:828:9: note: init: stmt relevant? _58 = testDoubleWeight[_56];
embann.c:828:9: note: init: stmt relevant? _59 = _57 * _58;
embann.c:828:9: note: init: stmt relevant? _60 = testDoubleBias[_56];
embann.c:828:9: note: init: stmt relevant? _61 = _59 + _60;
embann.c:828:9: note: init: stmt relevant? testDouble[_56] = _61;
embann.c:828:9: note: vec_stmt_relevant_p: stmt has vdefs.
embann.c:828:9: note: mark relevant 5, live 0: testDouble[_56] = _61;
embann.c:828:9: note: init: stmt relevant? i_121 = i_167 + 1;
embann.c:828:9: note: vec_stmt_relevant_p: used out of loop.
embann.c:828:9: note: vect_is_simple_use: operand i_167
embann.c:828:9: note: def_stmt: i_167 = PHI <0(16), i_136(48)>
embann.c:828:9: note: type of def: external
embann.c:828:9: note: mark relevant 0, live 1: i_121 = i_167 + 1;
embann.c:828:9: note: init: stmt relevant? _146 = (int) j_168;
embann.c:828:9: note: init: stmt relevant? _145 = testDouble[_146];
embann.c:828:9: note: init: stmt relevant? _144 = testDoubleWeight[_146];
embann.c:828:9: note: init: stmt relevant? _143 = _145 * _144;
embann.c:828:9: note: init: stmt relevant? _142 = testDoubleBias[_146];
embann.c:828:9: note: init: stmt relevant? _141 = _143 + _142;
embann.c:828:9: note: init: stmt relevant? testDouble[_146] = _141;
embann.c:828:9: note: vec_stmt_relevant_p: stmt has vdefs.
embann.c:828:9: note: mark relevant 5, live 0: testDouble[_146] = _141;
embann.c:828:9: note: init: stmt relevant? j.152_139 = (unsigned short) j_168;
embann.c:828:9: note: init: stmt relevant? _138 = j.152_139 + 1;
embann.c:828:9: note: init: stmt relevant? j_137 = (int16_t) _138;
embann.c:828:9: note: init: stmt relevant? ivtmp_205 = ivtmp_206 - 1;
embann.c:828:9: note: init: stmt relevant? if (ivtmp_205 != 0)
embann.c:828:9: note: worklist: examine stmt: testDouble[_146] = _141;
embann.c:828:9: note: vect_is_simple_use: operand _141
embann.c:828:9: note: def_stmt: _141 = _143 + _142;
embann.c:828:9: note: type of def: internal
embann.c:828:9: note: mark relevant 5, live 0: _141 = _143 + _142;
embann.c:828:9: note: worklist: examine stmt: _141 = _143 + _142;
embann.c:828:9: note: vect_is_simple_use: operand _143
embann.c:828:9: note: def_stmt: _143 = _145 * _144;
embann.c:828:9: note: type of def: internal
embann.c:828:9: note: mark relevant 5, live 0: _143 = _145 * _144;
embann.c:828:9: note: vect_is_simple_use: operand _142
embann.c:828:9: note: def_stmt: _142 = testDoubleBias[_146];
embann.c:828:9: note: type of def: internal
embann.c:828:9: note: mark relevant 5, live 0: _142 = testDoubleBias[_146];
embann.c:828:9: note: worklist: examine stmt: _142 = testDoubleBias[_146];
embann.c:828:9: note: worklist: examine stmt: _143 = _145 * _144;
embann.c:828:9: note: vect_is_simple_use: operand _145
embann.c:828:9: note: def_stmt: _145 = testDouble[_146];
embann.c:828:9: note: type of def: internal
embann.c:828:9: note: mark relevant 5, live 0: _145 = testDouble[_146];
embann.c:828:9: note: vect_is_simple_use: operand _144
embann.c:828:9: note: def_stmt: _144 = testDoubleWeight[_146];
embann.c:828:9: note: type of def: internal
embann.c:828:9: note: mark relevant 5, live 0: _144 = testDoubleWeight[_146];
embann.c:828:9: note: worklist: examine stmt: _144 = testDoubleWeight[_146];
embann.c:828:9: note: worklist: examine stmt: _145 = testDouble[_146];
embann.c:828:9: note: worklist: examine stmt: i_121 = i_167 + 1;
embann.c:828:9: note: vect_is_simple_use: operand i_167
embann.c:828:9: note: def_stmt: i_167 = PHI <0(16), i_136(48)>
embann.c:828:9: note: type of def: external
embann.c:828:9: note: def_stmt is out of loop.
embann.c:828:9: note: worklist: examine stmt: testDouble[_56] = _61;
embann.c:828:9: note: vect_is_simple_use: operand _61
embann.c:828:9: note: def_stmt: _61 = _59 + _60;
embann.c:828:9: note: type of def: internal
embann.c:828:9: note: mark relevant 5, live 0: _61 = _59 + _60;
embann.c:828:9: note: worklist: examine stmt: _61 = _59 + _60;
embann.c:828:9: note: vect_is_simple_use: operand _59
embann.c:828:9: note: def_stmt: _59 = _57 * _58;
embann.c:828:9: note: type of def: internal
embann.c:828:9: note: mark relevant 5, live 0: _59 = _57 * _58;
embann.c:828:9: note: vect_is_simple_use: operand _60
embann.c:828:9: note: def_stmt: _60 = testDoubleBias[_56];
embann.c:828:9: note: type of def: internal
embann.c:828:9: note: mark relevant 5, live 0: _60 = testDoubleBias[_56];
embann.c:828:9: note: worklist: examine stmt: _60 = testDoubleBias[_56];
embann.c:828:9: note: worklist: examine stmt: _59 = _57 * _58;
embann.c:828:9: note: vect_is_simple_use: operand _57
embann.c:828:9: note: def_stmt: _57 = testDouble[_56];
embann.c:828:9: note: type of def: internal
embann.c:828:9: note: mark relevant 5, live 0: _57 = testDouble[_56];
embann.c:828:9: note: vect_is_simple_use: operand _58
embann.c:828:9: note: def_stmt: _58 = testDoubleWeight[_56];
embann.c:828:9: note: type of def: internal
embann.c:828:9: note: mark relevant 5, live 0: _58 = testDoubleWeight[_56];
embann.c:828:9: note: worklist: examine stmt: _58 = testDoubleWeight[_56];
embann.c:828:9: note: worklist: examine stmt: _57 = testDouble[_56];
embann.c:828:9: note: === vect_analyze_data_ref_dependences ===
embann.c:828:9: note: dependence distance  = 0.
embann.c:828:9: note: dependence distance == 0 between testDouble[_56] and testDouble[_56]
embann.c:828:9: note: dependence distance  = 0.
embann.c:828:9: note: dependence distance == 0 between testDouble[_56] and testDouble[_146]
embann.c:828:9: note: dependence distance  = 0.
embann.c:828:9: note: dependence distance == 0 between testDouble[_56] and testDouble[_146]
embann.c:828:9: note: dependence distance  = 0.
embann.c:828:9: note: dependence distance == 0 between testDouble[_56] and testDouble[_146]
embann.c:828:9: note: dependence distance  = 0.
embann.c:828:9: note: dependence distance == 0 between testDouble[_146] and testDouble[_146]
embann.c:828:9: note: === vect_determine_vectorization_factor ===
embann.c:828:9: note: ==> examining phi: j_168 = PHI <0(19), j_137(45)>
embann.c:828:9: note: ==> examining phi: .MEM_174 = PHI <.MEM_175(19), .MEM_140(45)>
embann.c:828:9: note: ==> examining phi: ivtmp_206 = PHI <256(19), ivtmp_205(45)>
embann.c:828:9: note: ==> examining statement: _56 = (int) j_168;
embann.c:828:9: note: skip.
embann.c:828:9: note: ==> examining statement: _57 = testDouble[_56];
embann.c:828:9: note: get vectype for scalar type:  double
embann.c:828:9: note: vectype: vector(2) double
embann.c:828:9: note: nunits = 2
embann.c:828:9: note: ==> examining statement: _58 = testDoubleWeight[_56];
embann.c:828:9: note: get vectype for scalar type:  double
embann.c:828:9: note: vectype: vector(2) double
embann.c:828:9: note: nunits = 2
embann.c:828:9: note: ==> examining statement: _59 = _57 * _58;
embann.c:828:9: note: get vectype for scalar type:  double
embann.c:828:9: note: vectype: vector(2) double
embann.c:828:9: note: get vectype for scalar type:  double
embann.c:828:9: note: vectype: vector(2) double
embann.c:828:9: note: nunits = 2
embann.c:828:9: note: ==> examining statement: _60 = testDoubleBias[_56];
embann.c:828:9: note: get vectype for scalar type:  double
embann.c:828:9: note: vectype: vector(2) double
embann.c:828:9: note: nunits = 2
embann.c:828:9: note: ==> examining statement: _61 = _59 + _60;
embann.c:828:9: note: get vectype for scalar type:  double
embann.c:828:9: note: vectype: vector(2) double
embann.c:828:9: note: get vectype for scalar type:  double
embann.c:828:9: note: vectype: vector(2) double
embann.c:828:9: note: nunits = 2
embann.c:828:9: note: ==> examining statement: testDouble[_56] = _61;
embann.c:828:9: note: get vectype for scalar type:  double
embann.c:828:9: note: vectype: vector(2) double
embann.c:828:9: note: nunits = 2
embann.c:828:9: note: ==> examining statement: i_121 = i_167 + 1;
embann.c:828:9: note: get vectype for scalar type:  int32_t
embann.c:828:9: note: vectype: vector(4) int
embann.c:828:9: note: get vectype for scalar type:  int32_t
embann.c:828:9: note: vectype: vector(4) int
embann.c:828:9: note: nunits = 4
embann.c:828:9: note: ==> examining statement: _146 = (int) j_168;
embann.c:828:9: note: skip.
embann.c:828:9: note: ==> examining statement: _145 = testDouble[_146];
embann.c:828:9: note: get vectype for scalar type:  double
embann.c:828:9: note: vectype: vector(2) double
embann.c:828:9: note: nunits = 2
embann.c:828:9: note: ==> examining statement: _144 = testDoubleWeight[_146];
embann.c:828:9: note: get vectype for scalar type:  double
embann.c:828:9: note: vectype: vector(2) double
embann.c:828:9: note: nunits = 2
embann.c:828:9: note: ==> examining statement: _143 = _145 * _144;
embann.c:828:9: note: get vectype for scalar type:  double
embann.c:828:9: note: vectype: vector(2) double
embann.c:828:9: note: get vectype for scalar type:  double
embann.c:828:9: note: vectype: vector(2) double
embann.c:828:9: note: nunits = 2
embann.c:828:9: note: ==> examining statement: _142 = testDoubleBias[_146];
embann.c:828:9: note: get vectype for scalar type:  double
embann.c:828:9: note: vectype: vector(2) double
embann.c:828:9: note: nunits = 2
embann.c:828:9: note: ==> examining statement: _141 = _143 + _142;
embann.c:828:9: note: get vectype for scalar type:  double
embann.c:828:9: note: vectype: vector(2) double
embann.c:828:9: note: get vectype for scalar type:  double
embann.c:828:9: note: vectype: vector(2) double
embann.c:828:9: note: nunits = 2
embann.c:828:9: note: ==> examining statement: testDouble[_146] = _141;
embann.c:828:9: note: get vectype for scalar type:  double
embann.c:828:9: note: vectype: vector(2) double
embann.c:828:9: note: nunits = 2
embann.c:828:9: note: ==> examining statement: j.152_139 = (unsigned short) j_168;
embann.c:828:9: note: skip.
embann.c:828:9: note: ==> examining statement: _138 = j.152_139 + 1;
embann.c:828:9: note: skip.
embann.c:828:9: note: ==> examining statement: j_137 = (int16_t) _138;
embann.c:828:9: note: skip.
embann.c:828:9: note: ==> examining statement: ivtmp_205 = ivtmp_206 - 1;
embann.c:828:9: note: skip.
embann.c:828:9: note: ==> examining statement: if (ivtmp_205 != 0)
embann.c:828:9: note: skip.
embann.c:828:9: note: vectorization factor = 4
embann.c:828:9: note: === vect_analyze_slp ===
embann.c:828:9: note: === vect_make_slp_decision ===
embann.c:828:9: note: vectorization_factor = 4, niters = 256
embann.c:828:9: note: === vect_analyze_data_refs_alignment ===
embann.c:828:9: note: accesses have the same alignment: testDouble[_56] and testDouble[_56]
embann.c:828:9: note: accesses have the same alignment: testDouble[_56] and testDouble[_146]
embann.c:828:9: note: accesses have the same alignment: testDouble[_56] and testDouble[_146]
embann.c:828:9: note: accesses have the same alignment: testDoubleWeight[_56] and testDoubleWeight[_146]
embann.c:828:9: note: accesses have the same alignment: testDoubleBias[_56] and testDoubleBias[_146]
embann.c:828:9: note: accesses have the same alignment: testDouble[_56] and testDouble[_146]
embann.c:828:9: note: accesses have the same alignment: testDouble[_56] and testDouble[_146]
embann.c:828:9: note: accesses have the same alignment: testDouble[_146] and testDouble[_146]
embann.c:828:9: note: recording new base alignment for &testDouble
embann.c:828:9: note:   alignment:    32
embann.c:828:9: note:   misalignment: 0
embann.c:828:9: note:   based on:     _57 = testDouble[_56];
embann.c:828:9: note: recording new base alignment for &testDoubleWeight
embann.c:828:9: note:   alignment:    32
embann.c:828:9: note:   misalignment: 0
embann.c:828:9: note:   based on:     _58 = testDoubleWeight[_56];
embann.c:828:9: note: recording new base alignment for &testDoubleBias
embann.c:828:9: note:   alignment:    32
embann.c:828:9: note:   misalignment: 0
embann.c:828:9: note:   based on:     _60 = testDoubleBias[_56];
embann.c:828:9: note: vect_compute_data_ref_alignment:
embann.c:828:9: note: misalign = 0 bytes of ref testDouble[_56]
embann.c:828:9: note: vect_compute_data_ref_alignment:
embann.c:828:9: note: misalign = 0 bytes of ref testDoubleWeight[_56]
embann.c:828:9: note: vect_compute_data_ref_alignment:
embann.c:828:9: note: misalign = 0 bytes of ref testDoubleBias[_56]
embann.c:828:9: note: vect_compute_data_ref_alignment:
embann.c:828:9: note: misalign = 0 bytes of ref testDouble[_56]
embann.c:828:9: note: vect_compute_data_ref_alignment:
embann.c:828:9: note: misalign = 0 bytes of ref testDouble[_146]
embann.c:828:9: note: vect_compute_data_ref_alignment:
embann.c:828:9: note: misalign = 0 bytes of ref testDoubleWeight[_146]
embann.c:828:9: note: vect_compute_data_ref_alignment:
embann.c:828:9: note: misalign = 0 bytes of ref testDoubleBias[_146]
embann.c:828:9: note: vect_compute_data_ref_alignment:
embann.c:828:9: note: misalign = 0 bytes of ref testDouble[_146]
embann.c:828:9: note: === vect_prune_runtime_alias_test_list ===
embann.c:828:9: note: === vect_enhance_data_refs_alignment ===
embann.c:828:9: note: vect_can_advance_ivs_p:
embann.c:828:9: note: Analyze phi: j_168 = PHI <0(19), j_137(45)>
embann.c:828:9: note: Analyze phi: .MEM_174 = PHI <.MEM_175(19), .MEM_140(45)>
embann.c:828:9: note: reduc or virtual phi. skip.
embann.c:828:9: note: Analyze phi: ivtmp_206 = PHI <256(19), ivtmp_205(45)>
embann.c:828:9: note: vect_model_load_cost: aligned.
embann.c:828:9: note: vect_get_data_access_cost: inside_cost = 24, outside_cost = 0.
embann.c:828:9: note: vect_model_load_cost: aligned.
embann.c:828:9: note: vect_get_data_access_cost: inside_cost = 48, outside_cost = 0.
embann.c:828:9: note: vect_model_load_cost: aligned.
embann.c:828:9: note: vect_get_data_access_cost: inside_cost = 72, outside_cost = 0.
embann.c:828:9: note: vect_model_store_cost: aligned.
embann.c:828:9: note: vect_get_data_access_cost: inside_cost = 104, outside_cost = 0.
embann.c:828:9: note: vect_model_load_cost: aligned.
embann.c:828:9: note: vect_get_data_access_cost: inside_cost = 128, outside_cost = 0.
embann.c:828:9: note: vect_model_load_cost: aligned.
embann.c:828:9: note: vect_get_data_access_cost: inside_cost = 152, outside_cost = 0.
embann.c:828:9: note: vect_model_load_cost: aligned.
embann.c:828:9: note: vect_get_data_access_cost: inside_cost = 176, outside_cost = 0.
embann.c:828:9: note: vect_model_store_cost: aligned.
embann.c:828:9: note: vect_get_data_access_cost: inside_cost = 208, outside_cost = 0.
embann.c:828:9: note: === vect_analyze_loop_operations ===
embann.c:828:9: note: examining phi: j_168 = PHI <0(19), j_137(45)>
embann.c:828:9: note: examining phi: .MEM_174 = PHI <.MEM_175(19), .MEM_140(45)>
embann.c:828:9: note: examining phi: ivtmp_206 = PHI <256(19), ivtmp_205(45)>
embann.c:828:9: note: ==> examining statement: _56 = (int) j_168;
embann.c:828:9: note: irrelevant.
embann.c:828:9: note: ==> examining statement: _57 = testDouble[_56];
embann.c:828:9: note: num. args = 4 (not unary/binary/ternary op).
embann.c:828:9: note: vect_is_simple_use: operand testDouble[_56]
embann.c:828:9: note: not ssa-name.
embann.c:828:9: note: use not simple.
embann.c:828:9: note: vect_model_load_cost: aligned.
embann.c:828:9: note: vect_model_load_cost: inside_cost = 24, prologue_cost = 0 .
embann.c:828:9: note: ==> examining statement: _58 = testDoubleWeight[_56];
embann.c:828:9: note: num. args = 4 (not unary/binary/ternary op).
embann.c:828:9: note: vect_is_simple_use: operand testDoubleWeight[_56]
embann.c:828:9: note: not ssa-name.
embann.c:828:9: note: use not simple.
embann.c:828:9: note: vect_model_load_cost: aligned.
embann.c:828:9: note: vect_model_load_cost: inside_cost = 24, prologue_cost = 0 .
embann.c:828:9: note: ==> examining statement: _59 = _57 * _58;
embann.c:828:9: note: vect_is_simple_use: operand _57
embann.c:828:9: note: def_stmt: _57 = testDouble[_56];
embann.c:828:9: note: type of def: internal
embann.c:828:9: note: vect_is_simple_use: operand _58
embann.c:828:9: note: def_stmt: _58 = testDoubleWeight[_56];
embann.c:828:9: note: type of def: internal
embann.c:828:9: note: === vectorizable_operation ===
embann.c:828:9: note: vect_model_simple_cost: inside_cost = 32, prologue_cost = 0 .
embann.c:828:9: note: ==> examining statement: _60 = testDoubleBias[_56];
embann.c:828:9: note: num. args = 4 (not unary/binary/ternary op).
embann.c:828:9: note: vect_is_simple_use: operand testDoubleBias[_56]
embann.c:828:9: note: not ssa-name.
embann.c:828:9: note: use not simple.
embann.c:828:9: note: vect_model_load_cost: aligned.
embann.c:828:9: note: vect_model_load_cost: inside_cost = 24, prologue_cost = 0 .
embann.c:828:9: note: ==> examining statement: _61 = _59 + _60;
embann.c:828:9: note: vect_is_simple_use: operand _59
embann.c:828:9: note: def_stmt: _59 = _57 * _58;
embann.c:828:9: note: type of def: internal
embann.c:828:9: note: vect_is_simple_use: operand _60
embann.c:828:9: note: def_stmt: _60 = testDoubleBias[_56];
embann.c:828:9: note: type of def: internal
embann.c:828:9: note: === vectorizable_operation ===
embann.c:828:9: note: vect_model_simple_cost: inside_cost = 24, prologue_cost = 0 .
embann.c:828:9: note: ==> examining statement: testDouble[_56] = _61;
embann.c:828:9: note: vect_is_simple_use: operand _61
embann.c:828:9: note: def_stmt: _61 = _59 + _60;
embann.c:828:9: note: type of def: internal
embann.c:828:9: note: vect_model_store_cost: aligned.
embann.c:828:9: note: vect_model_store_cost: inside_cost = 32, prologue_cost = 0 .
embann.c:828:9: note: ==> examining statement: i_121 = i_167 + 1;
embann.c:828:9: note: vect_is_simple_use: operand i_167
embann.c:828:9: note: def_stmt: i_167 = PHI <0(16), i_136(48)>
embann.c:828:9: note: type of def: external
embann.c:828:9: note: statement is simple and uses invariant.  Leaving in place.
embann.c:828:9: note: ==> examining statement: _146 = (int) j_168;
embann.c:828:9: note: irrelevant.
embann.c:828:9: note: ==> examining statement: _145 = testDouble[_146];
embann.c:828:9: note: num. args = 4 (not unary/binary/ternary op).
embann.c:828:9: note: vect_is_simple_use: operand testDouble[_146]
embann.c:828:9: note: not ssa-name.
embann.c:828:9: note: use not simple.
embann.c:828:9: note: vect_model_load_cost: aligned.
embann.c:828:9: note: vect_model_load_cost: inside_cost = 24, prologue_cost = 0 .
embann.c:828:9: note: ==> examining statement: _144 = testDoubleWeight[_146];
embann.c:828:9: note: num. args = 4 (not unary/binary/ternary op).
embann.c:828:9: note: vect_is_simple_use: operand testDoubleWeight[_146]
embann.c:828:9: note: not ssa-name.
embann.c:828:9: note: use not simple.
embann.c:828:9: note: vect_model_load_cost: aligned.
embann.c:828:9: note: vect_model_load_cost: inside_cost = 24, prologue_cost = 0 .
embann.c:828:9: note: ==> examining statement: _143 = _145 * _144;
embann.c:828:9: note: vect_is_simple_use: operand _145
embann.c:828:9: note: def_stmt: _145 = testDouble[_146];
embann.c:828:9: note: type of def: internal
embann.c:828:9: note: vect_is_simple_use: operand _144
embann.c:828:9: note: def_stmt: _144 = testDoubleWeight[_146];
embann.c:828:9: note: type of def: internal
embann.c:828:9: note: === vectorizable_operation ===
embann.c:828:9: note: vect_model_simple_cost: inside_cost = 32, prologue_cost = 0 .
embann.c:828:9: note: ==> examining statement: _142 = testDoubleBias[_146];
embann.c:828:9: note: num. args = 4 (not unary/binary/ternary op).
embann.c:828:9: note: vect_is_simple_use: operand testDoubleBias[_146]
embann.c:828:9: note: not ssa-name.
embann.c:828:9: note: use not simple.
embann.c:828:9: note: vect_model_load_cost: aligned.
embann.c:828:9: note: vect_model_load_cost: inside_cost = 24, prologue_cost = 0 .
embann.c:828:9: note: ==> examining statement: _141 = _143 + _142;
embann.c:828:9: note: vect_is_simple_use: operand _143
embann.c:828:9: note: def_stmt: _143 = _145 * _144;
embann.c:828:9: note: type of def: internal
embann.c:828:9: note: vect_is_simple_use: operand _142
embann.c:828:9: note: def_stmt: _142 = testDoubleBias[_146];
embann.c:828:9: note: type of def: internal
embann.c:828:9: note: === vectorizable_operation ===
embann.c:828:9: note: vect_model_simple_cost: inside_cost = 24, prologue_cost = 0 .
embann.c:828:9: note: ==> examining statement: testDouble[_146] = _141;
embann.c:828:9: note: vect_is_simple_use: operand _141
embann.c:828:9: note: def_stmt: _141 = _143 + _142;
embann.c:828:9: note: type of def: internal
embann.c:828:9: note: vect_model_store_cost: aligned.
embann.c:828:9: note: vect_model_store_cost: inside_cost = 32, prologue_cost = 0 .
embann.c:828:9: note: ==> examining statement: j.152_139 = (unsigned short) j_168;
embann.c:828:9: note: irrelevant.
embann.c:828:9: note: ==> examining statement: _138 = j.152_139 + 1;
embann.c:828:9: note: irrelevant.
embann.c:828:9: note: ==> examining statement: j_137 = (int16_t) _138;
embann.c:828:9: note: irrelevant.
embann.c:828:9: note: ==> examining statement: ivtmp_205 = ivtmp_206 - 1;
embann.c:828:9: note: irrelevant.
embann.c:828:9: note: ==> examining statement: if (ivtmp_205 != 0)
embann.c:828:9: note: irrelevant.
embann.c:828:9: note: not using a fully-masked loop.
embann.c:828:9: note: Cost model analysis: 
  Vector inside of loop cost: 320
  Vector prologue cost: 0
  Vector epilogue cost: 0
  Scalar iteration cost: 144
  Scalar outside cost: 0
  Vector outside cost: 0
  prologue iterations: 0
  epilogue iterations: 0
  Calculated minimum iters for profitability: 0
embann.c:828:9: note:   Runtime profitability threshold = 4
embann.c:828:9: note:   Static estimate profitability threshold = 4
embann.c:828:9: note: loop vectorized
embann.c:828:9: note: === vec_transform_loop ===
embann.c:828:9: note: ------>vectorizing phi: j_168 = PHI <j_137(45), 0(84)>
embann.c:828:9: note: ------>vectorizing phi: .MEM_174 = PHI <.MEM_140(45), .MEM_175(84)>
embann.c:828:9: note: ------>vectorizing phi: ivtmp_206 = PHI <ivtmp_205(45), 256(84)>
embann.c:828:9: note: ------>vectorizing statement: _56 = (int) j_168;
embann.c:828:9: note: ------>vectorizing statement: _57 = testDouble[_56];
embann.c:828:9: note: multiple-types.
embann.c:828:9: note: transform statement.
embann.c:828:9: note: transform load. ncopies = 2
embann.c:828:9: note: create vector_type-pointer variable to type: vector(2) double  vectorizing an array ref: testDouble
embann.c:828:9: note: created &testDouble
embann.c:828:9: note: add new stmt: vect__57.494_219 = MEM[(double *)vectp_testDouble.492_221];
embann.c:828:9: note: add new stmt: vectp_testDouble.492_220 = vectp_testDouble.492_221 + 16;
embann.c:828:9: note: add new stmt: vect__57.495_63 = MEM[(double *)vectp_testDouble.492_220];
embann.c:828:9: note: ------>vectorizing statement: _58 = testDoubleWeight[_56];
embann.c:828:9: note: multiple-types.
embann.c:828:9: note: transform statement.
embann.c:828:9: note: transform load. ncopies = 2
embann.c:828:9: note: create vector_type-pointer variable to type: vector(2) double  vectorizing an array ref: testDoubleWeight
embann.c:828:9: note: created &testDoubleWeight
embann.c:828:9: note: add new stmt: vect__58.498_178 = MEM[(double *)vectp_testDoubleWeight.496_62];
embann.c:828:9: note: add new stmt: vectp_testDoubleWeight.496_211 = vectp_testDoubleWeight.496_62 + 16;
embann.c:828:9: note: add new stmt: vect__58.499_69 = MEM[(double *)vectp_testDoubleWeight.496_211];
embann.c:828:9: note: ------>vectorizing statement: _59 = _57 * _58;
embann.c:828:9: note: multiple-types.
embann.c:828:9: note: transform statement.
embann.c:828:9: note: vect_is_simple_use: operand _57
embann.c:828:9: note: def_stmt: _57 = testDouble[_56];
embann.c:828:9: note: type of def: internal
embann.c:828:9: note: vect_is_simple_use: operand _58
embann.c:828:9: note: def_stmt: _58 = testDoubleWeight[_56];
embann.c:828:9: note: type of def: internal
embann.c:828:9: note: transform binary/unary operation.
embann.c:828:9: note: vect_get_vec_def_for_operand: _57
embann.c:828:9: note: vect_is_simple_use: operand _57
embann.c:828:9: note: def_stmt: _57 = testDouble[_56];
embann.c:828:9: note: type of def: internal
embann.c:828:9: note:   def_stmt =  _57 = testDouble[_56];
embann.c:828:9: note: vect_get_vec_def_for_operand: _58
embann.c:828:9: note: vect_is_simple_use: operand _58
embann.c:828:9: note: def_stmt: _58 = testDoubleWeight[_56];
embann.c:828:9: note: type of def: internal
embann.c:828:9: note:   def_stmt =  _58 = testDoubleWeight[_56];
embann.c:828:9: note: add new stmt: vect__59.500_209 = vect__57.494_219 * vect__58.498_178;
embann.c:828:9: note: add new stmt: vect__59.500_210 = vect__57.495_63 * vect__58.499_69;
embann.c:828:9: note: ------>vectorizing statement: _60 = testDoubleBias[_56];
embann.c:828:9: note: multiple-types.
embann.c:828:9: note: transform statement.
embann.c:828:9: note: transform load. ncopies = 2
embann.c:828:9: note: create vector_type-pointer variable to type: vector(2) double  vectorizing an array ref: testDoubleBias
embann.c:828:9: note: created &testDoubleBias
embann.c:828:9: note: add new stmt: vect__60.503_78 = MEM[(double *)vectp_testDoubleBias.501_36];
embann.c:828:9: note: add new stmt: vectp_testDoubleBias.501_80 = vectp_testDoubleBias.501_36 + 16;
embann.c:828:9: note: add new stmt: vect__60.504_157 = MEM[(double *)vectp_testDoubleBias.501_80];
embann.c:828:9: note: ------>vectorizing statement: _61 = _59 + _60;
embann.c:828:9: note: multiple-types.
embann.c:828:9: note: transform statement.
embann.c:828:9: note: vect_is_simple_use: operand _59
embann.c:828:9: note: def_stmt: _59 = _57 * _58;
embann.c:828:9: note: type of def: internal
embann.c:828:9: note: vect_is_simple_use: operand _60
embann.c:828:9: note: def_stmt: _60 = testDoubleBias[_56];
embann.c:828:9: note: type of def: internal
embann.c:828:9: note: transform binary/unary operation.
embann.c:828:9: note: vect_get_vec_def_for_operand: _59
embann.c:828:9: note: vect_is_simple_use: operand _59
embann.c:828:9: note: def_stmt: _59 = _57 * _58;
embann.c:828:9: note: type of def: internal
embann.c:828:9: note:   def_stmt =  _59 = _57 * _58;
embann.c:828:9: note: vect_get_vec_def_for_operand: _60
embann.c:828:9: note: vect_is_simple_use: operand _60
embann.c:828:9: note: def_stmt: _60 = testDoubleBias[_56];
embann.c:828:9: note: type of def: internal
embann.c:828:9: note:   def_stmt =  _60 = testDoubleBias[_56];
embann.c:828:9: note: add new stmt: vect__61.505_156 = vect__59.500_209 + vect__60.503_78;
embann.c:828:9: note: add new stmt: vect__61.505_155 = vect__59.500_210 + vect__60.504_157;
embann.c:828:9: note: ------>vectorizing statement: testDouble[_56] = _61;
embann.c:828:9: note: multiple-types.
embann.c:828:9: note: transform statement.
embann.c:828:9: note: vect_is_simple_use: operand _61
embann.c:828:9: note: def_stmt: _61 = _59 + _60;
embann.c:828:9: note: type of def: internal
embann.c:828:9: note: transform store. ncopies = 2
embann.c:828:9: note: vect_get_vec_def_for_operand: _61
embann.c:828:9: note: vect_is_simple_use: operand _61
embann.c:828:9: note: def_stmt: _61 = _59 + _60;
embann.c:828:9: note: type of def: internal
embann.c:828:9: note:   def_stmt =  _61 = _59 + _60;
embann.c:828:9: note: create vector_type-pointer variable to type: vector(2) double  vectorizing an array ref: testDouble
embann.c:828:9: note: created &testDouble
embann.c:828:9: note: add new stmt: MEM[(double *)vectp_testDouble.506_154] = vect__61.505_156;
embann.c:828:9: note: vect_is_simple_use: operand vect__61.505_156
embann.c:828:9: note: def_stmt: vect__61.505_156 = vect__59.500_209 + vect__60.503_78;
embann.c:828:9: note: type of def: internal
embann.c:828:9: note: add new stmt: vectp_testDouble.506_201 = vectp_testDouble.506_154 + 16;
embann.c:828:9: note: add new stmt: MEM[(double *)vectp_testDouble.506_201] = vect__61.505_155;
embann.c:828:9: note: ------>vectorizing statement: i_121 = i_167 + 1;
embann.c:828:9: note: transform statement.
embann.c:828:9: note: vect_is_simple_use: operand i_167
embann.c:828:9: note: def_stmt: i_167 = PHI <0(16), i_136(48)>
embann.c:828:9: note: type of def: external
embann.c:828:9: note: statement is simple and uses invariant.  Leaving in place.
embann.c:828:9: note: ------>vectorizing statement: _146 = (int) j_168;
embann.c:828:9: note: ------>vectorizing statement: _145 = testDouble[_146];
embann.c:828:9: note: multiple-types.
embann.c:828:9: note: transform statement.
embann.c:828:9: note: transform load. ncopies = 2
embann.c:828:9: note: create vector_type-pointer variable to type: vector(2) double  vectorizing an array ref: testDouble
embann.c:828:9: note: created &testDouble
embann.c:828:9: note: add new stmt: vect__145.510_277 = MEM[(double *)vectp_testDouble.508_275];
embann.c:828:9: note: add new stmt: vectp_testDouble.508_278 = vectp_testDouble.508_275 + 16;
embann.c:828:9: note: add new stmt: vect__145.511_279 = MEM[(double *)vectp_testDouble.508_278];
embann.c:828:9: note: ------>vectorizing statement: _144 = testDoubleWeight[_146];
embann.c:828:9: note: multiple-types.
embann.c:828:9: note: transform statement.
embann.c:828:9: note: transform load. ncopies = 2
embann.c:828:9: note: create vector_type-pointer variable to type: vector(2) double  vectorizing an array ref: testDoubleWeight
embann.c:828:9: note: created &testDoubleWeight
embann.c:828:9: note: add new stmt: vect__144.514_282 = MEM[(double *)vectp_testDoubleWeight.512_280];
embann.c:828:9: note: add new stmt: vectp_testDoubleWeight.512_283 = vectp_testDoubleWeight.512_280 + 16;
embann.c:828:9: note: add new stmt: vect__144.515_284 = MEM[(double *)vectp_testDoubleWeight.512_283];
embann.c:828:9: note: ------>vectorizing statement: _143 = _145 * _144;
embann.c:828:9: note: multiple-types.
embann.c:828:9: note: transform statement.
embann.c:828:9: note: vect_is_simple_use: operand _145
embann.c:828:9: note: def_stmt: _145 = testDouble[_146];
embann.c:828:9: note: type of def: internal
embann.c:828:9: note: vect_is_simple_use: operand _144
embann.c:828:9: note: def_stmt: _144 = testDoubleWeight[_146];
embann.c:828:9: note: type of def: internal
embann.c:828:9: note: transform binary/unary operation.
embann.c:828:9: note: vect_get_vec_def_for_operand: _145
embann.c:828:9: note: vect_is_simple_use: operand _145
embann.c:828:9: note: def_stmt: _145 = testDouble[_146];
embann.c:828:9: note: type of def: internal
embann.c:828:9: note:   def_stmt =  _145 = testDouble[_146];
embann.c:828:9: note: vect_get_vec_def_for_operand: _144
embann.c:828:9: note: vect_is_simple_use: operand _144
embann.c:828:9: note: def_stmt: _144 = testDoubleWeight[_146];
embann.c:828:9: note: type of def: internal
embann.c:828:9: note:   def_stmt =  _144 = testDoubleWeight[_146];
embann.c:828:9: note: add new stmt: vect__143.516_285 = vect__145.510_277 * vect__144.514_282;
embann.c:828:9: note: add new stmt: vect__143.516_286 = vect__145.511_279 * vect__144.515_284;
embann.c:828:9: note: ------>vectorizing statement: _142 = testDoubleBias[_146];
embann.c:828:9: note: multiple-types.
embann.c:828:9: note: transform statement.
embann.c:828:9: note: transform load. ncopies = 2
embann.c:828:9: note: create vector_type-pointer variable to type: vector(2) double  vectorizing an array ref: testDoubleBias
embann.c:828:9: note: created &testDoubleBias
embann.c:828:9: note: add new stmt: vect__142.519_289 = MEM[(double *)vectp_testDoubleBias.517_287];
embann.c:828:9: note: add new stmt: vectp_testDoubleBias.517_290 = vectp_testDoubleBias.517_287 + 16;
embann.c:828:9: note: add new stmt: vect__142.520_291 = MEM[(double *)vectp_testDoubleBias.517_290];
embann.c:828:9: note: ------>vectorizing statement: _141 = _143 + _142;
embann.c:828:9: note: multiple-types.
embann.c:828:9: note: transform statement.
embann.c:828:9: note: vect_is_simple_use: operand _143
embann.c:828:9: note: def_stmt: _143 = _145 * _144;
embann.c:828:9: note: type of def: internal
embann.c:828:9: note: vect_is_simple_use: operand _142
embann.c:828:9: note: def_stmt: _142 = testDoubleBias[_146];
embann.c:828:9: note: type of def: internal
embann.c:828:9: note: transform binary/unary operation.
embann.c:828:9: note: vect_get_vec_def_for_operand: _143
embann.c:828:9: note: vect_is_simple_use: operand _143
embann.c:828:9: note: def_stmt: _143 = _145 * _144;
embann.c:828:9: note: type of def: internal
embann.c:828:9: note:   def_stmt =  _143 = _145 * _144;
embann.c:828:9: note: vect_get_vec_def_for_operand: _142
embann.c:828:9: note: vect_is_simple_use: operand _142
embann.c:828:9: note: def_stmt: _142 = testDoubleBias[_146];
embann.c:828:9: note: type of def: internal
embann.c:828:9: note:   def_stmt =  _142 = testDoubleBias[_146];
embann.c:828:9: note: add new stmt: vect__141.521_292 = vect__143.516_285 + vect__142.519_289;
embann.c:828:9: note: add new stmt: vect__141.521_293 = vect__143.516_286 + vect__142.520_291;
embann.c:828:9: note: ------>vectorizing statement: testDouble[_146] = _141;
embann.c:828:9: note: multiple-types.
embann.c:828:9: note: transform statement.
embann.c:828:9: note: vect_is_simple_use: operand _141
embann.c:828:9: note: def_stmt: _141 = _143 + _142;
embann.c:828:9: note: type of def: internal
embann.c:828:9: note: transform store. ncopies = 2
embann.c:828:9: note: vect_get_vec_def_for_operand: _141
embann.c:828:9: note: vect_is_simple_use: operand _141
embann.c:828:9: note: def_stmt: _141 = _143 + _142;
embann.c:828:9: note: type of def: internal
embann.c:828:9: note:   def_stmt =  _141 = _143 + _142;
embann.c:828:9: note: create vector_type-pointer variable to type: vector(2) double  vectorizing an array ref: testDouble
embann.c:828:9: note: created &testDouble
embann.c:828:9: note: add new stmt: MEM[(double *)vectp_testDouble.522_294] = vect__141.521_292;
embann.c:828:9: note: vect_is_simple_use: operand vect__141.521_292
embann.c:828:9: note: def_stmt: vect__141.521_292 = vect__143.516_285 + vect__142.519_289;
embann.c:828:9: note: type of def: internal
embann.c:828:9: note: add new stmt: vectp_testDouble.522_297 = vectp_testDouble.522_294 + 16;
embann.c:828:9: note: add new stmt: MEM[(double *)vectp_testDouble.522_297] = vect__141.521_293;
embann.c:828:9: note: ------>vectorizing statement: j.152_139 = (unsigned short) j_168;
embann.c:828:9: note: ------>vectorizing statement: _138 = j.152_139 + 1;
embann.c:828:9: note: ------>vectorizing statement: j_137 = (int16_t) _138;
embann.c:828:9: note: ------>vectorizing statement: ivtmp_205 = ivtmp_206 - 1;
embann.c:828:9: note: ------>vectorizing statement: vectp_testDouble.492_218 = vectp_testDouble.492_220 + 16;
embann.c:828:9: note: ------>vectorizing statement: vectp_testDoubleWeight.496_41 = vectp_testDoubleWeight.496_211 + 16;
embann.c:828:9: note: ------>vectorizing statement: vectp_testDoubleBias.501_35 = vectp_testDoubleBias.501_80 + 16;
embann.c:828:9: note: ------>vectorizing statement: vectp_testDouble.506_151 = vectp_testDouble.506_201 + 16;
embann.c:828:9: note: ------>vectorizing statement: vectp_testDouble.508_276 = vectp_testDouble.508_278 + 16;
embann.c:828:9: note: ------>vectorizing statement: vectp_testDoubleWeight.512_281 = vectp_testDoubleWeight.512_283 + 16;
embann.c:828:9: note: ------>vectorizing statement: vectp_testDoubleBias.517_288 = vectp_testDoubleBias.517_290 + 16;
embann.c:828:9: note: ------>vectorizing statement: vectp_testDouble.522_295 = vectp_testDouble.522_297 + 16;
embann.c:828:9: note: ------>vectorizing statement: if (ivtmp_205 != 0)
embann.c:828:9: note: New loop exit condition: if (ivtmp_300 < 64)
embann.c:828:9: note: LOOP VECTORIZED


Analyzing loop at embann.c:812
embann.c:812:5: note: ===== analyze_loop_nest =====
embann.c:812:5: note: === vect_analyze_loop_form ===
embann.c:812:5: note: === vect_analyze_loop_form ===
embann.c:812:5: note: === get_loop_niters ===
embann.c:812:5: note: Considering outer-loop vectorization.
embann.c:812:5: note: === get_loop_niters ===
embann.c:812:5: note: === vect_analyze_data_refs ===
embann.c:812:5: note: analyze in outer loop: *(&testFloat + (sizetype) j_253 * 4)
embann.c:812:5: note: 	outer base_address: &testFloat
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 4
	outer base alignment: 32

	outer base misalignment: 0

	outer offset alignment: 256

	outer step alignment: 4
embann.c:812:5: note: got vectype for stmt: _75 = testFloat[_76];
vector(4) float
embann.c:812:5: note: analyze in outer loop: *(&testFloatWeight + (sizetype) j_253 * 4)
embann.c:812:5: note: 	outer base_address: &testFloatWeight
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 4
	outer base alignment: 32

	outer base misalignment: 0

	outer offset alignment: 256

	outer step alignment: 4
embann.c:812:5: note: got vectype for stmt: _74 = testFloatWeight[_76];
vector(4) float
embann.c:812:5: note: analyze in outer loop: *(&testFloatBias + (sizetype) j_253 * 4)
embann.c:812:5: note: 	outer base_address: &testFloatBias
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 4
	outer base alignment: 32

	outer base misalignment: 0

	outer offset alignment: 256

	outer step alignment: 4
embann.c:812:5: note: got vectype for stmt: _72 = testFloatBias[_76];
vector(4) float
embann.c:812:5: note: analyze in outer loop: *(&testFloat + (sizetype) j_253 * 4)
embann.c:812:5: note: 	outer base_address: &testFloat
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 4
	outer base alignment: 32

	outer base misalignment: 0

	outer offset alignment: 256

	outer step alignment: 4
embann.c:812:5: note: got vectype for stmt: testFloat[_76] = _71;
vector(4) float
embann.c:812:5: note: === vect_analyze_scalar_cycles ===
embann.c:812:5: note: Analyze phi: .MEM_79 = PHI <.MEM_70(54), .MEM_185(57)>
embann.c:812:5: note: Analyze phi: j_253 = PHI <j_254(54), 0(57)>
embann.c:812:5: note: Access function of PHI: {0, +, 1}_12
embann.c:812:5: note: step: 1,  init: 0
embann.c:812:5: note: Detected induction.
embann.c:812:5: note: Analyze phi: ivtmp_255 = PHI <ivtmp_256(54), 256(57)>
embann.c:812:5: note: Access function of PHI: {256, +, 65535}_12
embann.c:812:5: note: step: 65535,  init: 256
embann.c:812:5: note: Detected induction.
embann.c:812:5: note: Analyze phi: ivtmp_257 = PHI <ivtmp_258(54), 256(57)>
embann.c:812:5: note: Access function of PHI: {256, +, 65535}_12
embann.c:812:5: note: step: 65535,  init: 256
embann.c:812:5: note: Detected induction.
embann.c:812:5: note: === vect_analyze_scalar_cycles ===
embann.c:812:5: note: Analyze phi: .MEM_77 = PHI <.MEM_79(50), .MEM_70(52)>
embann.c:812:5: note: Analyze phi: i_251 = PHI <i_207(50), i_252(52)>
embann.c:812:5: note: Access function of PHI: {i_207, +, 1}_11
embann.c:812:5: note: step: 1,  init: i_207
embann.c:812:5: note: Detected induction.
embann.c:812:5: note: Analyze phi: ivtmp_259 = PHI <_261(50), ivtmp_260(52)>
embann.c:812:5: note: Access function of PHI: {_261, +, 4294967295}_11
embann.c:812:5: note: step: 4294967295,  init: _261
embann.c:812:5: note: Detected induction.
embann.c:812:5: note: === vect_pattern_recog ===
embann.c:812:5: note: vect_is_simple_use: operand _75
embann.c:812:5: note: def_stmt: _75 = testFloat[_76];
embann.c:812:5: note: type of def: internal
embann.c:812:5: note: === vect_analyze_data_ref_accesses ===
embann.c:812:5: note: zero step in inner loop of nest
embann.c:812:5: note: not vectorized: complicated access pattern.
embann.c:812:5: note: bad data access.

Analyzing loop at embann.c:814
embann.c:814:9: note: ===== analyze_loop_nest =====
embann.c:814:9: note: === vect_analyze_loop_form ===
embann.c:814:9: note: === get_loop_niters ===
embann.c:814:9: note: Symbolic number of iterations is _250 + 1
embann.c:814:9: note: === vect_analyze_data_refs ===
embann.c:814:9: note: got vectype for stmt: _75 = testFloat[_76];
vector(4) float
embann.c:814:9: note: got vectype for stmt: _74 = testFloatWeight[_76];
vector(4) float
embann.c:814:9: note: got vectype for stmt: _72 = testFloatBias[_76];
vector(4) float
embann.c:814:9: note: got vectype for stmt: testFloat[_76] = _71;
vector(4) float
embann.c:814:9: note: === vect_analyze_scalar_cycles ===
embann.c:814:9: note: Analyze phi: .MEM_77 = PHI <.MEM_79(50), .MEM_70(52)>
embann.c:814:9: note: Analyze phi: i_251 = PHI <i_207(50), i_252(52)>
embann.c:814:9: note: Access function of PHI: {i_207, +, 1}_11
embann.c:814:9: note: step: 1,  init: i_207
embann.c:814:9: note: Detected induction.
embann.c:814:9: note: Analyze phi: ivtmp_259 = PHI <_261(50), ivtmp_260(52)>
embann.c:814:9: note: Access function of PHI: {_261, +, 4294967295}_11
embann.c:814:9: note: step: 4294967295,  init: _261
embann.c:814:9: note: Detected induction.
embann.c:814:9: note: === vect_pattern_recog ===
embann.c:814:9: note: vect_is_simple_use: operand _75
embann.c:814:9: note: def_stmt: _75 = testFloat[_76];
embann.c:814:9: note: type of def: internal
embann.c:814:9: note: === vect_analyze_data_ref_accesses ===
embann.c:814:9: note: not vectorized: complicated access pattern.
embann.c:814:9: note: bad data access.
embann.c:770:6: note: ===== analyze_loop_nest =====
embann.c:770:6: note: === vect_analyze_loop_form ===
embann.c:770:6: note: === vect_analyze_loop_form ===
embann.c:770:6: note: === get_loop_niters ===
embann.c:770:6: note: Considering outer-loop vectorization.
embann.c:770:6: note: === get_loop_niters ===
embann.c:770:6: note: === vect_analyze_data_refs ===
embann.c:770:6: note: analyze in outer loop: testFloat
embann.c:770:6: note: 	outer base_address: &testFloat
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 0
	outer base alignment: 32

	outer base misalignment: 0

	outer offset alignment: 256

	outer step alignment: 256
embann.c:770:6: note: got vectype for stmt: _43 = testFloat[_42];
vector(4) float
embann.c:770:6: note: analyze in outer loop: testFloatWeight
embann.c:770:6: note: 	outer base_address: &testFloatWeight
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 0
	outer base alignment: 32

	outer base misalignment: 0

	outer offset alignment: 256

	outer step alignment: 256
embann.c:770:6: note: got vectype for stmt: _44 = testFloatWeight[_42];
vector(4) float
embann.c:770:6: note: analyze in outer loop: testFloatBias
embann.c:770:6: note: 	outer base_address: &testFloatBias
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 0
	outer base alignment: 32

	outer base misalignment: 0

	outer offset alignment: 256

	outer step alignment: 256
embann.c:770:6: note: got vectype for stmt: _46 = testFloatBias[_42];
vector(4) float
embann.c:770:6: note: analyze in outer loop: testFloat
embann.c:770:6: note: 	outer base_address: &testFloat
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 0
	outer base alignment: 32

	outer base misalignment: 0

	outer offset alignment: 256

	outer step alignment: 256
embann.c:770:6: note: got vectype for stmt: testFloat[_42] = _47;
vector(4) float
embann.c:770:6: note: analyze in outer loop: testFloat
embann.c:770:6: note: 	outer base_address: &testFloat
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 0
	outer base alignment: 32

	outer base misalignment: 0

	outer offset alignment: 256

	outer step alignment: 256
embann.c:770:6: note: got vectype for stmt: _194 = testFloat[_199];
vector(4) float
embann.c:770:6: note: analyze in outer loop: testFloatWeight
embann.c:770:6: note: 	outer base_address: &testFloatWeight
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 0
	outer base alignment: 32

	outer base misalignment: 0

	outer offset alignment: 256

	outer step alignment: 256
embann.c:770:6: note: got vectype for stmt: _195 = testFloatWeight[_199];
vector(4) float
embann.c:770:6: note: analyze in outer loop: testFloatBias
embann.c:770:6: note: 	outer base_address: &testFloatBias
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 0
	outer base alignment: 32

	outer base misalignment: 0

	outer offset alignment: 256

	outer step alignment: 256
embann.c:770:6: note: got vectype for stmt: _196 = testFloatBias[_199];
vector(4) float
embann.c:770:6: note: analyze in outer loop: testFloat
embann.c:770:6: note: 	outer base_address: &testFloat
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 0
	outer base alignment: 32

	outer base misalignment: 0

	outer offset alignment: 256

	outer step alignment: 256
embann.c:770:6: note: got vectype for stmt: testFloat[_199] = _191;
vector(4) float
embann.c:770:6: note: === vect_analyze_scalar_cycles ===
embann.c:770:6: note: Analyze phi: i_165 = PHI <0(10), i_183(65)>
embann.c:770:6: note: Access function of PHI: {0, +, 2}_3
embann.c:770:6: note: step: 2,  init: 0
embann.c:770:6: note: Detected induction.
embann.c:770:6: note: Analyze phi: .MEM_173 = PHI <.MEM_111(10), .MEM_185(65)>
embann.c:770:6: note: Analyze phi: ivtmp_181 = PHI <1(10), ivtmp_184(65)>
embann.c:770:6: note: Access function of PHI: {1, +, 2}_3
embann.c:770:6: note: step: 2,  init: 1
embann.c:770:6: note: Detected induction.
embann.c:770:6: note: Analyze phi: ivtmp_49 = PHI <49999(10), ivtmp_114(65)>
embann.c:770:6: note: Access function of PHI: {49999, +, 4294967295}_3
embann.c:770:6: note: step: 4294967295,  init: 49999
embann.c:770:6: note: Detected induction.
embann.c:770:6: note: === vect_analyze_scalar_cycles ===
embann.c:770:6: note: Analyze phi: j_166 = PHI <0(13), j_182(62)>
embann.c:770:6: note: Access function of PHI: {0, +, 1}_6
embann.c:770:6: note: step: 1,  init: 0
embann.c:770:6: note: Detected induction.
embann.c:770:6: note: Analyze phi: .MEM_172 = PHI <.MEM_173(13), .MEM_185(62)>
embann.c:770:6: note: Analyze phi: ivtmp_107 = PHI <256(13), ivtmp_48(62)>
embann.c:770:6: note: Access function of PHI: {256, +, 65535}_6
embann.c:770:6: note: step: 65535,  init: 256
embann.c:770:6: note: Detected induction.
embann.c:770:6: note: === vect_pattern_recog ===
embann.c:770:6: note: vect_is_simple_use: operand _43
embann.c:770:6: note: def_stmt: _43 = testFloat[_42];
embann.c:770:6: note: type of def: internal
embann.c:770:6: note: vect_is_simple_use: operand _194
embann.c:770:6: note: def_stmt: _194 = testFloat[_199];
embann.c:770:6: note: type of def: internal
embann.c:770:6: note: === vect_analyze_data_ref_accesses ===
embann.c:770:6: note: zero step in outer loop.
embann.c:770:6: note: zero step in outer loop.
embann.c:770:6: note: zero step in outer loop.
embann.c:770:6: note: not vectorized: complicated access pattern.
embann.c:770:6: note: bad data access.

Analyzing loop at embann.c:814
embann.c:814:9: note: ===== analyze_loop_nest =====
embann.c:814:9: note: === vect_analyze_loop_form ===
embann.c:814:9: note: === get_loop_niters ===
embann.c:814:9: note: === vect_analyze_data_refs ===
embann.c:814:9: note: got vectype for stmt: _43 = testFloat[_42];
vector(4) float
embann.c:814:9: note: got vectype for stmt: _44 = testFloatWeight[_42];
vector(4) float
embann.c:814:9: note: got vectype for stmt: _46 = testFloatBias[_42];
vector(4) float
embann.c:814:9: note: got vectype for stmt: testFloat[_42] = _47;
vector(4) float
embann.c:814:9: note: got vectype for stmt: _194 = testFloat[_199];
vector(4) float
embann.c:814:9: note: got vectype for stmt: _195 = testFloatWeight[_199];
vector(4) float
embann.c:814:9: note: got vectype for stmt: _196 = testFloatBias[_199];
vector(4) float
embann.c:814:9: note: got vectype for stmt: testFloat[_199] = _191;
vector(4) float
embann.c:814:9: note: === vect_analyze_scalar_cycles ===
embann.c:814:9: note: Analyze phi: j_166 = PHI <0(13), j_182(62)>
embann.c:814:9: note: Access function of PHI: {0, +, 1}_6
embann.c:814:9: note: step: 1,  init: 0
embann.c:814:9: note: Detected induction.
embann.c:814:9: note: Analyze phi: .MEM_172 = PHI <.MEM_173(13), .MEM_185(62)>
embann.c:814:9: note: Analyze phi: ivtmp_107 = PHI <256(13), ivtmp_48(62)>
embann.c:814:9: note: Access function of PHI: {256, +, 65535}_6
embann.c:814:9: note: step: 65535,  init: 256
embann.c:814:9: note: Detected induction.
embann.c:814:9: note: === vect_pattern_recog ===
embann.c:814:9: note: vect_is_simple_use: operand _43
embann.c:814:9: note: def_stmt: _43 = testFloat[_42];
embann.c:814:9: note: type of def: internal
embann.c:814:9: note: vect_is_simple_use: operand _194
embann.c:814:9: note: def_stmt: _194 = testFloat[_199];
embann.c:814:9: note: type of def: internal
embann.c:814:9: note: === vect_analyze_data_ref_accesses ===
embann.c:814:9: note: === vect_mark_stmts_to_be_vectorized ===
embann.c:814:9: note: init: phi relevant? j_166 = PHI <0(13), j_182(62)>
embann.c:814:9: note: init: phi relevant? .MEM_172 = PHI <.MEM_173(13), .MEM_185(62)>
embann.c:814:9: note: init: phi relevant? ivtmp_107 = PHI <256(13), ivtmp_48(62)>
embann.c:814:9: note: init: stmt relevant? _42 = (int) j_166;
embann.c:814:9: note: init: stmt relevant? _43 = testFloat[_42];
embann.c:814:9: note: init: stmt relevant? _44 = testFloatWeight[_42];
embann.c:814:9: note: init: stmt relevant? _45 = _43 * _44;
embann.c:814:9: note: init: stmt relevant? _46 = testFloatBias[_42];
embann.c:814:9: note: init: stmt relevant? _47 = _45 + _46;
embann.c:814:9: note: init: stmt relevant? testFloat[_42] = _47;
embann.c:814:9: note: vec_stmt_relevant_p: stmt has vdefs.
embann.c:814:9: note: mark relevant 5, live 0: testFloat[_42] = _47;
embann.c:814:9: note: init: stmt relevant? i_115 = i_165 + 1;
embann.c:814:9: note: vec_stmt_relevant_p: used out of loop.
embann.c:814:9: note: vect_is_simple_use: operand i_165
embann.c:814:9: note: def_stmt: i_165 = PHI <0(10), i_183(65)>
embann.c:814:9: note: type of def: external
embann.c:814:9: note: mark relevant 0, live 1: i_115 = i_165 + 1;
embann.c:814:9: note: init: stmt relevant? _199 = (int) j_166;
embann.c:814:9: note: init: stmt relevant? _194 = testFloat[_199];
embann.c:814:9: note: init: stmt relevant? _195 = testFloatWeight[_199];
embann.c:814:9: note: init: stmt relevant? _193 = _194 * _195;
embann.c:814:9: note: init: stmt relevant? _196 = testFloatBias[_199];
embann.c:814:9: note: init: stmt relevant? _191 = _193 + _196;
embann.c:814:9: note: init: stmt relevant? testFloat[_199] = _191;
embann.c:814:9: note: vec_stmt_relevant_p: stmt has vdefs.
embann.c:814:9: note: mark relevant 5, live 0: testFloat[_199] = _191;
embann.c:814:9: note: init: stmt relevant? j.150_186 = (unsigned short) j_166;
embann.c:814:9: note: init: stmt relevant? _187 = j.150_186 + 1;
embann.c:814:9: note: init: stmt relevant? j_182 = (int16_t) _187;
embann.c:814:9: note: init: stmt relevant? ivtmp_48 = ivtmp_107 - 1;
embann.c:814:9: note: init: stmt relevant? if (ivtmp_48 != 0)
embann.c:814:9: note: worklist: examine stmt: testFloat[_199] = _191;
embann.c:814:9: note: vect_is_simple_use: operand _191
embann.c:814:9: note: def_stmt: _191 = _193 + _196;
embann.c:814:9: note: type of def: internal
embann.c:814:9: note: mark relevant 5, live 0: _191 = _193 + _196;
embann.c:814:9: note: worklist: examine stmt: _191 = _193 + _196;
embann.c:814:9: note: vect_is_simple_use: operand _193
embann.c:814:9: note: def_stmt: _193 = _194 * _195;
embann.c:814:9: note: type of def: internal
embann.c:814:9: note: mark relevant 5, live 0: _193 = _194 * _195;
embann.c:814:9: note: vect_is_simple_use: operand _196
embann.c:814:9: note: def_stmt: _196 = testFloatBias[_199];
embann.c:814:9: note: type of def: internal
embann.c:814:9: note: mark relevant 5, live 0: _196 = testFloatBias[_199];
embann.c:814:9: note: worklist: examine stmt: _196 = testFloatBias[_199];
embann.c:814:9: note: worklist: examine stmt: _193 = _194 * _195;
embann.c:814:9: note: vect_is_simple_use: operand _194
embann.c:814:9: note: def_stmt: _194 = testFloat[_199];
embann.c:814:9: note: type of def: internal
embann.c:814:9: note: mark relevant 5, live 0: _194 = testFloat[_199];
embann.c:814:9: note: vect_is_simple_use: operand _195
embann.c:814:9: note: def_stmt: _195 = testFloatWeight[_199];
embann.c:814:9: note: type of def: internal
embann.c:814:9: note: mark relevant 5, live 0: _195 = testFloatWeight[_199];
embann.c:814:9: note: worklist: examine stmt: _195 = testFloatWeight[_199];
embann.c:814:9: note: worklist: examine stmt: _194 = testFloat[_199];
embann.c:814:9: note: worklist: examine stmt: i_115 = i_165 + 1;
embann.c:814:9: note: vect_is_simple_use: operand i_165
embann.c:814:9: note: def_stmt: i_165 = PHI <0(10), i_183(65)>
embann.c:814:9: note: type of def: external
embann.c:814:9: note: def_stmt is out of loop.
embann.c:814:9: note: worklist: examine stmt: testFloat[_42] = _47;
embann.c:814:9: note: vect_is_simple_use: operand _47
embann.c:814:9: note: def_stmt: _47 = _45 + _46;
embann.c:814:9: note: type of def: internal
embann.c:814:9: note: mark relevant 5, live 0: _47 = _45 + _46;
embann.c:814:9: note: worklist: examine stmt: _47 = _45 + _46;
embann.c:814:9: note: vect_is_simple_use: operand _45
embann.c:814:9: note: def_stmt: _45 = _43 * _44;
embann.c:814:9: note: type of def: internal
embann.c:814:9: note: mark relevant 5, live 0: _45 = _43 * _44;
embann.c:814:9: note: vect_is_simple_use: operand _46
embann.c:814:9: note: def_stmt: _46 = testFloatBias[_42];
embann.c:814:9: note: type of def: internal
embann.c:814:9: note: mark relevant 5, live 0: _46 = testFloatBias[_42];
embann.c:814:9: note: worklist: examine stmt: _46 = testFloatBias[_42];
embann.c:814:9: note: worklist: examine stmt: _45 = _43 * _44;
embann.c:814:9: note: vect_is_simple_use: operand _43
embann.c:814:9: note: def_stmt: _43 = testFloat[_42];
embann.c:814:9: note: type of def: internal
embann.c:814:9: note: mark relevant 5, live 0: _43 = testFloat[_42];
embann.c:814:9: note: vect_is_simple_use: operand _44
embann.c:814:9: note: def_stmt: _44 = testFloatWeight[_42];
embann.c:814:9: note: type of def: internal
embann.c:814:9: note: mark relevant 5, live 0: _44 = testFloatWeight[_42];
embann.c:814:9: note: worklist: examine stmt: _44 = testFloatWeight[_42];
embann.c:814:9: note: worklist: examine stmt: _43 = testFloat[_42];
embann.c:814:9: note: === vect_analyze_data_ref_dependences ===
embann.c:814:9: note: dependence distance  = 0.
embann.c:814:9: note: dependence distance == 0 between testFloat[_42] and testFloat[_42]
embann.c:814:9: note: dependence distance  = 0.
embann.c:814:9: note: dependence distance == 0 between testFloat[_42] and testFloat[_199]
embann.c:814:9: note: dependence distance  = 0.
embann.c:814:9: note: dependence distance == 0 between testFloat[_42] and testFloat[_199]
embann.c:814:9: note: dependence distance  = 0.
embann.c:814:9: note: dependence distance == 0 between testFloat[_42] and testFloat[_199]
embann.c:814:9: note: dependence distance  = 0.
embann.c:814:9: note: dependence distance == 0 between testFloat[_199] and testFloat[_199]
embann.c:814:9: note: === vect_determine_vectorization_factor ===
embann.c:814:9: note: ==> examining phi: j_166 = PHI <0(13), j_182(62)>
embann.c:814:9: note: ==> examining phi: .MEM_172 = PHI <.MEM_173(13), .MEM_185(62)>
embann.c:814:9: note: ==> examining phi: ivtmp_107 = PHI <256(13), ivtmp_48(62)>
embann.c:814:9: note: ==> examining statement: _42 = (int) j_166;
embann.c:814:9: note: skip.
embann.c:814:9: note: ==> examining statement: _43 = testFloat[_42];
embann.c:814:9: note: get vectype for scalar type:  float
embann.c:814:9: note: vectype: vector(4) float
embann.c:814:9: note: nunits = 4
embann.c:814:9: note: ==> examining statement: _44 = testFloatWeight[_42];
embann.c:814:9: note: get vectype for scalar type:  float
embann.c:814:9: note: vectype: vector(4) float
embann.c:814:9: note: nunits = 4
embann.c:814:9: note: ==> examining statement: _45 = _43 * _44;
embann.c:814:9: note: get vectype for scalar type:  float
embann.c:814:9: note: vectype: vector(4) float
embann.c:814:9: note: get vectype for scalar type:  float
embann.c:814:9: note: vectype: vector(4) float
embann.c:814:9: note: nunits = 4
embann.c:814:9: note: ==> examining statement: _46 = testFloatBias[_42];
embann.c:814:9: note: get vectype for scalar type:  float
embann.c:814:9: note: vectype: vector(4) float
embann.c:814:9: note: nunits = 4
embann.c:814:9: note: ==> examining statement: _47 = _45 + _46;
embann.c:814:9: note: get vectype for scalar type:  float
embann.c:814:9: note: vectype: vector(4) float
embann.c:814:9: note: get vectype for scalar type:  float
embann.c:814:9: note: vectype: vector(4) float
embann.c:814:9: note: nunits = 4
embann.c:814:9: note: ==> examining statement: testFloat[_42] = _47;
embann.c:814:9: note: get vectype for scalar type:  float
embann.c:814:9: note: vectype: vector(4) float
embann.c:814:9: note: nunits = 4
embann.c:814:9: note: ==> examining statement: i_115 = i_165 + 1;
embann.c:814:9: note: get vectype for scalar type:  int32_t
embann.c:814:9: note: vectype: vector(4) int
embann.c:814:9: note: get vectype for scalar type:  int32_t
embann.c:814:9: note: vectype: vector(4) int
embann.c:814:9: note: nunits = 4
embann.c:814:9: note: ==> examining statement: _199 = (int) j_166;
embann.c:814:9: note: skip.
embann.c:814:9: note: ==> examining statement: _194 = testFloat[_199];
embann.c:814:9: note: get vectype for scalar type:  float
embann.c:814:9: note: vectype: vector(4) float
embann.c:814:9: note: nunits = 4
embann.c:814:9: note: ==> examining statement: _195 = testFloatWeight[_199];
embann.c:814:9: note: get vectype for scalar type:  float
embann.c:814:9: note: vectype: vector(4) float
embann.c:814:9: note: nunits = 4
embann.c:814:9: note: ==> examining statement: _193 = _194 * _195;
embann.c:814:9: note: get vectype for scalar type:  float
embann.c:814:9: note: vectype: vector(4) float
embann.c:814:9: note: get vectype for scalar type:  float
embann.c:814:9: note: vectype: vector(4) float
embann.c:814:9: note: nunits = 4
embann.c:814:9: note: ==> examining statement: _196 = testFloatBias[_199];
embann.c:814:9: note: get vectype for scalar type:  float
embann.c:814:9: note: vectype: vector(4) float
embann.c:814:9: note: nunits = 4
embann.c:814:9: note: ==> examining statement: _191 = _193 + _196;
embann.c:814:9: note: get vectype for scalar type:  float
embann.c:814:9: note: vectype: vector(4) float
embann.c:814:9: note: get vectype for scalar type:  float
embann.c:814:9: note: vectype: vector(4) float
embann.c:814:9: note: nunits = 4
embann.c:814:9: note: ==> examining statement: testFloat[_199] = _191;
embann.c:814:9: note: get vectype for scalar type:  float
embann.c:814:9: note: vectype: vector(4) float
embann.c:814:9: note: nunits = 4
embann.c:814:9: note: ==> examining statement: j.150_186 = (unsigned short) j_166;
embann.c:814:9: note: skip.
embann.c:814:9: note: ==> examining statement: _187 = j.150_186 + 1;
embann.c:814:9: note: skip.
embann.c:814:9: note: ==> examining statement: j_182 = (int16_t) _187;
embann.c:814:9: note: skip.
embann.c:814:9: note: ==> examining statement: ivtmp_48 = ivtmp_107 - 1;
embann.c:814:9: note: skip.
embann.c:814:9: note: ==> examining statement: if (ivtmp_48 != 0)
embann.c:814:9: note: skip.
embann.c:814:9: note: vectorization factor = 4
embann.c:814:9: note: === vect_analyze_slp ===
embann.c:814:9: note: === vect_make_slp_decision ===
embann.c:814:9: note: vectorization_factor = 4, niters = 256
embann.c:814:9: note: === vect_analyze_data_refs_alignment ===
embann.c:814:9: note: accesses have the same alignment: testFloat[_42] and testFloat[_42]
embann.c:814:9: note: accesses have the same alignment: testFloat[_42] and testFloat[_199]
embann.c:814:9: note: accesses have the same alignment: testFloat[_42] and testFloat[_199]
embann.c:814:9: note: accesses have the same alignment: testFloatWeight[_42] and testFloatWeight[_199]
embann.c:814:9: note: accesses have the same alignment: testFloatBias[_42] and testFloatBias[_199]
embann.c:814:9: note: accesses have the same alignment: testFloat[_42] and testFloat[_199]
embann.c:814:9: note: accesses have the same alignment: testFloat[_42] and testFloat[_199]
embann.c:814:9: note: accesses have the same alignment: testFloat[_199] and testFloat[_199]
embann.c:814:9: note: recording new base alignment for &testFloat
embann.c:814:9: note:   alignment:    32
embann.c:814:9: note:   misalignment: 0
embann.c:814:9: note:   based on:     _43 = testFloat[_42];
embann.c:814:9: note: recording new base alignment for &testFloatWeight
embann.c:814:9: note:   alignment:    32
embann.c:814:9: note:   misalignment: 0
embann.c:814:9: note:   based on:     _44 = testFloatWeight[_42];
embann.c:814:9: note: recording new base alignment for &testFloatBias
embann.c:814:9: note:   alignment:    32
embann.c:814:9: note:   misalignment: 0
embann.c:814:9: note:   based on:     _46 = testFloatBias[_42];
embann.c:814:9: note: vect_compute_data_ref_alignment:
embann.c:814:9: note: misalign = 0 bytes of ref testFloat[_42]
embann.c:814:9: note: vect_compute_data_ref_alignment:
embann.c:814:9: note: misalign = 0 bytes of ref testFloatWeight[_42]
embann.c:814:9: note: vect_compute_data_ref_alignment:
embann.c:814:9: note: misalign = 0 bytes of ref testFloatBias[_42]
embann.c:814:9: note: vect_compute_data_ref_alignment:
embann.c:814:9: note: misalign = 0 bytes of ref testFloat[_42]
embann.c:814:9: note: vect_compute_data_ref_alignment:
embann.c:814:9: note: misalign = 0 bytes of ref testFloat[_199]
embann.c:814:9: note: vect_compute_data_ref_alignment:
embann.c:814:9: note: misalign = 0 bytes of ref testFloatWeight[_199]
embann.c:814:9: note: vect_compute_data_ref_alignment:
embann.c:814:9: note: misalign = 0 bytes of ref testFloatBias[_199]
embann.c:814:9: note: vect_compute_data_ref_alignment:
embann.c:814:9: note: misalign = 0 bytes of ref testFloat[_199]
embann.c:814:9: note: === vect_prune_runtime_alias_test_list ===
embann.c:814:9: note: === vect_enhance_data_refs_alignment ===
embann.c:814:9: note: vect_can_advance_ivs_p:
embann.c:814:9: note: Analyze phi: j_166 = PHI <0(13), j_182(62)>
embann.c:814:9: note: Analyze phi: .MEM_172 = PHI <.MEM_173(13), .MEM_185(62)>
embann.c:814:9: note: reduc or virtual phi. skip.
embann.c:814:9: note: Analyze phi: ivtmp_107 = PHI <256(13), ivtmp_48(62)>
embann.c:814:9: note: vect_model_load_cost: aligned.
embann.c:814:9: note: vect_get_data_access_cost: inside_cost = 12, outside_cost = 0.
embann.c:814:9: note: vect_model_load_cost: aligned.
embann.c:814:9: note: vect_get_data_access_cost: inside_cost = 24, outside_cost = 0.
embann.c:814:9: note: vect_model_load_cost: aligned.
embann.c:814:9: note: vect_get_data_access_cost: inside_cost = 36, outside_cost = 0.
embann.c:814:9: note: vect_model_store_cost: aligned.
embann.c:814:9: note: vect_get_data_access_cost: inside_cost = 52, outside_cost = 0.
embann.c:814:9: note: vect_model_load_cost: aligned.
embann.c:814:9: note: vect_get_data_access_cost: inside_cost = 64, outside_cost = 0.
embann.c:814:9: note: vect_model_load_cost: aligned.
embann.c:814:9: note: vect_get_data_access_cost: inside_cost = 76, outside_cost = 0.
embann.c:814:9: note: vect_model_load_cost: aligned.
embann.c:814:9: note: vect_get_data_access_cost: inside_cost = 88, outside_cost = 0.
embann.c:814:9: note: vect_model_store_cost: aligned.
embann.c:814:9: note: vect_get_data_access_cost: inside_cost = 104, outside_cost = 0.
embann.c:814:9: note: === vect_analyze_loop_operations ===
embann.c:814:9: note: examining phi: j_166 = PHI <0(13), j_182(62)>
embann.c:814:9: note: examining phi: .MEM_172 = PHI <.MEM_173(13), .MEM_185(62)>
embann.c:814:9: note: examining phi: ivtmp_107 = PHI <256(13), ivtmp_48(62)>
embann.c:814:9: note: ==> examining statement: _42 = (int) j_166;
embann.c:814:9: note: irrelevant.
embann.c:814:9: note: ==> examining statement: _43 = testFloat[_42];
embann.c:814:9: note: num. args = 4 (not unary/binary/ternary op).
embann.c:814:9: note: vect_is_simple_use: operand testFloat[_42]
embann.c:814:9: note: not ssa-name.
embann.c:814:9: note: use not simple.
embann.c:814:9: note: vect_model_load_cost: aligned.
embann.c:814:9: note: vect_model_load_cost: inside_cost = 12, prologue_cost = 0 .
embann.c:814:9: note: ==> examining statement: _44 = testFloatWeight[_42];
embann.c:814:9: note: num. args = 4 (not unary/binary/ternary op).
embann.c:814:9: note: vect_is_simple_use: operand testFloatWeight[_42]
embann.c:814:9: note: not ssa-name.
embann.c:814:9: note: use not simple.
embann.c:814:9: note: vect_model_load_cost: aligned.
embann.c:814:9: note: vect_model_load_cost: inside_cost = 12, prologue_cost = 0 .
embann.c:814:9: note: ==> examining statement: _45 = _43 * _44;
embann.c:814:9: note: vect_is_simple_use: operand _43
embann.c:814:9: note: def_stmt: _43 = testFloat[_42];
embann.c:814:9: note: type of def: internal
embann.c:814:9: note: vect_is_simple_use: operand _44
embann.c:814:9: note: def_stmt: _44 = testFloatWeight[_42];
embann.c:814:9: note: type of def: internal
embann.c:814:9: note: === vectorizable_operation ===
embann.c:814:9: note: vect_model_simple_cost: inside_cost = 12, prologue_cost = 0 .
embann.c:814:9: note: ==> examining statement: _46 = testFloatBias[_42];
embann.c:814:9: note: num. args = 4 (not unary/binary/ternary op).
embann.c:814:9: note: vect_is_simple_use: operand testFloatBias[_42]
embann.c:814:9: note: not ssa-name.
embann.c:814:9: note: use not simple.
embann.c:814:9: note: vect_model_load_cost: aligned.
embann.c:814:9: note: vect_model_load_cost: inside_cost = 12, prologue_cost = 0 .
embann.c:814:9: note: ==> examining statement: _47 = _45 + _46;
embann.c:814:9: note: vect_is_simple_use: operand _45
embann.c:814:9: note: def_stmt: _45 = _43 * _44;
embann.c:814:9: note: type of def: internal
embann.c:814:9: note: vect_is_simple_use: operand _46
embann.c:814:9: note: def_stmt: _46 = testFloatBias[_42];
embann.c:814:9: note: type of def: internal
embann.c:814:9: note: === vectorizable_operation ===
embann.c:814:9: note: vect_model_simple_cost: inside_cost = 12, prologue_cost = 0 .
embann.c:814:9: note: ==> examining statement: testFloat[_42] = _47;
embann.c:814:9: note: vect_is_simple_use: operand _47
embann.c:814:9: note: def_stmt: _47 = _45 + _46;
embann.c:814:9: note: type of def: internal
embann.c:814:9: note: vect_model_store_cost: aligned.
embann.c:814:9: note: vect_model_store_cost: inside_cost = 16, prologue_cost = 0 .
embann.c:814:9: note: ==> examining statement: i_115 = i_165 + 1;
embann.c:814:9: note: vect_is_simple_use: operand i_165
embann.c:814:9: note: def_stmt: i_165 = PHI <0(10), i_183(65)>
embann.c:814:9: note: type of def: external
embann.c:814:9: note: statement is simple and uses invariant.  Leaving in place.
embann.c:814:9: note: ==> examining statement: _199 = (int) j_166;
embann.c:814:9: note: irrelevant.
embann.c:814:9: note: ==> examining statement: _194 = testFloat[_199];
embann.c:814:9: note: num. args = 4 (not unary/binary/ternary op).
embann.c:814:9: note: vect_is_simple_use: operand testFloat[_199]
embann.c:814:9: note: not ssa-name.
embann.c:814:9: note: use not simple.
embann.c:814:9: note: vect_model_load_cost: aligned.
embann.c:814:9: note: vect_model_load_cost: inside_cost = 12, prologue_cost = 0 .
embann.c:814:9: note: ==> examining statement: _195 = testFloatWeight[_199];
embann.c:814:9: note: num. args = 4 (not unary/binary/ternary op).
embann.c:814:9: note: vect_is_simple_use: operand testFloatWeight[_199]
embann.c:814:9: note: not ssa-name.
embann.c:814:9: note: use not simple.
embann.c:814:9: note: vect_model_load_cost: aligned.
embann.c:814:9: note: vect_model_load_cost: inside_cost = 12, prologue_cost = 0 .
embann.c:814:9: note: ==> examining statement: _193 = _194 * _195;
embann.c:814:9: note: vect_is_simple_use: operand _194
embann.c:814:9: note: def_stmt: _194 = testFloat[_199];
embann.c:814:9: note: type of def: internal
embann.c:814:9: note: vect_is_simple_use: operand _195
embann.c:814:9: note: def_stmt: _195 = testFloatWeight[_199];
embann.c:814:9: note: type of def: internal
embann.c:814:9: note: === vectorizable_operation ===
embann.c:814:9: note: vect_model_simple_cost: inside_cost = 12, prologue_cost = 0 .
embann.c:814:9: note: ==> examining statement: _196 = testFloatBias[_199];
embann.c:814:9: note: num. args = 4 (not unary/binary/ternary op).
embann.c:814:9: note: vect_is_simple_use: operand testFloatBias[_199]
embann.c:814:9: note: not ssa-name.
embann.c:814:9: note: use not simple.
embann.c:814:9: note: vect_model_load_cost: aligned.
embann.c:814:9: note: vect_model_load_cost: inside_cost = 12, prologue_cost = 0 .
embann.c:814:9: note: ==> examining statement: _191 = _193 + _196;
embann.c:814:9: note: vect_is_simple_use: operand _193
embann.c:814:9: note: def_stmt: _193 = _194 * _195;
embann.c:814:9: note: type of def: internal
embann.c:814:9: note: vect_is_simple_use: operand _196
embann.c:814:9: note: def_stmt: _196 = testFloatBias[_199];
embann.c:814:9: note: type of def: internal
embann.c:814:9: note: === vectorizable_operation ===
embann.c:814:9: note: vect_model_simple_cost: inside_cost = 12, prologue_cost = 0 .
embann.c:814:9: note: ==> examining statement: testFloat[_199] = _191;
embann.c:814:9: note: vect_is_simple_use: operand _191
embann.c:814:9: note: def_stmt: _191 = _193 + _196;
embann.c:814:9: note: type of def: internal
embann.c:814:9: note: vect_model_store_cost: aligned.
embann.c:814:9: note: vect_model_store_cost: inside_cost = 16, prologue_cost = 0 .
embann.c:814:9: note: ==> examining statement: j.150_186 = (unsigned short) j_166;
embann.c:814:9: note: irrelevant.
embann.c:814:9: note: ==> examining statement: _187 = j.150_186 + 1;
embann.c:814:9: note: irrelevant.
embann.c:814:9: note: ==> examining statement: j_182 = (int16_t) _187;
embann.c:814:9: note: irrelevant.
embann.c:814:9: note: ==> examining statement: ivtmp_48 = ivtmp_107 - 1;
embann.c:814:9: note: irrelevant.
embann.c:814:9: note: ==> examining statement: if (ivtmp_48 != 0)
embann.c:814:9: note: irrelevant.
embann.c:814:9: note: not using a fully-masked loop.
embann.c:814:9: note: Cost model analysis: 
  Vector inside of loop cost: 152
  Vector prologue cost: 0
  Vector epilogue cost: 0
  Scalar iteration cost: 136
  Scalar outside cost: 0
  Vector outside cost: 0
  prologue iterations: 0
  epilogue iterations: 0
  Calculated minimum iters for profitability: 0
embann.c:814:9: note:   Runtime profitability threshold = 4
embann.c:814:9: note:   Static estimate profitability threshold = 4
embann.c:814:9: note: loop vectorized
embann.c:814:9: note: === vec_transform_loop ===
embann.c:814:9: note: ------>vectorizing phi: j_166 = PHI <j_182(62), 0(85)>
embann.c:814:9: note: ------>vectorizing phi: .MEM_172 = PHI <.MEM_185(62), .MEM_173(85)>
embann.c:814:9: note: ------>vectorizing phi: ivtmp_107 = PHI <ivtmp_48(62), 256(85)>
embann.c:814:9: note: ------>vectorizing statement: _42 = (int) j_166;
embann.c:814:9: note: ------>vectorizing statement: _43 = testFloat[_42];
embann.c:814:9: note: transform statement.
embann.c:814:9: note: transform load. ncopies = 1
embann.c:814:9: note: create vector_type-pointer variable to type: vector(4) float  vectorizing an array ref: testFloat
embann.c:814:9: note: created &testFloat
embann.c:814:9: note: add new stmt: vect__43.526_303 = MEM[(float *)vectp_testFloat.524_301];
embann.c:814:9: note: ------>vectorizing statement: _44 = testFloatWeight[_42];
embann.c:814:9: note: transform statement.
embann.c:814:9: note: transform load. ncopies = 1
embann.c:814:9: note: create vector_type-pointer variable to type: vector(4) float  vectorizing an array ref: testFloatWeight
embann.c:814:9: note: created &testFloatWeight
embann.c:814:9: note: add new stmt: vect__44.529_306 = MEM[(float *)vectp_testFloatWeight.527_304];
embann.c:814:9: note: ------>vectorizing statement: _45 = _43 * _44;
embann.c:814:9: note: transform statement.
embann.c:814:9: note: vect_is_simple_use: operand _43
embann.c:814:9: note: def_stmt: _43 = testFloat[_42];
embann.c:814:9: note: type of def: internal
embann.c:814:9: note: vect_is_simple_use: operand _44
embann.c:814:9: note: def_stmt: _44 = testFloatWeight[_42];
embann.c:814:9: note: type of def: internal
embann.c:814:9: note: transform binary/unary operation.
embann.c:814:9: note: vect_get_vec_def_for_operand: _43
embann.c:814:9: note: vect_is_simple_use: operand _43
embann.c:814:9: note: def_stmt: _43 = testFloat[_42];
embann.c:814:9: note: type of def: internal
embann.c:814:9: note:   def_stmt =  _43 = testFloat[_42];
embann.c:814:9: note: vect_get_vec_def_for_operand: _44
embann.c:814:9: note: vect_is_simple_use: operand _44
embann.c:814:9: note: def_stmt: _44 = testFloatWeight[_42];
embann.c:814:9: note: type of def: internal
embann.c:814:9: note:   def_stmt =  _44 = testFloatWeight[_42];
embann.c:814:9: note: add new stmt: vect__45.530_307 = vect__43.526_303 * vect__44.529_306;
embann.c:814:9: note: ------>vectorizing statement: _46 = testFloatBias[_42];
embann.c:814:9: note: transform statement.
embann.c:814:9: note: transform load. ncopies = 1
embann.c:814:9: note: create vector_type-pointer variable to type: vector(4) float  vectorizing an array ref: testFloatBias
embann.c:814:9: note: created &testFloatBias
embann.c:814:9: note: add new stmt: vect__46.533_310 = MEM[(float *)vectp_testFloatBias.531_308];
embann.c:814:9: note: ------>vectorizing statement: _47 = _45 + _46;
embann.c:814:9: note: transform statement.
embann.c:814:9: note: vect_is_simple_use: operand _45
embann.c:814:9: note: def_stmt: _45 = _43 * _44;
embann.c:814:9: note: type of def: internal
embann.c:814:9: note: vect_is_simple_use: operand _46
embann.c:814:9: note: def_stmt: _46 = testFloatBias[_42];
embann.c:814:9: note: type of def: internal
embann.c:814:9: note: transform binary/unary operation.
embann.c:814:9: note: vect_get_vec_def_for_operand: _45
embann.c:814:9: note: vect_is_simple_use: operand _45
embann.c:814:9: note: def_stmt: _45 = _43 * _44;
embann.c:814:9: note: type of def: internal
embann.c:814:9: note:   def_stmt =  _45 = _43 * _44;
embann.c:814:9: note: vect_get_vec_def_for_operand: _46
embann.c:814:9: note: vect_is_simple_use: operand _46
embann.c:814:9: note: def_stmt: _46 = testFloatBias[_42];
embann.c:814:9: note: type of def: internal
embann.c:814:9: note:   def_stmt =  _46 = testFloatBias[_42];
embann.c:814:9: note: add new stmt: vect__47.534_311 = vect__45.530_307 + vect__46.533_310;
embann.c:814:9: note: ------>vectorizing statement: testFloat[_42] = _47;
embann.c:814:9: note: transform statement.
embann.c:814:9: note: vect_is_simple_use: operand _47
embann.c:814:9: note: def_stmt: _47 = _45 + _46;
embann.c:814:9: note: type of def: internal
embann.c:814:9: note: transform store. ncopies = 1
embann.c:814:9: note: vect_get_vec_def_for_operand: _47
embann.c:814:9: note: vect_is_simple_use: operand _47
embann.c:814:9: note: def_stmt: _47 = _45 + _46;
embann.c:814:9: note: type of def: internal
embann.c:814:9: note:   def_stmt =  _47 = _45 + _46;
embann.c:814:9: note: create vector_type-pointer variable to type: vector(4) float  vectorizing an array ref: testFloat
embann.c:814:9: note: created &testFloat
embann.c:814:9: note: add new stmt: MEM[(float *)vectp_testFloat.535_312] = vect__47.534_311;
embann.c:814:9: note: ------>vectorizing statement: i_115 = i_165 + 1;
embann.c:814:9: note: transform statement.
embann.c:814:9: note: vect_is_simple_use: operand i_165
embann.c:814:9: note: def_stmt: i_165 = PHI <0(10), i_183(65)>
embann.c:814:9: note: type of def: external
embann.c:814:9: note: statement is simple and uses invariant.  Leaving in place.
embann.c:814:9: note: ------>vectorizing statement: _199 = (int) j_166;
embann.c:814:9: note: ------>vectorizing statement: _194 = testFloat[_199];
embann.c:814:9: note: transform statement.
embann.c:814:9: note: transform load. ncopies = 1
embann.c:814:9: note: create vector_type-pointer variable to type: vector(4) float  vectorizing an array ref: testFloat
embann.c:814:9: note: created &testFloat
embann.c:814:9: note: add new stmt: vect__194.539_317 = MEM[(float *)vectp_testFloat.537_315];
embann.c:814:9: note: ------>vectorizing statement: _195 = testFloatWeight[_199];
embann.c:814:9: note: transform statement.
embann.c:814:9: note: transform load. ncopies = 1
embann.c:814:9: note: create vector_type-pointer variable to type: vector(4) float  vectorizing an array ref: testFloatWeight
embann.c:814:9: note: created &testFloatWeight
embann.c:814:9: note: add new stmt: vect__195.542_320 = MEM[(float *)vectp_testFloatWeight.540_318];
embann.c:814:9: note: ------>vectorizing statement: _193 = _194 * _195;
embann.c:814:9: note: transform statement.
embann.c:814:9: note: vect_is_simple_use: operand _194
embann.c:814:9: note: def_stmt: _194 = testFloat[_199];
embann.c:814:9: note: type of def: internal
embann.c:814:9: note: vect_is_simple_use: operand _195
embann.c:814:9: note: def_stmt: _195 = testFloatWeight[_199];
embann.c:814:9: note: type of def: internal
embann.c:814:9: note: transform binary/unary operation.
embann.c:814:9: note: vect_get_vec_def_for_operand: _194
embann.c:814:9: note: vect_is_simple_use: operand _194
embann.c:814:9: note: def_stmt: _194 = testFloat[_199];
embann.c:814:9: note: type of def: internal
embann.c:814:9: note:   def_stmt =  _194 = testFloat[_199];
embann.c:814:9: note: vect_get_vec_def_for_operand: _195
embann.c:814:9: note: vect_is_simple_use: operand _195
embann.c:814:9: note: def_stmt: _195 = testFloatWeight[_199];
embann.c:814:9: note: type of def: internal
embann.c:814:9: note:   def_stmt =  _195 = testFloatWeight[_199];
embann.c:814:9: note: add new stmt: vect__193.543_321 = vect__194.539_317 * vect__195.542_320;
embann.c:814:9: note: ------>vectorizing statement: _196 = testFloatBias[_199];
embann.c:814:9: note: transform statement.
embann.c:814:9: note: transform load. ncopies = 1
embann.c:814:9: note: create vector_type-pointer variable to type: vector(4) float  vectorizing an array ref: testFloatBias
embann.c:814:9: note: created &testFloatBias
embann.c:814:9: note: add new stmt: vect__196.546_324 = MEM[(float *)vectp_testFloatBias.544_322];
embann.c:814:9: note: ------>vectorizing statement: _191 = _193 + _196;
embann.c:814:9: note: transform statement.
embann.c:814:9: note: vect_is_simple_use: operand _193
embann.c:814:9: note: def_stmt: _193 = _194 * _195;
embann.c:814:9: note: type of def: internal
embann.c:814:9: note: vect_is_simple_use: operand _196
embann.c:814:9: note: def_stmt: _196 = testFloatBias[_199];
embann.c:814:9: note: type of def: internal
embann.c:814:9: note: transform binary/unary operation.
embann.c:814:9: note: vect_get_vec_def_for_operand: _193
embann.c:814:9: note: vect_is_simple_use: operand _193
embann.c:814:9: note: def_stmt: _193 = _194 * _195;
embann.c:814:9: note: type of def: internal
embann.c:814:9: note:   def_stmt =  _193 = _194 * _195;
embann.c:814:9: note: vect_get_vec_def_for_operand: _196
embann.c:814:9: note: vect_is_simple_use: operand _196
embann.c:814:9: note: def_stmt: _196 = testFloatBias[_199];
embann.c:814:9: note: type of def: internal
embann.c:814:9: note:   def_stmt =  _196 = testFloatBias[_199];
embann.c:814:9: note: add new stmt: vect__191.547_325 = vect__193.543_321 + vect__196.546_324;
embann.c:814:9: note: ------>vectorizing statement: testFloat[_199] = _191;
embann.c:814:9: note: transform statement.
embann.c:814:9: note: vect_is_simple_use: operand _191
embann.c:814:9: note: def_stmt: _191 = _193 + _196;
embann.c:814:9: note: type of def: internal
embann.c:814:9: note: transform store. ncopies = 1
embann.c:814:9: note: vect_get_vec_def_for_operand: _191
embann.c:814:9: note: vect_is_simple_use: operand _191
embann.c:814:9: note: def_stmt: _191 = _193 + _196;
embann.c:814:9: note: type of def: internal
embann.c:814:9: note:   def_stmt =  _191 = _193 + _196;
embann.c:814:9: note: create vector_type-pointer variable to type: vector(4) float  vectorizing an array ref: testFloat
embann.c:814:9: note: created &testFloat
embann.c:814:9: note: add new stmt: MEM[(float *)vectp_testFloat.548_326] = vect__191.547_325;
embann.c:814:9: note: ------>vectorizing statement: j.150_186 = (unsigned short) j_166;
embann.c:814:9: note: ------>vectorizing statement: _187 = j.150_186 + 1;
embann.c:814:9: note: ------>vectorizing statement: j_182 = (int16_t) _187;
embann.c:814:9: note: ------>vectorizing statement: ivtmp_48 = ivtmp_107 - 1;
embann.c:814:9: note: ------>vectorizing statement: vectp_testFloat.524_302 = vectp_testFloat.524_301 + 16;
embann.c:814:9: note: ------>vectorizing statement: vectp_testFloatWeight.527_305 = vectp_testFloatWeight.527_304 + 16;
embann.c:814:9: note: ------>vectorizing statement: vectp_testFloatBias.531_309 = vectp_testFloatBias.531_308 + 16;
embann.c:814:9: note: ------>vectorizing statement: vectp_testFloat.535_313 = vectp_testFloat.535_312 + 16;
embann.c:814:9: note: ------>vectorizing statement: vectp_testFloat.537_316 = vectp_testFloat.537_315 + 16;
embann.c:814:9: note: ------>vectorizing statement: vectp_testFloatWeight.540_319 = vectp_testFloatWeight.540_318 + 16;
embann.c:814:9: note: ------>vectorizing statement: vectp_testFloatBias.544_323 = vectp_testFloatBias.544_322 + 16;
embann.c:814:9: note: ------>vectorizing statement: vectp_testFloat.548_327 = vectp_testFloat.548_326 + 16;
embann.c:814:9: note: ------>vectorizing statement: if (ivtmp_48 != 0)
embann.c:814:9: note: New loop exit condition: if (ivtmp_330 < 64)
embann.c:814:9: note: LOOP VECTORIZED


Analyzing loop at embann.c:798
embann.c:798:5: note: ===== analyze_loop_nest =====
embann.c:798:5: note: === vect_analyze_loop_form ===
embann.c:798:5: note: === vect_analyze_loop_form ===
embann.c:798:5: note: === get_loop_niters ===
embann.c:798:5: note: Considering outer-loop vectorization.
embann.c:798:5: note: === get_loop_niters ===
embann.c:798:5: note: === vect_analyze_data_refs ===
embann.c:798:5: note: analyze in outer loop: *(&testInt + (sizetype) j_266 * 4)
embann.c:798:5: note: 	outer base_address: &testInt
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 4
	outer base alignment: 32

	outer base misalignment: 0

	outer offset alignment: 256

	outer step alignment: 4
embann.c:798:5: note: got vectype for stmt: _204 = testInt[_68];
vector(4) int
embann.c:798:5: note: analyze in outer loop: *(&testIntWeight + (sizetype) j_266 * 4)
embann.c:798:5: note: 	outer base_address: &testIntWeight
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 4
	outer base alignment: 32

	outer base misalignment: 0

	outer offset alignment: 256

	outer step alignment: 4
embann.c:798:5: note: got vectype for stmt: _192 = testIntWeight[_68];
vector(4) int
embann.c:798:5: note: analyze in outer loop: *(&testIntBias + (sizetype) j_266 * 4)
embann.c:798:5: note: 	outer base_address: &testIntBias
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 4
	outer base alignment: 32

	outer base misalignment: 0

	outer offset alignment: 256

	outer step alignment: 4
embann.c:798:5: note: got vectype for stmt: _215 = testIntBias[_68];
vector(4) int
embann.c:798:5: note: analyze in outer loop: *(&testInt + (sizetype) j_266 * 4)
embann.c:798:5: note: 	outer base_address: &testInt
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 4
	outer base alignment: 32

	outer base misalignment: 0

	outer offset alignment: 256

	outer step alignment: 4
embann.c:798:5: note: got vectype for stmt: testInt[_68] = _216;
vector(4) int
embann.c:798:5: note: === vect_analyze_scalar_cycles ===
embann.c:798:5: note: Analyze phi: .MEM_177 = PHI <.MEM_217(71), .MEM_235(74)>
embann.c:798:5: note: Analyze phi: j_266 = PHI <j_267(71), 0(74)>
embann.c:798:5: note: Access function of PHI: {0, +, 1}_15
embann.c:798:5: note: step: 1,  init: 0
embann.c:798:5: note: Detected induction.
embann.c:798:5: note: Analyze phi: ivtmp_268 = PHI <ivtmp_269(71), 256(74)>
embann.c:798:5: note: Access function of PHI: {256, +, 65535}_15
embann.c:798:5: note: step: 65535,  init: 256
embann.c:798:5: note: Detected induction.
embann.c:798:5: note: Analyze phi: ivtmp_270 = PHI <ivtmp_271(71), 256(74)>
embann.c:798:5: note: Access function of PHI: {256, +, 65535}_15
embann.c:798:5: note: step: 65535,  init: 256
embann.c:798:5: note: Detected induction.
embann.c:798:5: note: === vect_analyze_scalar_cycles ===
embann.c:798:5: note: Analyze phi: .MEM_54 = PHI <.MEM_177(67), .MEM_217(69)>
embann.c:798:5: note: Analyze phi: i_264 = PHI <i_223(67), i_265(69)>
embann.c:798:5: note: Access function of PHI: {i_223, +, 1}_14
embann.c:798:5: note: step: 1,  init: i_223
embann.c:798:5: note: Detected induction.
embann.c:798:5: note: Analyze phi: ivtmp_272 = PHI <_274(67), ivtmp_273(69)>
embann.c:798:5: note: Access function of PHI: {_274, +, 4294967295}_14
embann.c:798:5: note: step: 4294967295,  init: _274
embann.c:798:5: note: Detected induction.
embann.c:798:5: note: === vect_pattern_recog ===
embann.c:798:5: note: === vect_analyze_data_ref_accesses ===
embann.c:798:5: note: zero step in inner loop of nest
embann.c:798:5: note: not vectorized: complicated access pattern.
embann.c:798:5: note: bad data access.

Analyzing loop at embann.c:800
embann.c:800:9: note: ===== analyze_loop_nest =====
embann.c:800:9: note: === vect_analyze_loop_form ===
embann.c:800:9: note: === get_loop_niters ===
embann.c:800:9: note: Symbolic number of iterations is _263 + 1
embann.c:800:9: note: === vect_analyze_data_refs ===
embann.c:800:9: note: got vectype for stmt: _204 = testInt[_68];
vector(4) int
embann.c:800:9: note: got vectype for stmt: _192 = testIntWeight[_68];
vector(4) int
embann.c:800:9: note: got vectype for stmt: _215 = testIntBias[_68];
vector(4) int
embann.c:800:9: note: got vectype for stmt: testInt[_68] = _216;
vector(4) int
embann.c:800:9: note: === vect_analyze_scalar_cycles ===
embann.c:800:9: note: Analyze phi: .MEM_54 = PHI <.MEM_177(67), .MEM_217(69)>
embann.c:800:9: note: Analyze phi: i_264 = PHI <i_223(67), i_265(69)>
embann.c:800:9: note: Access function of PHI: {i_223, +, 1}_14
embann.c:800:9: note: step: 1,  init: i_223
embann.c:800:9: note: Detected induction.
embann.c:800:9: note: Analyze phi: ivtmp_272 = PHI <_274(67), ivtmp_273(69)>
embann.c:800:9: note: Access function of PHI: {_274, +, 4294967295}_14
embann.c:800:9: note: step: 4294967295,  init: _274
embann.c:800:9: note: Detected induction.
embann.c:800:9: note: === vect_pattern_recog ===
embann.c:800:9: note: === vect_analyze_data_ref_accesses ===
embann.c:800:9: note: not vectorized: complicated access pattern.
embann.c:800:9: note: bad data access.
embann.c:770:6: note: ===== analyze_loop_nest =====
embann.c:770:6: note: === vect_analyze_loop_form ===
embann.c:770:6: note: === vect_analyze_loop_form ===
embann.c:770:6: note: === get_loop_niters ===
embann.c:770:6: note: Considering outer-loop vectorization.
embann.c:770:6: note: === get_loop_niters ===
embann.c:770:6: note: === vect_analyze_data_refs ===
embann.c:770:6: note: analyze in outer loop: testInt
embann.c:770:6: note: 	outer base_address: &testInt
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 0
	outer base alignment: 32

	outer base misalignment: 0

	outer offset alignment: 256

	outer step alignment: 256
embann.c:770:6: note: got vectype for stmt: _30 = testInt[_29];
vector(4) int
embann.c:770:6: note: analyze in outer loop: testIntWeight
embann.c:770:6: note: 	outer base_address: &testIntWeight
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 0
	outer base alignment: 32

	outer base misalignment: 0

	outer offset alignment: 256

	outer step alignment: 256
embann.c:770:6: note: got vectype for stmt: _31 = testIntWeight[_29];
vector(4) int
embann.c:770:6: note: analyze in outer loop: testIntBias
embann.c:770:6: note: 	outer base_address: &testIntBias
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 0
	outer base alignment: 32

	outer base misalignment: 0

	outer offset alignment: 256

	outer step alignment: 256
embann.c:770:6: note: got vectype for stmt: _33 = testIntBias[_29];
vector(4) int
embann.c:770:6: note: analyze in outer loop: testInt
embann.c:770:6: note: 	outer base_address: &testInt
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 0
	outer base alignment: 32

	outer base misalignment: 0

	outer offset alignment: 256

	outer step alignment: 256
embann.c:770:6: note: got vectype for stmt: testInt[_29] = _34;
vector(4) int
embann.c:770:6: note: analyze in outer loop: testInt
embann.c:770:6: note: 	outer base_address: &testInt
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 0
	outer base alignment: 32

	outer base misalignment: 0

	outer offset alignment: 256

	outer step alignment: 256
embann.c:770:6: note: got vectype for stmt: _230 = testInt[_229];
vector(4) int
embann.c:770:6: note: analyze in outer loop: testIntWeight
embann.c:770:6: note: 	outer base_address: &testIntWeight
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 0
	outer base alignment: 32

	outer base misalignment: 0

	outer offset alignment: 256

	outer step alignment: 256
embann.c:770:6: note: got vectype for stmt: _231 = testIntWeight[_229];
vector(4) int
embann.c:770:6: note: analyze in outer loop: testIntBias
embann.c:770:6: note: 	outer base_address: &testIntBias
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 0
	outer base alignment: 32

	outer base misalignment: 0

	outer offset alignment: 256

	outer step alignment: 256
embann.c:770:6: note: got vectype for stmt: _233 = testIntBias[_229];
vector(4) int
embann.c:770:6: note: analyze in outer loop: testInt
embann.c:770:6: note: 	outer base_address: &testInt
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 0
	outer base alignment: 32

	outer base misalignment: 0

	outer offset alignment: 256

	outer step alignment: 256
embann.c:770:6: note: got vectype for stmt: testInt[_229] = _234;
vector(4) int
embann.c:770:6: note: === vect_analyze_scalar_cycles ===
embann.c:770:6: note: Analyze phi: i_163 = PHI <0(4), i_239(82)>
embann.c:770:6: note: Access function of PHI: {0, +, 2}_2
embann.c:770:6: note: step: 2,  init: 0
embann.c:770:6: note: Detected induction.
embann.c:770:6: note: Analyze phi: .MEM_171 = PHI <.MEM_104(4), .MEM_235(82)>
embann.c:770:6: note: Analyze phi: ivtmp_240 = PHI <1(4), ivtmp_241(82)>
embann.c:770:6: note: Access function of PHI: {1, +, 2}_2
embann.c:770:6: note: step: 2,  init: 1
embann.c:770:6: note: Detected induction.
embann.c:770:6: note: Analyze phi: ivtmp_148 = PHI <49999(4), ivtmp_149(82)>
embann.c:770:6: note: Access function of PHI: {49999, +, 4294967295}_2
embann.c:770:6: note: step: 4294967295,  init: 49999
embann.c:770:6: note: Detected induction.
embann.c:770:6: note: === vect_analyze_scalar_cycles ===
embann.c:770:6: note: Analyze phi: j_164 = PHI <0(7), j_238(79)>
embann.c:770:6: note: Access function of PHI: {0, +, 1}_7
embann.c:770:6: note: step: 1,  init: 0
embann.c:770:6: note: Detected induction.
embann.c:770:6: note: Analyze phi: .MEM_170 = PHI <.MEM_171(7), .MEM_235(79)>
embann.c:770:6: note: Analyze phi: ivtmp_120 = PHI <256(7), ivtmp_147(79)>
embann.c:770:6: note: Access function of PHI: {256, +, 65535}_7
embann.c:770:6: note: step: 65535,  init: 256
embann.c:770:6: note: Detected induction.
embann.c:770:6: note: === vect_pattern_recog ===
embann.c:770:6: note: === vect_analyze_data_ref_accesses ===
embann.c:770:6: note: zero step in outer loop.
embann.c:770:6: note: zero step in outer loop.
embann.c:770:6: note: zero step in outer loop.
embann.c:770:6: note: not vectorized: complicated access pattern.
embann.c:770:6: note: bad data access.

Analyzing loop at embann.c:800
embann.c:800:9: note: ===== analyze_loop_nest =====
embann.c:800:9: note: === vect_analyze_loop_form ===
embann.c:800:9: note: === get_loop_niters ===
embann.c:800:9: note: === vect_analyze_data_refs ===
embann.c:800:9: note: got vectype for stmt: _30 = testInt[_29];
vector(4) int
embann.c:800:9: note: got vectype for stmt: _31 = testIntWeight[_29];
vector(4) int
embann.c:800:9: note: got vectype for stmt: _33 = testIntBias[_29];
vector(4) int
embann.c:800:9: note: got vectype for stmt: testInt[_29] = _34;
vector(4) int
embann.c:800:9: note: got vectype for stmt: _230 = testInt[_229];
vector(4) int
embann.c:800:9: note: got vectype for stmt: _231 = testIntWeight[_229];
vector(4) int
embann.c:800:9: note: got vectype for stmt: _233 = testIntBias[_229];
vector(4) int
embann.c:800:9: note: got vectype for stmt: testInt[_229] = _234;
vector(4) int
embann.c:800:9: note: === vect_analyze_scalar_cycles ===
embann.c:800:9: note: Analyze phi: j_164 = PHI <0(7), j_238(79)>
embann.c:800:9: note: Access function of PHI: {0, +, 1}_7
embann.c:800:9: note: step: 1,  init: 0
embann.c:800:9: note: Detected induction.
embann.c:800:9: note: Analyze phi: .MEM_170 = PHI <.MEM_171(7), .MEM_235(79)>
embann.c:800:9: note: Analyze phi: ivtmp_120 = PHI <256(7), ivtmp_147(79)>
embann.c:800:9: note: Access function of PHI: {256, +, 65535}_7
embann.c:800:9: note: step: 65535,  init: 256
embann.c:800:9: note: Detected induction.
embann.c:800:9: note: === vect_pattern_recog ===
embann.c:800:9: note: === vect_analyze_data_ref_accesses ===
embann.c:800:9: note: === vect_mark_stmts_to_be_vectorized ===
embann.c:800:9: note: init: phi relevant? j_164 = PHI <0(7), j_238(79)>
embann.c:800:9: note: init: phi relevant? .MEM_170 = PHI <.MEM_171(7), .MEM_235(79)>
embann.c:800:9: note: init: phi relevant? ivtmp_120 = PHI <256(7), ivtmp_147(79)>
embann.c:800:9: note: init: stmt relevant? _29 = (int) j_164;
embann.c:800:9: note: init: stmt relevant? _30 = testInt[_29];
embann.c:800:9: note: init: stmt relevant? _31 = testIntWeight[_29];
embann.c:800:9: note: init: stmt relevant? _32 = _30 / _31;
embann.c:800:9: note: init: stmt relevant? _33 = testIntBias[_29];
embann.c:800:9: note: init: stmt relevant? _34 = _32 + _33;
embann.c:800:9: note: init: stmt relevant? testInt[_29] = _34;
embann.c:800:9: note: vec_stmt_relevant_p: stmt has vdefs.
embann.c:800:9: note: mark relevant 5, live 0: testInt[_29] = _34;
embann.c:800:9: note: init: stmt relevant? i_108 = i_163 + 1;
embann.c:800:9: note: vec_stmt_relevant_p: used out of loop.
embann.c:800:9: note: vect_is_simple_use: operand i_163
embann.c:800:9: note: def_stmt: i_163 = PHI <0(4), i_239(82)>
embann.c:800:9: note: type of def: external
embann.c:800:9: note: mark relevant 0, live 1: i_108 = i_163 + 1;
embann.c:800:9: note: init: stmt relevant? _229 = (int) j_164;
embann.c:800:9: note: init: stmt relevant? _230 = testInt[_229];
embann.c:800:9: note: init: stmt relevant? _231 = testIntWeight[_229];
embann.c:800:9: note: init: stmt relevant? _232 = _230 / _231;
embann.c:800:9: note: init: stmt relevant? _233 = testIntBias[_229];
embann.c:800:9: note: init: stmt relevant? _234 = _232 + _233;
embann.c:800:9: note: init: stmt relevant? testInt[_229] = _234;
embann.c:800:9: note: vec_stmt_relevant_p: stmt has vdefs.
embann.c:800:9: note: mark relevant 5, live 0: testInt[_229] = _234;
embann.c:800:9: note: init: stmt relevant? j.148_236 = (unsigned short) j_164;
embann.c:800:9: note: init: stmt relevant? _237 = j.148_236 + 1;
embann.c:800:9: note: init: stmt relevant? j_238 = (int16_t) _237;
embann.c:800:9: note: init: stmt relevant? ivtmp_147 = ivtmp_120 - 1;
embann.c:800:9: note: init: stmt relevant? if (ivtmp_147 != 0)
embann.c:800:9: note: worklist: examine stmt: testInt[_229] = _234;
embann.c:800:9: note: vect_is_simple_use: operand _234
embann.c:800:9: note: def_stmt: _234 = _232 + _233;
embann.c:800:9: note: type of def: internal
embann.c:800:9: note: mark relevant 5, live 0: _234 = _232 + _233;
embann.c:800:9: note: worklist: examine stmt: _234 = _232 + _233;
embann.c:800:9: note: vect_is_simple_use: operand _232
embann.c:800:9: note: def_stmt: _232 = _230 / _231;
embann.c:800:9: note: type of def: internal
embann.c:800:9: note: mark relevant 5, live 0: _232 = _230 / _231;
embann.c:800:9: note: vect_is_simple_use: operand _233
embann.c:800:9: note: def_stmt: _233 = testIntBias[_229];
embann.c:800:9: note: type of def: internal
embann.c:800:9: note: mark relevant 5, live 0: _233 = testIntBias[_229];
embann.c:800:9: note: worklist: examine stmt: _233 = testIntBias[_229];
embann.c:800:9: note: worklist: examine stmt: _232 = _230 / _231;
embann.c:800:9: note: vect_is_simple_use: operand _230
embann.c:800:9: note: def_stmt: _230 = testInt[_229];
embann.c:800:9: note: type of def: internal
embann.c:800:9: note: mark relevant 5, live 0: _230 = testInt[_229];
embann.c:800:9: note: vect_is_simple_use: operand _231
embann.c:800:9: note: def_stmt: _231 = testIntWeight[_229];
embann.c:800:9: note: type of def: internal
embann.c:800:9: note: mark relevant 5, live 0: _231 = testIntWeight[_229];
embann.c:800:9: note: worklist: examine stmt: _231 = testIntWeight[_229];
embann.c:800:9: note: worklist: examine stmt: _230 = testInt[_229];
embann.c:800:9: note: worklist: examine stmt: i_108 = i_163 + 1;
embann.c:800:9: note: vect_is_simple_use: operand i_163
embann.c:800:9: note: def_stmt: i_163 = PHI <0(4), i_239(82)>
embann.c:800:9: note: type of def: external
embann.c:800:9: note: def_stmt is out of loop.
embann.c:800:9: note: worklist: examine stmt: testInt[_29] = _34;
embann.c:800:9: note: vect_is_simple_use: operand _34
embann.c:800:9: note: def_stmt: _34 = _32 + _33;
embann.c:800:9: note: type of def: internal
embann.c:800:9: note: mark relevant 5, live 0: _34 = _32 + _33;
embann.c:800:9: note: worklist: examine stmt: _34 = _32 + _33;
embann.c:800:9: note: vect_is_simple_use: operand _32
embann.c:800:9: note: def_stmt: _32 = _30 / _31;
embann.c:800:9: note: type of def: internal
embann.c:800:9: note: mark relevant 5, live 0: _32 = _30 / _31;
embann.c:800:9: note: vect_is_simple_use: operand _33
embann.c:800:9: note: def_stmt: _33 = testIntBias[_29];
embann.c:800:9: note: type of def: internal
embann.c:800:9: note: mark relevant 5, live 0: _33 = testIntBias[_29];
embann.c:800:9: note: worklist: examine stmt: _33 = testIntBias[_29];
embann.c:800:9: note: worklist: examine stmt: _32 = _30 / _31;
embann.c:800:9: note: vect_is_simple_use: operand _30
embann.c:800:9: note: def_stmt: _30 = testInt[_29];
embann.c:800:9: note: type of def: internal
embann.c:800:9: note: mark relevant 5, live 0: _30 = testInt[_29];
embann.c:800:9: note: vect_is_simple_use: operand _31
embann.c:800:9: note: def_stmt: _31 = testIntWeight[_29];
embann.c:800:9: note: type of def: internal
embann.c:800:9: note: mark relevant 5, live 0: _31 = testIntWeight[_29];
embann.c:800:9: note: worklist: examine stmt: _31 = testIntWeight[_29];
embann.c:800:9: note: worklist: examine stmt: _30 = testInt[_29];
embann.c:800:9: note: === vect_analyze_data_ref_dependences ===
embann.c:800:9: note: dependence distance  = 0.
embann.c:800:9: note: dependence distance == 0 between testInt[_29] and testInt[_29]
embann.c:800:9: note: dependence distance  = 0.
embann.c:800:9: note: dependence distance == 0 between testInt[_29] and testInt[_229]
embann.c:800:9: note: dependence distance  = 0.
embann.c:800:9: note: dependence distance == 0 between testInt[_29] and testInt[_229]
embann.c:800:9: note: dependence distance  = 0.
embann.c:800:9: note: dependence distance == 0 between testInt[_29] and testInt[_229]
embann.c:800:9: note: dependence distance  = 0.
embann.c:800:9: note: dependence distance == 0 between testInt[_229] and testInt[_229]
embann.c:800:9: note: === vect_determine_vectorization_factor ===
embann.c:800:9: note: ==> examining phi: j_164 = PHI <0(7), j_238(79)>
embann.c:800:9: note: ==> examining phi: .MEM_170 = PHI <.MEM_171(7), .MEM_235(79)>
embann.c:800:9: note: ==> examining phi: ivtmp_120 = PHI <256(7), ivtmp_147(79)>
embann.c:800:9: note: ==> examining statement: _29 = (int) j_164;
embann.c:800:9: note: skip.
embann.c:800:9: note: ==> examining statement: _30 = testInt[_29];
embann.c:800:9: note: get vectype for scalar type:  int
embann.c:800:9: note: vectype: vector(4) int
embann.c:800:9: note: nunits = 4
embann.c:800:9: note: ==> examining statement: _31 = testIntWeight[_29];
embann.c:800:9: note: get vectype for scalar type:  int
embann.c:800:9: note: vectype: vector(4) int
embann.c:800:9: note: nunits = 4
embann.c:800:9: note: ==> examining statement: _32 = _30 / _31;
embann.c:800:9: note: get vectype for scalar type:  int
embann.c:800:9: note: vectype: vector(4) int
embann.c:800:9: note: get vectype for scalar type:  int
embann.c:800:9: note: vectype: vector(4) int
embann.c:800:9: note: nunits = 4
embann.c:800:9: note: ==> examining statement: _33 = testIntBias[_29];
embann.c:800:9: note: get vectype for scalar type:  int
embann.c:800:9: note: vectype: vector(4) int
embann.c:800:9: note: nunits = 4
embann.c:800:9: note: ==> examining statement: _34 = _32 + _33;
embann.c:800:9: note: get vectype for scalar type:  int
embann.c:800:9: note: vectype: vector(4) int
embann.c:800:9: note: get vectype for scalar type:  int
embann.c:800:9: note: vectype: vector(4) int
embann.c:800:9: note: nunits = 4
embann.c:800:9: note: ==> examining statement: testInt[_29] = _34;
embann.c:800:9: note: get vectype for scalar type:  int32_t
embann.c:800:9: note: vectype: vector(4) int
embann.c:800:9: note: nunits = 4
embann.c:800:9: note: ==> examining statement: i_108 = i_163 + 1;
embann.c:800:9: note: get vectype for scalar type:  int32_t
embann.c:800:9: note: vectype: vector(4) int
embann.c:800:9: note: get vectype for scalar type:  int32_t
embann.c:800:9: note: vectype: vector(4) int
embann.c:800:9: note: nunits = 4
embann.c:800:9: note: ==> examining statement: _229 = (int) j_164;
embann.c:800:9: note: skip.
embann.c:800:9: note: ==> examining statement: _230 = testInt[_229];
embann.c:800:9: note: get vectype for scalar type:  int
embann.c:800:9: note: vectype: vector(4) int
embann.c:800:9: note: nunits = 4
embann.c:800:9: note: ==> examining statement: _231 = testIntWeight[_229];
embann.c:800:9: note: get vectype for scalar type:  int
embann.c:800:9: note: vectype: vector(4) int
embann.c:800:9: note: nunits = 4
embann.c:800:9: note: ==> examining statement: _232 = _230 / _231;
embann.c:800:9: note: get vectype for scalar type:  int
embann.c:800:9: note: vectype: vector(4) int
embann.c:800:9: note: get vectype for scalar type:  int
embann.c:800:9: note: vectype: vector(4) int
embann.c:800:9: note: nunits = 4
embann.c:800:9: note: ==> examining statement: _233 = testIntBias[_229];
embann.c:800:9: note: get vectype for scalar type:  int
embann.c:800:9: note: vectype: vector(4) int
embann.c:800:9: note: nunits = 4
embann.c:800:9: note: ==> examining statement: _234 = _232 + _233;
embann.c:800:9: note: get vectype for scalar type:  int
embann.c:800:9: note: vectype: vector(4) int
embann.c:800:9: note: get vectype for scalar type:  int
embann.c:800:9: note: vectype: vector(4) int
embann.c:800:9: note: nunits = 4
embann.c:800:9: note: ==> examining statement: testInt[_229] = _234;
embann.c:800:9: note: get vectype for scalar type:  int32_t
embann.c:800:9: note: vectype: vector(4) int
embann.c:800:9: note: nunits = 4
embann.c:800:9: note: ==> examining statement: j.148_236 = (unsigned short) j_164;
embann.c:800:9: note: skip.
embann.c:800:9: note: ==> examining statement: _237 = j.148_236 + 1;
embann.c:800:9: note: skip.
embann.c:800:9: note: ==> examining statement: j_238 = (int16_t) _237;
embann.c:800:9: note: skip.
embann.c:800:9: note: ==> examining statement: ivtmp_147 = ivtmp_120 - 1;
embann.c:800:9: note: skip.
embann.c:800:9: note: ==> examining statement: if (ivtmp_147 != 0)
embann.c:800:9: note: skip.
embann.c:800:9: note: vectorization factor = 4
embann.c:800:9: note: === vect_analyze_slp ===
embann.c:800:9: note: === vect_make_slp_decision ===
embann.c:800:9: note: vectorization_factor = 4, niters = 256
embann.c:800:9: note: === vect_analyze_data_refs_alignment ===
embann.c:800:9: note: accesses have the same alignment: testInt[_29] and testInt[_29]
embann.c:800:9: note: accesses have the same alignment: testInt[_29] and testInt[_229]
embann.c:800:9: note: accesses have the same alignment: testInt[_29] and testInt[_229]
embann.c:800:9: note: accesses have the same alignment: testIntWeight[_29] and testIntWeight[_229]
embann.c:800:9: note: accesses have the same alignment: testIntBias[_29] and testIntBias[_229]
embann.c:800:9: note: accesses have the same alignment: testInt[_29] and testInt[_229]
embann.c:800:9: note: accesses have the same alignment: testInt[_29] and testInt[_229]
embann.c:800:9: note: accesses have the same alignment: testInt[_229] and testInt[_229]
embann.c:800:9: note: recording new base alignment for &testInt
embann.c:800:9: note:   alignment:    32
embann.c:800:9: note:   misalignment: 0
embann.c:800:9: note:   based on:     _30 = testInt[_29];
embann.c:800:9: note: recording new base alignment for &testIntWeight
embann.c:800:9: note:   alignment:    32
embann.c:800:9: note:   misalignment: 0
embann.c:800:9: note:   based on:     _31 = testIntWeight[_29];
embann.c:800:9: note: recording new base alignment for &testIntBias
embann.c:800:9: note:   alignment:    32
embann.c:800:9: note:   misalignment: 0
embann.c:800:9: note:   based on:     _33 = testIntBias[_29];
embann.c:800:9: note: vect_compute_data_ref_alignment:
embann.c:800:9: note: misalign = 0 bytes of ref testInt[_29]
embann.c:800:9: note: vect_compute_data_ref_alignment:
embann.c:800:9: note: misalign = 0 bytes of ref testIntWeight[_29]
embann.c:800:9: note: vect_compute_data_ref_alignment:
embann.c:800:9: note: misalign = 0 bytes of ref testIntBias[_29]
embann.c:800:9: note: vect_compute_data_ref_alignment:
embann.c:800:9: note: misalign = 0 bytes of ref testInt[_29]
embann.c:800:9: note: vect_compute_data_ref_alignment:
embann.c:800:9: note: misalign = 0 bytes of ref testInt[_229]
embann.c:800:9: note: vect_compute_data_ref_alignment:
embann.c:800:9: note: misalign = 0 bytes of ref testIntWeight[_229]
embann.c:800:9: note: vect_compute_data_ref_alignment:
embann.c:800:9: note: misalign = 0 bytes of ref testIntBias[_229]
embann.c:800:9: note: vect_compute_data_ref_alignment:
embann.c:800:9: note: misalign = 0 bytes of ref testInt[_229]
embann.c:800:9: note: === vect_prune_runtime_alias_test_list ===
embann.c:800:9: note: === vect_enhance_data_refs_alignment ===
embann.c:800:9: note: vect_can_advance_ivs_p:
embann.c:800:9: note: Analyze phi: j_164 = PHI <0(7), j_238(79)>
embann.c:800:9: note: Analyze phi: .MEM_170 = PHI <.MEM_171(7), .MEM_235(79)>
embann.c:800:9: note: reduc or virtual phi. skip.
embann.c:800:9: note: Analyze phi: ivtmp_120 = PHI <256(7), ivtmp_147(79)>
embann.c:800:9: note: vect_model_load_cost: aligned.
embann.c:800:9: note: vect_get_data_access_cost: inside_cost = 12, outside_cost = 0.
embann.c:800:9: note: vect_model_load_cost: aligned.
embann.c:800:9: note: vect_get_data_access_cost: inside_cost = 24, outside_cost = 0.
embann.c:800:9: note: vect_model_load_cost: aligned.
embann.c:800:9: note: vect_get_data_access_cost: inside_cost = 36, outside_cost = 0.
embann.c:800:9: note: vect_model_store_cost: aligned.
embann.c:800:9: note: vect_get_data_access_cost: inside_cost = 52, outside_cost = 0.
embann.c:800:9: note: vect_model_load_cost: aligned.
embann.c:800:9: note: vect_get_data_access_cost: inside_cost = 64, outside_cost = 0.
embann.c:800:9: note: vect_model_load_cost: aligned.
embann.c:800:9: note: vect_get_data_access_cost: inside_cost = 76, outside_cost = 0.
embann.c:800:9: note: vect_model_load_cost: aligned.
embann.c:800:9: note: vect_get_data_access_cost: inside_cost = 88, outside_cost = 0.
embann.c:800:9: note: vect_model_store_cost: aligned.
embann.c:800:9: note: vect_get_data_access_cost: inside_cost = 104, outside_cost = 0.
embann.c:800:9: note: === vect_analyze_loop_operations ===
embann.c:800:9: note: examining phi: j_164 = PHI <0(7), j_238(79)>
embann.c:800:9: note: examining phi: .MEM_170 = PHI <.MEM_171(7), .MEM_235(79)>
embann.c:800:9: note: examining phi: ivtmp_120 = PHI <256(7), ivtmp_147(79)>
embann.c:800:9: note: ==> examining statement: _29 = (int) j_164;
embann.c:800:9: note: irrelevant.
embann.c:800:9: note: ==> examining statement: _30 = testInt[_29];
embann.c:800:9: note: num. args = 4 (not unary/binary/ternary op).
embann.c:800:9: note: vect_is_simple_use: operand testInt[_29]
embann.c:800:9: note: not ssa-name.
embann.c:800:9: note: use not simple.
embann.c:800:9: note: vect_model_load_cost: aligned.
embann.c:800:9: note: vect_model_load_cost: inside_cost = 12, prologue_cost = 0 .
embann.c:800:9: note: ==> examining statement: _31 = testIntWeight[_29];
embann.c:800:9: note: num. args = 4 (not unary/binary/ternary op).
embann.c:800:9: note: vect_is_simple_use: operand testIntWeight[_29]
embann.c:800:9: note: not ssa-name.
embann.c:800:9: note: use not simple.
embann.c:800:9: note: vect_model_load_cost: aligned.
embann.c:800:9: note: vect_model_load_cost: inside_cost = 12, prologue_cost = 0 .
embann.c:800:9: note: ==> examining statement: _32 = _30 / _31;
embann.c:800:9: note: vect_is_simple_use: operand _30
embann.c:800:9: note: def_stmt: _30 = testInt[_29];
embann.c:800:9: note: type of def: internal
embann.c:800:9: note: vect_is_simple_use: operand _31
embann.c:800:9: note: def_stmt: _31 = testIntWeight[_29];
embann.c:800:9: note: type of def: internal
embann.c:800:9: note: op not supported by target.
embann.c:800:9: note: not vectorized: relevant stmt not supported: _32 = _30 / _31;
embann.c:800:9: note: bad operation or unsupported loop bound.

Analyzing loop at embann.c:785
embann.c:785:5: note: ===== analyze_loop_nest =====
embann.c:785:5: note: === vect_analyze_loop_form ===
embann.c:785:5: note: === get_loop_niters ===
embann.c:785:5: note: not vectorized: loop contains function calls or data references that cannot be analyzed
embann.c:770:6: note: vectorized 2 loops in function.
embann.c:770:6: note: ===vect_slp_analyze_bb===
embann.c:774:42: note: === vect_analyze_data_refs ===
embann.c:774:42: note: not vectorized: no vectype for stmt: testInt = {};
 scalar_type: int32_t[256]
embann.c:774:42: note: got vectype for stmt: testInt[0] = 2147483647;
vector(4) int
embann.c:774:42: note: not vectorized: no vectype for stmt: testFloat = {};
 scalar_type: float[256]
embann.c:774:42: note: got vectype for stmt: testFloat[0] = 3.4028234663852885981170418348451692544e+38;
vector(4) float
embann.c:774:42: note: not vectorized: no vectype for stmt: testDouble = {};
 scalar_type: double[256]
embann.c:774:42: note: got vectype for stmt: testDouble[0] = 1.79769313486231570814527423731704356798070567525844996599e+308;
vector(2) double
embann.c:774:42: note: === vect_analyze_data_ref_accesses ===
embann.c:774:42: note: not consecutive access testInt[0] = 2147483647;
embann.c:774:42: note: not consecutive access testFloat[0] = 3.4028234663852885981170418348451692544e+38;
embann.c:774:42: note: not consecutive access testDouble[0] = 1.79769313486231570814527423731704356798070567525844996599e+308;
embann.c:774:42: note: not vectorized: no grouped stores in basic block.
embann.c:774:42: note: ===vect_slp_analyze_bb===
embann.c:788:38: note: === vect_analyze_data_refs ===
embann.c:788:38: note: got vectype for stmt: testIntWeight[_5] = _6;
vector(4) int
embann.c:788:38: note: not vectorized: not enough data-refs in basic block.
embann.c:789:39: note: === vect_analyze_data_refs ===
embann.c:789:39: note: got vectype for stmt: testFloatWeight[_5] = _10;
vector(4) float
embann.c:789:39: note: not vectorized: not enough data-refs in basic block.
embann.c:791:27: note: === vect_analyze_data_refs ===
embann.c:791:27: note: got vectype for stmt: testDoubleWeight[_5] = _15;
vector(2) double
embann.c:791:27: note: not vectorized: not enough data-refs in basic block.
embann.c:792:36: note: === vect_analyze_data_refs ===
embann.c:792:36: note: got vectype for stmt: testIntBias[_5] = _20;
vector(4) int
embann.c:792:36: note: not vectorized: not enough data-refs in basic block.
embann.c:793:38: note: === vect_analyze_data_refs ===
embann.c:793:38: note: got vectype for stmt: testFloatBias[_5] = _24;
vector(4) float
embann.c:793:38: note: not vectorized: not enough data-refs in basic block.
embann.c:785:5: note: === vect_analyze_data_refs ===
embann.c:785:5: note: got vectype for stmt: testDoubleBias[_5] = _28;
vector(2) double
embann.c:785:5: note: not vectorized: not enough data-refs in basic block.
embann.c:785:5: note: ===vect_slp_analyze_bb===
embann.c:785:5: note: ===vect_slp_analyze_bb===
embann.c:796:5: note: ===vect_slp_analyze_bb===
embann.c:800:9: note: === vect_analyze_data_refs ===
embann.c:800:9: note: got vectype for stmt: _30 = testInt[_29];
vector(4) int
embann.c:800:9: note: got vectype for stmt: _31 = testIntWeight[_29];
vector(4) int
embann.c:800:9: note: got vectype for stmt: _33 = testIntBias[_29];
vector(4) int
embann.c:800:9: note: got vectype for stmt: testInt[_29] = _34;
vector(4) int
embann.c:800:9: note: got vectype for stmt: testInt[_229] = _234;
vector(4) int
embann.c:800:9: note: === vect_analyze_data_ref_accesses ===
embann.c:800:9: note: not consecutive access _30 = testInt[_29];
embann.c:800:9: note: not consecutive access testInt[_29] = _34;
embann.c:800:9: note: not consecutive access testInt[_229] = _234;
embann.c:800:9: note: not consecutive access _31 = testIntWeight[_29];
embann.c:800:9: note: not consecutive access _33 = testIntBias[_29];
embann.c:800:9: note: not vectorized: no grouped stores in basic block.
embann.c:800:9: note: ===vect_slp_analyze_bb===
embann.c:800:9: note: ===vect_slp_analyze_bb===
embann.c:798:38: note: === vect_analyze_data_refs ===
embann.c:798:38: note: not vectorized: not enough data-refs in basic block.
embann.c:798:38: note: ===vect_slp_analyze_bb===
embann.c:798:38: note: ===vect_slp_analyze_bb===
embann.c:798:38: note: === vect_analyze_data_refs ===
embann.c:798:38: note: not vectorized: not enough data-refs in basic block.
embann.c:798:38: note: ===vect_slp_analyze_bb===
embann.c:798:38: note: === vect_analyze_data_refs ===
embann.c:798:38: note: got vectype for stmt: testIntBias_I_lsm0.568_137 = MEM[(int *)_145];
vector(4) int
embann.c:798:38: note: got vectype for stmt: testIntWeight_I_lsm0.569_205 = MEM[(int *)_142];
vector(4) int
embann.c:798:38: note: got vectype for stmt: _243 = MEM[(int *)_138];
vector(4) int
embann.c:798:38: note: === vect_analyze_data_ref_accesses ===
embann.c:798:38: note: not consecutive access _243 = MEM[(int *)_138];
embann.c:798:38: note: not consecutive access testIntWeight_I_lsm0.569_205 = MEM[(int *)_142];
embann.c:798:38: note: not consecutive access testIntBias_I_lsm0.568_137 = MEM[(int *)_145];
embann.c:798:38: note: not vectorized: no grouped stores in basic block.
embann.c:798:38: note: ===vect_slp_analyze_bb===
embann.c:800:9: note: === vect_analyze_data_refs ===
embann.c:800:9: note: got vectype for stmt: testInt[_68] = _216;
vector(4) int
embann.c:800:9: note: not vectorized: not enough data-refs in basic block.
embann.c:800:9: note: ===vect_slp_analyze_bb===
embann.c:800:9: note: ===vect_slp_analyze_bb===
embann.c:798:5: note: === vect_analyze_data_refs ===
embann.c:798:5: note: not vectorized: not enough data-refs in basic block.
embann.c:798:5: note: ===vect_slp_analyze_bb===
embann.c:798:5: note: ===vect_slp_analyze_bb===
embann.c:798:5: note: ===vect_slp_analyze_bb===
embann.c:806:5: note: === vect_analyze_data_refs ===
embann.c:806:5: note: got vectype for stmt: pretmp_190 = testInt[0];
vector(4) int
embann.c:806:5: note: not vectorized: not enough data-refs in basic block.
embann.c:807:19: note: === vect_analyze_data_refs ===
embann.c:807:19: note: got vectype for stmt: _37 = timeAfter.tv_usec;
vector(2) long int
embann.c:807:19: note: got vectype for stmt: _38 = timeBefore.tv_usec;
vector(2) long int
embann.c:807:19: note: === vect_analyze_data_ref_accesses ===
embann.c:807:19: note: not consecutive access _38 = timeBefore.tv_usec;
embann.c:807:19: note: not consecutive access _37 = timeAfter.tv_usec;
embann.c:807:19: note: not vectorized: no grouped stores in basic block.
embann.c:807:19: note: ===vect_slp_analyze_bb===
embann.c:807:15: note: === vect_analyze_data_refs ===
embann.c:807:15: note: not vectorized: not enough data-refs in basic block.
embann.c:807:15: note: ===vect_slp_analyze_bb===
embann.c:810:5: note: ===vect_slp_analyze_bb===
embann.c:817:26: note: === vect_analyze_data_refs ===
embann.c:817:26: note: not vectorized: no vectype for stmt: vect__43.526_303 = MEM[(float *)vectp_testFloat.524_301];
 scalar_type: vector(4) float
embann.c:817:26: note: not vectorized: no vectype for stmt: vect__44.529_306 = MEM[(float *)vectp_testFloatWeight.527_304];
 scalar_type: vector(4) float
embann.c:817:26: note: not vectorized: no vectype for stmt: vect__46.533_310 = MEM[(float *)vectp_testFloatBias.531_308];
 scalar_type: vector(4) float
embann.c:817:26: note: not vectorized: no vectype for stmt: MEM[(float *)vectp_testFloat.535_312] = vect__47.534_311;
 scalar_type: vector(4) float
embann.c:817:26: note: not vectorized: no vectype for stmt: MEM[(float *)vectp_testFloat.548_326] = vect__191.547_325;
 scalar_type: vector(4) float
embann.c:817:26: note: === vect_analyze_data_ref_accesses ===
embann.c:817:26: note: not vectorized: no grouped stores in basic block.
embann.c:817:26: note: ===vect_slp_analyze_bb===
embann.c:817:26: note: ===vect_slp_analyze_bb===
embann.c:812:38: note: === vect_analyze_data_refs ===
embann.c:812:38: note: not vectorized: not enough data-refs in basic block.
embann.c:812:38: note: ===vect_slp_analyze_bb===
embann.c:812:38: note: ===vect_slp_analyze_bb===
embann.c:812:38: note: === vect_analyze_data_refs ===
embann.c:812:38: note: not vectorized: not enough data-refs in basic block.
embann.c:812:38: note: ===vect_slp_analyze_bb===
embann.c:812:38: note: === vect_analyze_data_refs ===
embann.c:812:38: note: got vectype for stmt: testFloatBias_I_lsm0.565_56 = MEM[(float *)_186];
vector(4) float
embann.c:812:38: note: got vectype for stmt: testFloatWeight_I_lsm0.566_57 = MEM[(float *)_48];
vector(4) float
embann.c:812:38: note: got vectype for stmt: _60 = MEM[(float *)_256];
vector(4) float
embann.c:812:38: note: === vect_analyze_data_ref_accesses ===
embann.c:812:38: note: not consecutive access _60 = MEM[(float *)_256];
embann.c:812:38: note: not consecutive access testFloatWeight_I_lsm0.566_57 = MEM[(float *)_48];
embann.c:812:38: note: not consecutive access testFloatBias_I_lsm0.565_56 = MEM[(float *)_186];
embann.c:812:38: note: not vectorized: no grouped stores in basic block.
embann.c:812:38: note: ===vect_slp_analyze_bb===
embann.c:814:9: note: === vect_analyze_data_refs ===
embann.c:814:9: note: got vectype for stmt: testFloat[_76] = _71;
vector(4) float
embann.c:814:9: note: not vectorized: not enough data-refs in basic block.
embann.c:814:9: note: ===vect_slp_analyze_bb===
embann.c:814:9: note: ===vect_slp_analyze_bb===
embann.c:812:5: note: === vect_analyze_data_refs ===
embann.c:812:5: note: not vectorized: not enough data-refs in basic block.
embann.c:812:5: note: ===vect_slp_analyze_bb===
embann.c:812:5: note: ===vect_slp_analyze_bb===
embann.c:812:5: note: ===vect_slp_analyze_bb===
embann.c:820:5: note: === vect_analyze_data_refs ===
embann.c:820:5: note: got vectype for stmt: pretmp_202 = testFloat[0];
vector(4) float
embann.c:820:5: note: not vectorized: not enough data-refs in basic block.
embann.c:821:19: note: === vect_analyze_data_refs ===
embann.c:821:19: note: got vectype for stmt: _50 = timeAfter.tv_usec;
vector(2) long int
embann.c:821:19: note: got vectype for stmt: _51 = timeBefore.tv_usec;
vector(2) long int
embann.c:821:19: note: === vect_analyze_data_ref_accesses ===
embann.c:821:19: note: not consecutive access _51 = timeBefore.tv_usec;
embann.c:821:19: note: not consecutive access _50 = timeAfter.tv_usec;
embann.c:821:19: note: not vectorized: no grouped stores in basic block.
embann.c:821:19: note: ===vect_slp_analyze_bb===
embann.c:821:15: note: === vect_analyze_data_refs ===
embann.c:821:15: note: not vectorized: not enough data-refs in basic block.
embann.c:821:15: note: ===vect_slp_analyze_bb===
embann.c:822:5: note: === vect_analyze_data_refs ===
embann.c:822:5: note: not vectorized: not enough data-refs in basic block.
embann.c:824:5: note: ===vect_slp_analyze_bb===
embann.c:831:27: note: === vect_analyze_data_refs ===
embann.c:831:27: note: not vectorized: no vectype for stmt: vect__57.494_219 = MEM[(double *)vectp_testDouble.492_221];
 scalar_type: vector(2) double
embann.c:831:27: note: not vectorized: no vectype for stmt: vect__57.495_63 = MEM[(double *)vectp_testDouble.492_220];
 scalar_type: vector(2) double
embann.c:831:27: note: not vectorized: no vectype for stmt: vect__58.498_178 = MEM[(double *)vectp_testDoubleWeight.496_62];
 scalar_type: vector(2) double
embann.c:831:27: note: not vectorized: no vectype for stmt: vect__58.499_69 = MEM[(double *)vectp_testDoubleWeight.496_211];
 scalar_type: vector(2) double
embann.c:831:27: note: not vectorized: no vectype for stmt: vect__60.503_78 = MEM[(double *)vectp_testDoubleBias.501_36];
 scalar_type: vector(2) double
embann.c:831:27: note: not vectorized: no vectype for stmt: vect__60.504_157 = MEM[(double *)vectp_testDoubleBias.501_80];
 scalar_type: vector(2) double
embann.c:831:27: note: not vectorized: no vectype for stmt: MEM[(double *)vectp_testDouble.506_154] = vect__61.505_156;
 scalar_type: vector(2) double
embann.c:831:27: note: not vectorized: no vectype for stmt: MEM[(double *)vectp_testDouble.506_201] = vect__61.505_155;
 scalar_type: vector(2) double
embann.c:831:27: note: not vectorized: no vectype for stmt: MEM[(double *)vectp_testDouble.522_294] = vect__141.521_292;
 scalar_type: vector(2) double
embann.c:831:27: note: not vectorized: no vectype for stmt: MEM[(double *)vectp_testDouble.522_297] = vect__141.521_293;
 scalar_type: vector(2) double
embann.c:831:27: note: === vect_analyze_data_ref_accesses ===
embann.c:831:27: note: not vectorized: no grouped stores in basic block.
embann.c:831:27: note: ===vect_slp_analyze_bb===
embann.c:831:27: note: ===vect_slp_analyze_bb===
embann.c:826:38: note: === vect_analyze_data_refs ===
embann.c:826:38: note: not vectorized: not enough data-refs in basic block.
embann.c:826:38: note: ===vect_slp_analyze_bb===
embann.c:826:38: note: ===vect_slp_analyze_bb===
embann.c:826:38: note: === vect_analyze_data_refs ===
embann.c:826:38: note: not vectorized: not enough data-refs in basic block.
embann.c:826:38: note: ===vect_slp_analyze_bb===
embann.c:826:38: note: === vect_analyze_data_refs ===
embann.c:826:38: note: got vectype for stmt: testDoubleBias_I_lsm0.562_47 = MEM[(double *)_265];
vector(2) double
embann.c:826:38: note: got vectype for stmt: testDoubleWeight_I_lsm0.563_199 = MEM[(double *)_43];
vector(2) double
embann.c:826:38: note: got vectype for stmt: _193 = MEM[(double *)_46];
vector(2) double
embann.c:826:38: note: === vect_analyze_data_ref_accesses ===
embann.c:826:38: note: not consecutive access _193 = MEM[(double *)_46];
embann.c:826:38: note: not consecutive access testDoubleWeight_I_lsm0.563_199 = MEM[(double *)_43];
embann.c:826:38: note: not consecutive access testDoubleBias_I_lsm0.562_47 = MEM[(double *)_265];
embann.c:826:38: note: not vectorized: no grouped stores in basic block.
embann.c:826:38: note: ===vect_slp_analyze_bb===
embann.c:828:9: note: === vect_analyze_data_refs ===
embann.c:828:9: note: got vectype for stmt: testDouble[_189] = _159;
vector(2) double
embann.c:828:9: note: not vectorized: not enough data-refs in basic block.
embann.c:828:9: note: ===vect_slp_analyze_bb===
embann.c:828:9: note: ===vect_slp_analyze_bb===
embann.c:826:5: note: === vect_analyze_data_refs ===
embann.c:826:5: note: not vectorized: not enough data-refs in basic block.
embann.c:826:5: note: ===vect_slp_analyze_bb===
embann.c:826:5: note: ===vect_slp_analyze_bb===
embann.c:826:5: note: ===vect_slp_analyze_bb===
embann.c:834:5: note: === vect_analyze_data_refs ===
embann.c:834:5: note: got vectype for stmt: pretmp_214 = testDouble[0];
vector(2) double
embann.c:834:5: note: not vectorized: not enough data-refs in basic block.
embann.c:835:19: note: === vect_analyze_data_refs ===
embann.c:835:19: note: got vectype for stmt: _64 = timeAfter.tv_usec;
vector(2) long int
embann.c:835:19: note: got vectype for stmt: _65 = timeBefore.tv_usec;
vector(2) long int
embann.c:835:19: note: === vect_analyze_data_ref_accesses ===
embann.c:835:19: note: not consecutive access _65 = timeBefore.tv_usec;
embann.c:835:19: note: not consecutive access _64 = timeAfter.tv_usec;
embann.c:835:19: note: not vectorized: no grouped stores in basic block.
embann.c:835:19: note: ===vect_slp_analyze_bb===
embann.c:835:15: note: === vect_analyze_data_refs ===
embann.c:835:15: note: not vectorized: not enough data-refs in basic block.
embann.c:835:15: note: ===vect_slp_analyze_bb===
embann.c:837:1: note: === vect_analyze_data_refs ===
embann.c:837:1: note: not vectorized: not enough data-refs in basic block.
embann.c:837:1: note: ===vect_slp_analyze_bb===
embann.c:35:5: note: === vect_analyze_data_refs ===
embann.c:35:5: note: got vectype for stmt: _1 = tv.tv_usec;
vector(2) long int
embann.c:35:5: note: got vectype for stmt: _3 = tv.tv_sec;
vector(2) long int
embann.c:35:5: note: === vect_analyze_data_ref_accesses ===
embann.c:35:5: note: Detected interleaving load tv.tv_sec and tv.tv_usec
embann.c:35:5: note: Detected interleaving load of size 2 starting with _3 = tv.tv_sec;
embann.c:35:5: note: not vectorized: no grouped stores in basic block.
embann.c:31:27: note: === vect_analyze_data_refs ===
embann.c:31:27: note: not vectorized: not enough data-refs in basic block.
